<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="正则表达式与文件格式化处理正则表达式（Regular Expression ）是通过一些特殊字符的排列，用来搜索或替换、删除一列或多列文字字符串 本章需要多练习：因为目前很多套件都使用正则表达式来达成过来、分析的目的，为了未来主机管理的便利性，使用者至少要能看懂正则表达式的含义 开始之前：什么是正则表达式 什么是正则表达式： 这个就不解释了，某些指令支持，比如 grep &#39;mail&amp;#39">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础教程(二)">
<meta property="og:url" content="http://example.com/2024/06/18/Linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BA%8C/index.html">
<meta property="og:site_name" content="Cai">
<meta property="og:description" content="正则表达式与文件格式化处理正则表达式（Regular Expression ）是通过一些特殊字符的排列，用来搜索或替换、删除一列或多列文字字符串 本章需要多练习：因为目前很多套件都使用正则表达式来达成过来、分析的目的，为了未来主机管理的便利性，使用者至少要能看懂正则表达式的含义 开始之前：什么是正则表达式 什么是正则表达式： 这个就不解释了，某些指令支持，比如 grep &#39;mail&amp;#39">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/Linux-pid.png">
<meta property="og:image" content="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/linux-fork-exec.png">
<meta property="og:image" content="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/linux-queue-priority.jpg">
<meta property="og:image" content="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/selinux.png">
<meta property="og:image" content="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/crond-domain.png">
<meta property="og:image" content="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/selinux-three-pattern.png">
<meta property="article:published_time" content="2024-06-18T02:38:44.000Z">
<meta property="article:modified_time" content="2024-11-12T02:13:41.491Z">
<meta property="article:author" content="wotzc">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/Linux-pid.png">


<link rel="canonical" href="http://example.com/2024/06/18/Linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BA%8C/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/06/18/Linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BA%8C/","path":"2024/06/18/Linux基础教程-二/","title":"Linux基础教程(二)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux基础教程(二) | Cai</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Cai</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">正则表达式与文件格式化处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">开始之前：什么是正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">基础正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E7%B3%BB%E5%AF%B9%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.2.1.</span> <span class="nav-text">语系对正则表达式的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grep-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%80%89%E9%A1%B9"><span class="nav-number">1.2.2.</span> <span class="nav-text">grep 的一些进阶选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0"><span class="nav-number">1.2.3.</span> <span class="nav-text">基础正则表达式练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B-4%EF%BC%9A%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6-%E4%B8%8E%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.4.</span> <span class="nav-text">范例 4：任意一个字符 . 与重复字符 *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E4%BE%8B-5%EF%BC%9A%E9%99%90%E5%AE%9A%E8%BF%9E%E7%BB%AD-%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6%E8%8C%83%E5%9B%B4"><span class="nav-number">1.2.5.</span> <span class="nav-text">范例 5：限定连续 正则字符范围 &amp;#123;&amp;#125;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AD%97%E7%AC%A6%E6%B1%87%E6%80%BB"><span class="nav-number">1.3.</span> <span class="nav-text">基础正则表示法字符汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sed-%E5%B7%A5%E5%85%B7"><span class="nav-number">1.3.1.</span> <span class="nav-text">sed 工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E8%A1%8C%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%96%B0%E5%A2%9E-%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">以行为单位的新增&#x2F;删除功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E8%A1%8C%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E5%8F%96%E4%BB%A3%E6%98%BE%E7%A4%BA%E5%8A%9F%E8%83%BD"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">以行为单位的取代显示功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%90%9C%E7%B4%A2%E5%B9%B6%E6%9B%BF%E6%8D%A2%E5%8A%9F%E8%83%BD"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">部分数据的搜索并替换功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%88%E5%8D%B1%E9%99%A9%E5%8A%A8%E4%BD%9C%EF%BC%89"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">直接修改文件内容（危险动作）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E6%AD%A3%E5%88%99%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">延伸正则表示法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">文件的格式化与相关处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0%EF%BC%9Aprintf"><span class="nav-number">1.5.1.</span> <span class="nav-text">格式化打印：printf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#awk%EF%BC%9A%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">1.5.2.</span> <span class="nav-text">awk：好用的数据处理工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#awk-%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%AD%97%E7%AC%A6"><span class="nav-number">1.5.3.</span> <span class="nav-text">awk 的逻辑运算字符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7"><span class="nav-number">1.6.</span> <span class="nav-text">文件比对工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#diff"><span class="nav-number">1.6.1.</span> <span class="nav-text">diff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cmp"><span class="nav-number">1.6.2.</span> <span class="nav-text">cmp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#patch"><span class="nav-number">1.6.3.</span> <span class="nav-text">patch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%8D%B0%E5%87%86%E5%A4%87%EF%BC%9Apr"><span class="nav-number">1.6.4.</span> <span class="nav-text">文件打印准备：pr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0-Shell-Scripts"><span class="nav-number">2.</span> <span class="nav-text">学习 Shell Scripts</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Shell-Scripts"><span class="nav-number">2.1.</span> <span class="nav-text">什么是 Shell Scripts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0-shell-scripts"><span class="nav-number">2.2.</span> <span class="nav-text">为什么要学习 shell scripts?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%94%AF-script-%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="nav-number">2.3.</span> <span class="nav-text">第一支 script 的编写与执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hello-World"><span class="nav-number">2.3.1.</span> <span class="nav-text">Hello World</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99-shell-script-%E7%9A%84%E8%89%AF%E5%A5%BD%E4%B9%A0%E6%83%AF%E5%BB%BA%E7%AB%8B"><span class="nav-number">2.4.</span> <span class="nav-text">编写 shell script 的良好习惯建立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84-Shell-Script-%E7%BB%83%E4%B9%A0"><span class="nav-number">2.5.</span> <span class="nav-text">简单的 Shell Script 练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%8C%83%E4%BE%8B"><span class="nav-number">2.5.1.</span> <span class="nav-text">简单范例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B0%88%E5%BC%8F%E8%84%9A%E6%9C%AC%EF%BC%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%AE%B9%E7%94%B1%E7%94%A8%E6%88%B7%E5%86%B3%E5%AE%9A"><span class="nav-number">2.5.2.</span> <span class="nav-text">对谈式脚本：变量类容由用户决定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%97%A5%E6%9C%9F%E5%8F%98%E5%8C%96%EF%BC%9A%E5%88%A9%E7%94%A8-date-%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">2.5.3.</span> <span class="nav-text">随日期变化：利用 date 进行文件的建立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="nav-number">2.5.4.</span> <span class="nav-text">数值运算：简单的加减乘除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%EF%BC%9A%E9%80%9A%E8%BF%87-bc-%E8%AE%A1%E7%AE%97-pi"><span class="nav-number">2.5.5.</span> <span class="nav-text">数值运算：通过 bc 计算 pi</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#script-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F%E5%B7%AE%E5%BC%82%EF%BC%88source%E3%80%81sh-script%E3%80%81-script%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">script 的执行方式差异（source、sh script、.&#x2F;script）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%89%A7%E8%A1%8C-script%EF%BC%9A%E5%9C%A8%E5%AD%90%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%89%A7%E8%A1%8C"><span class="nav-number">2.6.1.</span> <span class="nav-text">利用直接执行的方式来执行 script：在子程序中执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-source-%E6%9D%A5%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%EF%BC%9A%E5%9C%A8%E7%88%B6%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%89%A7%E8%A1%8C"><span class="nav-number">2.6.2.</span> <span class="nav-text">利用 source 来执行脚本：在父程序中执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%96%84%E7%94%A8%E5%88%A4%E6%96%AD"><span class="nav-number">2.7.</span> <span class="nav-text">善用判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-test-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="nav-number">2.7.1.</span> <span class="nav-text">使用 test 指令的测试功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%88%A4%E6%96%AD%E7%AC%A6%E5%8F%B7"><span class="nav-number">2.7.2.</span> <span class="nav-text">利用判断符号 []</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shell-script-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%98%E9%87%8F-0-1"><span class="nav-number">2.7.3.</span> <span class="nav-text">shell script 的默认变量 $0,$1...</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shift%EF%BC%9A%E9%80%A0%E6%88%90%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E4%BD%8D%E7%BD%AE%E5%81%8F%E7%A7%BB"><span class="nav-number">2.7.4.</span> <span class="nav-text">shift：造成参数变量位置偏移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">2.8.</span> <span class="nav-text">条件判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-if-then"><span class="nav-number">2.8.1.</span> <span class="nav-text">利用 if...then</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-case-esac-%E5%88%A4%E6%96%AD"><span class="nav-number">2.8.2.</span> <span class="nav-text">利用 case...esac 判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-function-%E5%8A%9F%E8%83%BD"><span class="nav-number">2.8.3.</span> <span class="nav-text">利用 function 功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%EF%BC%88loop%EF%BC%89"><span class="nav-number">2.9.</span> <span class="nav-text">循环（loop）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while-do-done%E3%80%81until-do-done%EF%BC%88%E4%B8%8D%E5%AE%9A%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="nav-number">2.9.1.</span> <span class="nav-text">while do done、until do done（不定循环）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-do-done-%E5%9B%BA%E5%AE%9A%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.9.2.</span> <span class="nav-text">for...do...done 固定循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-do-done-%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86"><span class="nav-number">2.9.3.</span> <span class="nav-text">for...do...done 数值处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%AD%E9%85%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E9%AA%8C"><span class="nav-number">2.9.4.</span> <span class="nav-text">搭配随机数与数组的实验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-Script-%E7%9A%84%E8%BF%BD%E8%B8%AA%E4%B8%8E-debug"><span class="nav-number">2.10.</span> <span class="nav-text">Shell Script 的追踪与 debug</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E-SELinux-%E5%88%9D%E6%8E%A2"><span class="nav-number">3.</span> <span class="nav-text">进程管理与 SELinux 初探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%88process%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">什么是进程（process）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F-%EF%BC%88process-amp-program%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">进程与程序 （process &amp; program）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%88%B6%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.2.</span> <span class="nav-text">子进程与父进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-and-exec%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%91%BC%E5%8F%AB%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">fork and exec：进程呼叫的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%88%96%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%B8%B8%E9%A9%BB%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.4.</span> <span class="nav-text">系统或网络服务：常驻在内存的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%9A%84%E5%A4%9A%E4%BA%BA%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83"><span class="nav-number">3.1.5.</span> <span class="nav-text">Linux 的多人多任务环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%AE%A1%E7%90%86%EF%BC%88job-control%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">工作管理（job control）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E4%BD%9C%E7%AE%A1%E7%90%86%EF%BC%9F"><span class="nav-number">3.2.1.</span> <span class="nav-text">什么是工作管理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#job-control-%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">3.2.2.</span> <span class="nav-text">job control 的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%B0%86%E6%8C%87%E4%BB%A4%E4%B8%A2%E5%88%B0%E8%83%8C%E6%99%AF%E4%B8%AD-%E6%89%A7%E8%A1%8C-%E7%9A%84-amp"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">直接将指令丢到背景中 执行 的 &amp;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86-%E7%9B%AE%E5%89%8D-%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%B8%A2%E5%88%B0%E8%83%8C%E6%99%AF%E4%B8%AD-%E6%9A%82%E5%81%9C-%EF%BC%9Actrl-z"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">将 目前 的工作丢到背景中_暂停_：ctrl+z</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E7%9B%AE%E5%89%8D%E7%9A%84%E8%83%8C%E6%99%AF%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81%EF%BC%9Ajobs"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">观察目前的背景工作状态：jobs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E8%83%8C%E6%99%AF%E5%B7%A5%E4%BD%9C%E6%8B%BF%E5%88%B0%E5%89%8D%E6%99%AF%E6%9D%A5%E5%A4%84%E7%90%86%EF%BC%9Afg"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">将背景工作拿到前景来处理：fg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A9%E5%B7%A5%E4%BD%9C%E5%9C%A8%E8%83%8C%E6%99%AF%E4%B8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E6%88%90%E8%BF%90%E8%A1%8C%E4%B8%AD%EF%BC%9Abg"><span class="nav-number">3.2.2.5.</span> <span class="nav-text">让工作在背景下的状态变成运行中：bg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E8%83%8C%E6%99%AF%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%EF%BC%9Akill"><span class="nav-number">3.2.2.6.</span> <span class="nav-text">管理背景中的工作：kill</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%B1%E6%9C%BA%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.3.</span> <span class="nav-text">脱机管理问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%82%E5%AF%9F"><span class="nav-number">3.3.1.</span> <span class="nav-text">进程的观察</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ps%EF%BC%9A%E5%B0%86%E6%9F%90%E4%B8%AA%E6%97%B6%E9%97%B4%E7%82%B9%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5%E6%88%AA%E5%8F%96%E4%B8%8B%E6%9D%A5"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">ps：将某个时间点的进程运行情况截取下来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%85%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1%E7%9A%84-bash-%E7%9B%B8%E5%85%B3%E8%BF%9B%E7%A8%8B%EF%BC%9Aps-l"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">仅查看自己的 bash 相关进程：ps -l</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E7%B3%BB%E7%BB%9F%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B%EF%BC%9Aps-aux"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">观察系统所有进程：ps aux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-zombie"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">僵尸进程 zombie</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#top%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%82%E5%AF%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">3.3.2.</span> <span class="nav-text">top：动态观察进程的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pstree"><span class="nav-number">3.3.3.</span> <span class="nav-text">pstree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.4.</span> <span class="nav-text">进程的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill-signal-PID"><span class="nav-number">3.3.5.</span> <span class="nav-text">kill -signal PID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#killall-signal-%E6%8C%87%E4%BB%A4%E5%90%8D%E7%A7%B0"><span class="nav-number">3.3.6.</span> <span class="nav-text">killall -signal 指令名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.3.7.</span> <span class="nav-text">关于程序的执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Priority-%E4%B8%8E-Nice-%E5%80%BC"><span class="nav-number">3.3.7.1.</span> <span class="nav-text">Priority 与 Nice 值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nice%EF%BC%9A%E6%96%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8C%87%E4%BB%A4%E7%BB%99%E4%BA%88%E6%96%B0%E7%9A%84-nice-%E5%80%BC"><span class="nav-number">3.3.7.2.</span> <span class="nav-text">nice：新执行的指令给予新的 nice 值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#renice%EF%BC%9A%E5%B7%B2%E5%AD%98%E5%9C%A8%E8%BF%9B%E7%A8%8B%E7%9A%84-nice-%E9%87%8D%E6%96%B0%E8%B0%83%E6%95%B4"><span class="nav-number">3.3.7.3.</span> <span class="nav-text">renice：已存在进程的 nice 重新调整</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9A%84%E8%A7%82%E5%AF%9F"><span class="nav-number">3.3.8.</span> <span class="nav-text">系统资源的观察</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free%EF%BC%9A%E8%A7%82%E5%AF%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">3.3.9.</span> <span class="nav-text">free：观察内存使用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uname%EF%BC%9A%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-number">3.3.10.</span> <span class="nav-text">uname：查询系统与核心相关信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uptime%EF%BC%9A%E8%A7%82%E5%AF%9F%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E4%B8%8E%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD"><span class="nav-number">3.3.11.</span> <span class="nav-text">uptime：观察系统启动时间与工作负载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netstat%EF%BC%9A%E8%BF%BD%E8%B8%AA%E7%BD%91%E7%BB%9C%E6%88%96%E6%8F%92%E6%A7%BD%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.12.</span> <span class="nav-text">netstat：追踪网络或插槽文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dmesg%EF%BC%9A%E5%88%86%E6%9E%90%E6%A0%B8%E5%BF%83%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">3.3.13.</span> <span class="nav-text">dmesg：分析核心产生的信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vmstat%EF%BC%9A%E4%BE%A6%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E5%8F%98%E5%8C%96"><span class="nav-number">3.3.14.</span> <span class="nav-text">vmstat：侦测系统资源变化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">特殊文件与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E6%9C%89-SUID%E3%80%81SGID-%E6%9D%83%E9%99%90%E7%9A%84%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="nav-number">3.4.1.</span> <span class="nav-text">具有 SUID、SGID 权限的指令执行状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proc-%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">3.4.2.</span> <span class="nav-text">&#x2F;proc&#x2F;* 代表的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%B7%B2%E5%BC%80%E5%90%AF%E6%96%87%E4%BB%B6%E6%88%96%E5%B7%B2%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%90%AF%E4%B9%8B%E6%96%87%E4%BB%B6"><span class="nav-number">3.4.3.</span> <span class="nav-text">查询已开启文件或已执行进程开启之文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fuser%EF%BC%9A%E7%94%B1%E6%96%87%E4%BB%B6%EF%BC%88%E6%88%96%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89%E6%89%BE%E5%87%BA%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">fuser：由文件（或文件系统）找出正在使用该文件的进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lsof%EF%BC%9A%E5%88%97%E5%87%BA%E8%A2%AB%E8%BF%9B%E7%A8%8B%E6%89%80%E5%BC%80%E5%90%AF%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">lsof：列出被进程所开启的文件名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pidof%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9F%90%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84-PID"><span class="nav-number">3.4.4.</span> <span class="nav-text">pidof：找出某个正在运行的程序的 PID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SELinux-%E5%88%9D%E6%8E%A2"><span class="nav-number">3.5.</span> <span class="nav-text">SELinux 初探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SELinux"><span class="nav-number">3.5.1.</span> <span class="nav-text">什么是 SELinux</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%88%9D%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%AE%E6%A0%87%EF%BC%9A%E9%81%BF%E5%85%8D%E8%B5%84%E6%BA%90%E7%9A%84%E8%AF%AF%E7%94%A8"><span class="nav-number">3.5.2.</span> <span class="nav-text">当初设计的目标：避免资源的误用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E8%B4%A6%E6%88%B7%E5%85%B3%E7%B3%BB%EF%BC%9A%E8%87%AA%E4%B8%BB%E5%BC%8F%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-DAC"><span class="nav-number">3.5.3.</span> <span class="nav-text">传统的文件权限与账户关系：自主式访问控制 DAC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E6%94%BF%E7%AD%96%E8%A7%84%E5%88%99%E8%A7%84%E5%AE%9A%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%8F%96%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6%EF%BC%9A%E5%A7%94%E4%BB%BB%E5%BC%8F%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-MAC"><span class="nav-number">3.5.4.</span> <span class="nav-text">以政策规则规定特定进程读取特定文件：委任式访问控制 MAC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E6%9C%AC%E6%96%87-Security-Context"><span class="nav-number">3.5.5.</span> <span class="nav-text">安全性本文 Security Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%96%87%E4%BB%B6-SELinux-type-%E5%AD%97%E6%AE%B5%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7"><span class="nav-number">3.5.6.</span> <span class="nav-text">进程与文件 SELinux type 字段的相关性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELinux-%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E3%80%81%E5%85%B3%E9%97%AD%E4%B8%8E%E8%A7%82%E5%AF%9F"><span class="nav-number">3.5.7.</span> <span class="nav-text">SELinux 三种模式的启动、关闭与观察</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SElinux-%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-number">3.5.8.</span> <span class="nav-text">SElinux 的启动与关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELinux-%E6%94%BF%E7%AD%96%E5%86%85%E7%9A%84%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86"><span class="nav-number">3.5.9.</span> <span class="nav-text">SELinux 政策内的规则管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SELinux-%E5%90%84%E4%B8%AA%E8%A7%84%E5%88%99%E7%9A%84%E5%B8%83%E5%B0%94%E5%80%BC%E6%9F%A5%E8%AF%A2%EF%BC%9Agetsebool"><span class="nav-number">3.5.9.1.</span> <span class="nav-text">SELinux 各个规则的布尔值查询：getsebool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SELinux-%E5%90%84%E4%B8%AA%E8%A7%84%E5%88%99%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%BB%E4%BD%93%E8%BF%9B%E7%A8%8B%E8%83%BD%E5%A4%9F%E8%AF%BB%E5%8F%96%E7%9A%84%E6%96%87%E4%BB%B6-SELinux-type-%E6%9F%A5%E8%AF%A2-seinfo%E3%80%81sesearch"><span class="nav-number">3.5.9.2.</span> <span class="nav-text">SELinux 各个规则规范的主体进程能够读取的文件 SELinux type 查询 seinfo、sesearch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-SELinux-%E8%A7%84%E5%88%99%E7%9A%84%E5%B8%83%E5%B0%94%E5%80%BC-setsebool"><span class="nav-number">3.5.9.3.</span> <span class="nav-text">修改 SELinux 规则的布尔值 setsebool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELinux-%E5%AE%89%E5%85%A8%E6%9C%AC%E6%96%87%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">3.5.10.</span> <span class="nav-text">SELinux 安全本文的修改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-chcon-%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%9A%84-SELinux-type"><span class="nav-number">3.5.10.1.</span> <span class="nav-text">使用 chcon 手动修改文件的 SELinux type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-restorecon-%E8%AE%A9%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%AD%A3%E7%A1%AE%E7%9A%84-SELinux-type"><span class="nav-number">3.5.10.2.</span> <span class="nav-text">使用 restorecon 让文件恢复正确的 SELinux type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#semanage-%E9%BB%98%E8%AE%A4%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%9C%AC%E6%96%87%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="nav-number">3.5.10.3.</span> <span class="nav-text">semanage 默认目录的安全性本文查询与修改</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A1%88%E4%BE%8B%E5%8F%8A%E7%99%BB%E5%BD%95%E6%96%87%E4%BB%B6%E5%8D%8F%E5%8A%A9"><span class="nav-number">3.6.</span> <span class="nav-text">一个网络服务案例及登录文件协助</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setroubleshoot%EF%BC%9A%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%86%99%E5%85%A5-var-log-messages"><span class="nav-number">3.6.1.</span> <span class="nav-text">setroubleshoot：错误信息写入 &#x2F;var&#x2F;log&#x2F;messages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A%E9%80%9A%E8%BF%87-vsftpd-%E8%BF%99%E4%B8%AA-FTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E5%AD%98%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">3.6.2.</span> <span class="nav-text">实例说明：通过 vsftpd 这个 FTP 服务器来存取系统上的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E8%80%85%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.3.</span> <span class="nav-text">匿名者无法下载的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E4%BB%8E%E5%AE%B6%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="nav-number">3.6.4.</span> <span class="nav-text">无法从家目录下载文件的问题分析与解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E8%B4%A6%E6%88%B7%E7%94%A8%E6%88%B7%E4%BB%8E%E9%9D%9E%E6%AD%A3%E8%A7%84%E7%9B%AE%E5%BD%95%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="nav-number">3.6.5.</span> <span class="nav-text">一般账户用户从非正规目录上传&#x2F;下载文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E5%8F%98%E6%9B%B4-FTP-%E8%81%94%E6%9C%BA%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E8%A7%A3%E5%86%B3"><span class="nav-number">3.6.6.</span> <span class="nav-text">无法变更 FTP 联机端口问题分析解决</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wotzc"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">wotzc</p>
  <div class="site-description" itemprop="description">真正的大师永远都怀着一颗学徒的心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/18/Linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux基础教程(二) | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux基础教程(二)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-18 10:38:44" itemprop="dateCreated datePublished" datetime="2024-06-18T10:38:44+08:00">2024-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-12 10:13:41" itemprop="dateModified" datetime="2024-11-12T10:13:41+08:00">2024-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="正则表达式与文件格式化处理"><a href="#正则表达式与文件格式化处理" class="headerlink" title="正则表达式与文件格式化处理"></a>正则表达式与文件格式化处理</h1><p>正则表达式（<strong>Regular Expression</strong> ）是通过一些特殊字符的排列，用来搜索或替换、删除一列或多列文字字符串</p>
<p>本章需要多练习：因为目前很多套件都使用正则表达式来达成过来、分析的目的，为了未来主机管理的便利性，使用者至少要能看懂正则表达式的含义</p>
<h2 id="开始之前：什么是正则表达式"><a href="#开始之前：什么是正则表达式" class="headerlink" title="开始之前：什么是正则表达式"></a>开始之前：什么是正则表达式</h2><ul>
<li><p>什么是正则表达式：</p>
<p>这个就不解释了，某些指令支持，比如 <code>grep &#39;mail&#39; /lib/systemd/system/*</code> 搜索该目录下的所有文件中包含 <strong>mail</strong> 的文件，但是 <strong>cp ls</strong> 等命令不支持正则表达式，只能使用 <strong>bash</strong> 自己本身的通配符</p>
</li>
<li><p>正则表达式对于系统管理员的用途</p>
<p>对于一般使用者来说，使用不多，对于系统管理员来说，是必学的知识，如 错误信息登录文件（第十八章中）的内容记录了系统产生的所有信息，包含是否被入侵的记录数据，可以通过正则表达式将这些登录信息进行处理，仅取出有问题的信息进行分析</p>
</li>
<li><p>正则表达式的广泛用途</p>
<p>由于正则表达式强大的字符串处理能力，一堆软件都支持</p>
</li>
<li><p>正则表达式与 <strong>shell</strong> 在 <strong>Linux</strong> 中的角色定位</p>
<p>这样说吧，小学的 九九乘法表 有多重要，<strong>shell</strong> 与 正则表达式就有多重要</p>
</li>
<li><p>扩展的正则表达式</p>
<p>正则表达式的字符串表示方式依照不同的严谨程度分为：基础正则表达式、扩展正则表达式。</p>
</li>
</ul>
<h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>既然正则表达式是处理字符串的一种表示方式，那么对字符排序有影响的语系数据就会对正则表达式的结果有影响。此外也需要有支持工具程序来辅助才行。</p>
<p>因此这里先介绍一个最简单的字符串摘取工具程序 <strong>grep</strong>。前面讲解了 <strong>grep</strong> 的相关参数与参数，本章着重讲解进阶的 <strong>grep</strong> 选项说明，介绍完 <strong>grep</strong> 的功能后，就进入正则表达式的特殊字符处理能力</p>
<h3 id="语系对正则表达式的影响"><a href="#语系对正则表达式的影响" class="headerlink" title="语系对正则表达式的影响"></a>语系对正则表达式的影响</h3><p>为什么语系数据会影响正则表达式的输出结果？在第 0 章计算器概论的文字编码系统里面谈到，文件其实记录的仅有 <strong>0</strong> 与 <strong>1</strong>，我们看到的字符与数值都是通过编码表转换来的。</p>
<p>由于不同语系的编码数据不同，就会造成数据处理结果的差异了，举例说明，假设两种语系输出结果为：</p>
<ul>
<li><strong>LANG=C：0 1 2 3 … A B C D ..Z a b c d .. z</strong></li>
<li><strong>LANG=zh_TW ：0 1 2 3 … a A b c C D .. z Z</strong></li>
</ul>
<p>两种语系明显不一样，如果想获取大写字符使用 <code>[A-Z]</code>时，会发现 <strong>C</strong> 可以获取到正确的大写字符（因为是连续的），<strong>zh_TW</strong> 连同小写也会 b-z 也会获取到，因为就编码的顺序来看，<strong>big5</strong> 语系可以获取到 <code>A b B c C .. z Z</code> 这一堆字符。</p>
<p>所以使用正则表达式时，需要留意当前的语系，否则可能发现与别人不同的截取结果</p>
<p>由于一般我们再联系正则表达式时，使用的是兼容于 <strong>POSIX</strong> 的标准，因此就使用 <strong>C</strong> 这个语系，因此下面的练习都是使用 <code>LANG=C</code>来练习的。为了避免这样编码所造成的英文与数字截取问题，因此特殊符号需要了解下</p>
<ul>
<li><code>[:alnum:]</code>：代表英文大小写字符及数字，即 <strong>0-9</strong>、<strong>A-Z</strong>、<strong>a-z</strong></li>
<li><code>[:alpha:]</code>：代表任何英文大小写字符，<strong>A-Z</strong>、<strong>a-z</strong></li>
<li><code>[:blank:]</code>：代表空格与 <strong>tab</strong></li>
<li><code>[:cntrl:]</code>：代表键盘上面的控制按键，包括 <strong>CR</strong>、<strong>LF</strong>、<strong>TAB</strong>、<strong>Del</strong> 等</li>
<li><code>[:digit:]</code>：代表数字，<strong>0-9</strong></li>
<li><code>[:graph:]</code>：除了空格符（空格键与 <strong>tab</strong> 键）外其他的所有按键</li>
<li><code>[:lower:]</code>：代表些小字符，<strong>a-z</strong></li>
<li><code>[:print:]</code>：代表任何可以被打印出来的字符</li>
<li><code>[:punct:]</code>：代表标点符号（<strong>punctuation symbol</strong>）</li>
<li><code>[:upper:]</code>：代表大写字符，<strong>A-Z</strong></li>
<li><code>[:space:]</code>：任何会产生空白的字符，包括空格、<strong>tab</strong>、<strong>CR</strong> 等</li>
<li><code>[:xdigit:]</code>：代表 <strong>16</strong> 进制的数值类型，包括 <strong>0-9</strong>、<strong>A-F</strong>、<strong>a-f</strong> 的数字与字符</li>
</ul>
<p>尤其是 <code>[:alnum:]</code>、<code>[:alpha:]</code>、<code>[:upper:]</code>、<code>[:lower:]</code>、<code>[:digit:]</code>一定要知道代表什么意思，因为他们要比 <strong>a-z</strong> 或 <strong>A-Z</strong> 的用途要确定。</p>
<h3 id="grep-的一些进阶选项"><a href="#grep-的一些进阶选项" class="headerlink" title="grep 的一些进阶选项"></a>grep 的一些进阶选项</h3><p>在第十章 <strong>BASH</strong> 中的 <strong>grep</strong> 谈论过一些基础用法，下面列出较进阶的 <strong>grep</strong> 选项与参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep [-A] [-B] [--color=<span class="string">&#x27;auto&#x27;</span>] <span class="string">&#x27;关键词&#x27;</span> filename</span><br><span class="line"></span><br><span class="line">-A：后面可以加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来</span><br><span class="line">-B：后面可以加数字，为 befer 的意思，处理列出该行外，前面的 n 行也列出来</span><br><span class="line">--colort=auto：可将正确的哪个截取数据列出颜色</span><br></pre></td></tr></table></figure>

<p>实践与练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：用 dmesg 列出核心信息，再以 grep 找出含有 qx1 那一行</span></span><br><span class="line">dmesg | grep <span class="string">&#x27;qx1&#x27;</span></span><br><span class="line"><span class="comment"># 笔者不知道自己使用的显卡是什么，而且使用的是虚拟机，而作者使用的显卡是 qx1，所以查看显卡信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：用 --color=auto 显示查找到的关键词高亮,并显示行号</span></span><br><span class="line">dmesg | grep -n --color=auto ‘qx1’</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：在关键词所在行的前两行与后三行也一起显示出来</span></span><br><span class="line">dmest | grep -n -A2 -B3 --color=auto <span class="string">&#x27;qx1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>grep</strong> 是一个很常见也很常用的指令，最重要的功能就是进行字符串的比对，然后将符合用户需求的字符串打印出来。需要注意的是：<strong>grep</strong> 是已整行为单位来进行数据截取的</p>
<h3 id="基础正则表达式练习"><a href="#基础正则表达式练习" class="headerlink" title="基础正则表达式练习"></a>基础正则表达式练习</h3><p>要了解正则表达式最简单的方法就是由实际练习去感受，所以在汇总特殊符号前，先以下面这个文件的内容来进行正则表达式的练习，练习前提为：</p>
<ul>
<li>语系已经使用 <code>export LANG=C；export LC_ALL=C</code></li>
<li><strong>grep</strong> 已经使用 <strong>alias</strong> 设置为 <code>grep --color=auto</code></li>
</ul>
<p>本机默认为 <code>LANG=en_US.UTF-8;LC_ALL=</code></p>
<p>文件为 <strong>regular——express.txt</strong> ，该文件内容是在 <strong>windows</strong> 系统下编辑的，所以包含 <strong>dos</strong> 的换行符；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">apple is my favorite food.</span><br><span class="line">Football game is not use feet only.</span><br><span class="line">this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">However, this dress is about $ 3183 dollars.</span></span><br><span class="line"><span class="string">GNU is free air not free beer.</span></span><br><span class="line"><span class="string">Her hair is very beauty.</span></span><br><span class="line"><span class="string">I can&#x27;</span>t finish the <span class="built_in">test</span>.</span><br><span class="line">Oh! The soup taste good.</span><br><span class="line">motorcycle is cheap than car.</span><br><span class="line">This window is clear.</span><br><span class="line">the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line">Oh!	My god!</span><br><span class="line">The gd software is a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">You are the best is mean you are the no. 1.</span><br><span class="line">The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">I like dog.</span><br><span class="line">google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">goooooogle yes!</span><br><span class="line">go! go! Let<span class="string">&#x27;s go.</span></span><br><span class="line"><span class="string"># I am VBird</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p><strong>范例 1：搜索特定字符</strong></p>
<p>从文件中取得 <strong>the</strong> 这个特定字符串，最简单的方式如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">8:I can<span class="string">&#x27;t finish the test.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="string">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br></pre></td></tr></table></figure>

<p>反向选择，可以看到输出结果少了上面的 <strong>8、12、15、16、18</strong> 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -vn <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">4:this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">5:However, this dress is about $ 3183 dollars.</span></span><br><span class="line"><span class="string">6:GNU is free air not free beer.</span></span><br><span class="line"><span class="string">7:Her hair is very beauty.</span></span><br><span class="line"><span class="string">9:Oh! The soup taste good.</span></span><br><span class="line"><span class="string">10:motorcycle is cheap than car.</span></span><br><span class="line"><span class="string">11:This window is clear.</span></span><br><span class="line"><span class="string">13:Oh!  My god!</span></span><br><span class="line"><span class="string">14:The gd software is a library for drafting programs.</span></span><br><span class="line"><span class="string">17:I like dog.</span></span><br><span class="line"><span class="string">19:goooooogle yes!</span></span><br><span class="line"><span class="string">20:go! go! Let&#x27;</span>s go.</span><br><span class="line">21:<span class="comment"># I am VBird</span></span><br><span class="line">22:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>忽略大小写 ，多出来几行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -<span class="keyword">in</span> <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">8:I can<span class="string">&#x27;t finish the test.</span></span><br><span class="line"><span class="string">9:Oh! The soup taste good.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">14:The gd software is a library for drafting programs.</span></span><br><span class="line"><span class="string">15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="string">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br></pre></td></tr></table></figure>

<p><strong>范例 2：利用中括号<code>[]</code>来搜索集合字符</strong></p>
<p>如果要搜索 test 或 taste 这两个单词时，可以发现他们其实有共同的 <code>t?st</code> 存在</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n &#x27;t[ae]st&#x27; regular_express.txt</span><br><span class="line">8:I can&#x27;t finish the test.</span><br><span class="line">9:Oh! The soup taste good.</span><br></pre></td></tr></table></figure>

<p>中括号中，无论几个字符都表示任意一个字符。如果想要搜索到所有 <strong>oo</strong> 字符时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;oo&#x27;</span> regular_express.txt</span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure>

<p>如果不想要 <strong>oo</strong> 前面的 <strong>g</strong> 呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[^g]oo&#x27;</span> regular_express.txt</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure>

<p>会发现可能会有一部分是正确的，一部分是错误的，比如 <strong>1</strong>、<strong>9</strong> 行少了，但是 <strong>google</strong> 和 <strong>goooooogle</strong> 还是出来了，是怎么回事？第 <strong>18</strong> 行，出现了 <strong>tools</strong> 所以也符合 <code>[^g]oo</code>，而 <strong>19</strong> 行，中间有那么多的 <strong>oo</strong>，也符合</p>
<p>继续，不想要 <strong>oo</strong> 前面是小写字符的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于小写字符的 ASCII 编码顺序是连续的，所以可以简化为，否则就需要把 a-z 都写出来</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[^a-z]oo&#x27;</span> regular_express.txt</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得有数字那一行</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[0-9]&#x27;</span> regular_express.txt</span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于考虑到语系对于编码顺序的影响，因此除了连续编码使用减号 <code>-</code>，还可以使用如下的方法来取得前面两个测试的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[^[:lower:]]oo&#x27;</span> regular_express.txt</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line"></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[[:digit:]]&#x27;</span> regular_express.txt</span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br></pre></td></tr></table></figure>

<p><strong>范例 3：行首与行尾字符</strong> <code>^、$</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只要行首是 the 的</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^the&#x27;</span> regular_express.txt </span><br><span class="line">12:the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要行首是小写字符开头的</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^[a-z]&#x27;</span> regular_express.txt </span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">4:this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">10:motorcycle is cheap than car.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br><span class="line"><span class="string">19:goooooogle yes!</span></span><br><span class="line"><span class="string">20:go! go! Let&#x27;</span>s go.</span><br><span class="line"><span class="comment"># 下面的等效</span></span><br><span class="line"><span class="comment"># [mrcode@study tmp]$ grep -n &#x27;^[[:lower:]]&#x27; regular_express.txt </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要英文字母开头的</span></span><br><span class="line"><span class="comment"># ^ 在中括号内表示反选，在外表示定位首航</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^[^a-zA-Z]&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">21:<span class="comment"># I am VBird</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>行尾练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出行尾为 . 符号的数据</span></span><br><span class="line"><span class="comment"># 使用 \ 对 小数点转义</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;\.$&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">4:this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">5:However, this dress is about $ 3183 dollars.</span></span><br><span class="line"><span class="string">6:GNU is free air not free beer.</span></span><br><span class="line"><span class="string">7:Her hair is very beauty.</span></span><br><span class="line"><span class="string">8:I can&#x27;</span>t finish the <span class="built_in">test</span>.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">10:motorcycle is cheap than car.</span><br><span class="line">11:This window is clear.</span><br><span class="line">12:the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">17:I like dog.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">20:go! go! Let<span class="string">&#x27;s go.</span></span><br></pre></td></tr></table></figure>

<p>这里需要说一句，原本的文件 <strong>5-9</strong> 行默认是 <code>.^M$</code> 结尾的，也就是 <code>\r\n</code>，由于没有网络，无法下载文件，所以复制粘贴丢失了这些换行符，和书上结果不一样。</p>
<p>也就是说上面的示例 <strong>5-9</strong> 不应该出来的，使用命令查看特殊字符应该如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ cat -An regular_express.txt | head -n 10 | tail -n 6</span><br><span class="line">     5  However, this dress is about $ 3183 dollars.^M$</span><br><span class="line">     6  GNU is free air not free beer.^M$</span><br><span class="line">     7  Her hair is very beauty.^M$</span><br><span class="line">     8  I can<span class="string">&#x27;t finish the test.^M$</span></span><br><span class="line"><span class="string">     9  Oh! The soup taste good.^M$</span></span><br><span class="line"><span class="string">    10  motorcycle is cheap than car.$		# 但实际上 ^M 被丢失了</span></span><br></pre></td></tr></table></figure>

<p>找出空白行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^$&#x27;</span> regular_express.txt </span><br><span class="line">22:</span><br><span class="line"><span class="comment"># 只有行首和行尾的表示法，中间没有任何字符，所以是 ^$</span></span><br></pre></td></tr></table></figure>

<p>假设你已经知道 <strong>shell script</strong> 或则是配置文件中，空白行与开头为 <strong>#</strong> 的那一行是批注，想要将这些数据忽略掉，该怎么做？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ cat -n /etc/rsyslog.conf </span><br><span class="line"><span class="comment"># 在 centOS 7 中可以看到有 91 行，有大量的空行与批注信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种写法：-v &#x27;^$&#x27; 是反选，也就是排除空行的，-v ‘^#’ 排除开头是 # 号的</span></span><br><span class="line"><span class="comment"># 但是这里的行号与源文件对不上了，后面的行号是针对前面排除空行后的行号</span></span><br><span class="line">[mrcode@study tmp]$ grep -v <span class="string">&#x27;^$&#x27;</span> /etc/rsyslog.conf | grep -vn <span class="string">&#x27;^#&#x27;</span></span><br><span class="line">6:<span class="variable">$ModLoad</span> imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span><br><span class="line">7:<span class="variable">$ModLoad</span> imjournal <span class="comment"># provides access to the systemd journal</span></span><br><span class="line">18:<span class="variable">$WorkDirectory</span> /var/lib/rsyslog</span><br><span class="line">20:<span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span><br><span class="line">25:<span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span><br><span class="line">28:<span class="variable">$OmitLocalLogging</span> on</span><br><span class="line">30:<span class="variable">$IMJournalStateFile</span> imjournal.state</span><br><span class="line">37:*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages</span><br><span class="line">39:authpriv.*                                              /var/<span class="built_in">log</span>/secure</span><br><span class="line">41:mail.*                                                  -/var/<span class="built_in">log</span>/maillog</span><br><span class="line">43:cron.*                                                  /var/<span class="built_in">log</span>/cron</span><br><span class="line">45:*.emerg                                                 :omusrmsg:*</span><br><span class="line">47:uucp,news.crit                                          /var/<span class="built_in">log</span>/spooler</span><br><span class="line">49:local7.*                                                /var/<span class="built_in">log</span>/boot.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种实现：直接匹配行首非 # 开头的</span></span><br><span class="line"><span class="comment"># 因为使用了中括号表示需要有一个字符存在，所以空行的不会被匹配</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^[^#]&#x27;</span> /etc/rsyslog.conf </span><br><span class="line">9:<span class="variable">$ModLoad</span> imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span><br><span class="line">10:<span class="variable">$ModLoad</span> imjournal <span class="comment"># provides access to the systemd journal</span></span><br><span class="line">26:<span class="variable">$WorkDirectory</span> /var/lib/rsyslog</span><br><span class="line">29:<span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span><br><span class="line">36:<span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span><br><span class="line">40:<span class="variable">$OmitLocalLogging</span> on</span><br><span class="line">43:<span class="variable">$IMJournalStateFile</span> imjournal.state</span><br><span class="line">54:*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages</span><br><span class="line">57:authpriv.*                                              /var/<span class="built_in">log</span>/secure</span><br><span class="line">60:mail.*                                                  -/var/<span class="built_in">log</span>/maillog</span><br><span class="line">64:cron.*                                                  /var/<span class="built_in">log</span>/cron</span><br><span class="line">67:*.emerg                                                 :omusrmsg:*</span><br><span class="line">70:uucp,news.crit                                          /var/<span class="built_in">log</span>/spooler</span><br><span class="line">73:local7.*                                                /var/<span class="built_in">log</span>/boot.log</span><br></pre></td></tr></table></figure>

<p>这里要注意的是批注可以出现在任意处，所以匹配行首的是最安全的做法</p>
<h3 id="范例-4：任意一个字符-与重复字符"><a href="#范例-4：任意一个字符-与重复字符" class="headerlink" title="范例 4：任意一个字符 . 与重复字符 *"></a>范例 4：任意一个字符 <code>.</code> 与重复字符 <code>*</code></h3><p>在第十章 <strong>bash</strong> 中，通配符 <code>*</code>表示任意（0 或 多个）字符，但是正则表达式中并不是这样，他们含义如下：</p>
<ul>
<li><code>.</code>：一定有一个任意字符</li>
<li><code>*</code>：重复前一个字符，0 到任意次，为组合形态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出 g??d 的字符串，也就是 g 开头 d 结尾的 4 字符的字符串</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;g..d&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 oo、ooo、ooo 等数据，至少含有 2 个 o</span></span><br><span class="line"><span class="comment"># 注意，这里不能写 oo* 因为，*是作用于第二个 o 的，表示 0 到任意个</span></span><br><span class="line"><span class="comment"># 也就是说如果是 oo* 有可能匹配到一个 o </span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;ooo*&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 开头与结尾都是 g ，并且中间至少含有一个 o 的数据</span></span><br><span class="line"><span class="comment"># 也就是 gog、goog 之类的数据</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;goo*g&#x27;</span> regular_express.txt </span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 开头与结尾都是 g，中间有无字符均可</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;g*g&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">13:Oh!  My god!</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">17:I like dog.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line">20:go! go! Let<span class="string">&#x27;s go.</span></span><br><span class="line"><span class="string"># 使用 g*g 发现第一行的数据就不匹配，这个还是需要再终端看，因为可以开启高亮，方便查看哈</span></span><br><span class="line"><span class="string"># 原因是 * 作用于 g，g* 代表空字符或一个以上的 g，因此应该匹配 g、gg、ggg 等</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 正确的应该这样实现</span></span><br><span class="line"><span class="string">[mrcode@study tmp]$ grep -n &#x27;</span>g.*g<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span></span><br><span class="line"><span class="string">14:The gd software is a library for drafting programs.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br><span class="line"><span class="string">19:goooooogle yes!</span></span><br><span class="line"><span class="string">20:go! go! Let&#x27;</span>s go.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出包含任意数字的数据</span></span><br><span class="line"><span class="comment"># 同上，[0-9]* 只作用于一个中括号</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[0-9][0-9]*&#x27;</span> regular_express.txt </span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line"><span class="comment"># 直接使用 grep -n &#x27;[0-9]&#x27; regular_express.txt 也可以得到相同结果哈</span></span><br></pre></td></tr></table></figure>

<h3 id="范例-5：限定连续-正则字符范围"><a href="#范例-5：限定连续-正则字符范围" class="headerlink" title="范例 5：限定连续 正则字符范围 {}"></a>范例 5：限定连续 正则字符范围 <code>&#123;&#125;</code></h3><p>找出 <strong>2</strong> 个到 <strong>5</strong> 个 <strong>o</strong> 的连续字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 华括弧在 shell 中是特殊符号，需要转义</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;o\&#123;2\&#125;&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line"><span class="comment"># 上述结果是至少是 2 个 oo 的出来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单词开头结尾都是 g，中间 o，至少 2 个，最多 5 个</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;go\&#123;2,5\&#125;g&#x27;</span> regular_express.txt </span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 承上，只是中间的 o 至少 2 个</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;go\&#123;2,\&#125;g&#x27;</span> regular_express.txt </span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure>

<h2 id="基础正则表示法字符汇总"><a href="#基础正则表示法字符汇总" class="headerlink" title="基础正则表示法字符汇总"></a>基础正则表示法字符汇总</h2><ul>
<li><p><code>^word</code>：搜索的关键词 <strong>word</strong> 在行首</p>
<p>范例：搜索行首为 <strong>#</strong> 的，并列出行号 <code>grep -n &#39;^#&#39; file</code></p>
</li>
<li><p><code>word$</code>：搜索的关键词 <strong>word</strong> 在行尾</p>
<p>范例：搜索以 ！结尾的，<code>grep -n &#39;!$&#39; file</code></p>
</li>
<li><p><code>.</code>：一定有一个任意字符</p>
<p>范例：搜索字符串可以是 <strong>eve</strong>、<strong>eae</strong>、<strong>eee</strong>、<strong>e e</strong>；<code>grep -n &#39;e.e&#39; file</code></p>
</li>
<li><p><code>\</code>：转义字符</p>
<p>范例：搜索含有单引号数据。<code>grep -n &#39;\’&#39; file</code></p>
</li>
<li><p><code>*</code>：重复另个到无穷多个前一个字符</p>
<p>范例：找出含有 <strong>es</strong>、<strong>ess</strong>、<strong>esss</strong> 等字符串；<code>grep -n &#39;es*&#39; file</code></p>
</li>
<li><p><code>[list]</code>：里面列出想要截取的字符合集</p>
<p>范例：找出含有 <strong>g1</strong> 或 <strong>gd</strong> 的数据；<code>grep -n &#39;g[1d]&#39; file</code></p>
</li>
<li><p><code>[n1-n2]</code>：字符合集范围</p>
<p>范例：找出含有任意大写字母的数据；<code>grep -n &#39;[A-Z]&#39; file</code></p>
</li>
<li><p><code>[^list]</code>：不要包含该集合中的字符或该范围的字符</p>
<p>范例：找出 <strong>ooa</strong>、<strong>oog</strong> 但是不包含 <strong>oot</strong> 的数据; <code>grep -n &#39;oo[^t]&#39;</code></p>
</li>
<li><p><code>\&#123;n,m\&#125;</code>：连续 <strong>n</strong> 到 <strong>m</strong> 个前一个字符</p>
</li>
<li><p><code>\&#123;n\&#125;</code>：连续 <strong>n</strong> 个前一个字符</p>
</li>
<li><p><code>\&#123;n,\&#125;</code>：至少 <strong>n</strong> 个以上的前一个字符；咋效果上感觉和 <code>\&#123;n\&#125;</code> 是一样的</p>
</li>
</ul>
<p>最后再强调，通配符和正则表达式不一样，比如在 <strong>ls</strong> 命令中找出以 <strong>a</strong> 开头的文件</p>
<ul>
<li>通配符：<code>ls -l a*</code></li>
<li>正则表达式：<code>ls | grep -n &#39;^a&#39;</code> 或则 <code>ls | grep -n &#39;^a.*&#39;</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例：以 ls -l 配合 grep 找出 /etc/ 下文件类型为链接文件属性的文件名</span></span><br><span class="line"><span class="comment"># 符号链接文件的特点是权限前面一位是 l，根据 ls 的输出，只要找到行首为 l 的即可</span></span><br><span class="line">[mrcode@study tmp]$ ls -l /etc | grep <span class="string">&#x27;^l&#x27;</span></span><br><span class="line">lrwxrwxrwx.  1 root root       56 Oct  4 18:22 favicon.png -&gt; /usr/share/icons/hicolor/16x16/apps/fedora-logo-icon.png</span><br><span class="line">lrwxrwxrwx.  1 root root       22 Oct  4 18:23 grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>

<h3 id="sed-工具"><a href="#sed-工具" class="headerlink" title="sed 工具"></a>sed 工具</h3><p>了解了一些正则基础使用后，可以来玩一玩 <strong>sed</strong> 和 <strong>awk</strong> ；作者就利用他们两个实现了一个小工具：<strong>logfile.sh</strong> 分析登录文件（第十八章会讲解）。里面绝大部分关键词的提取、统计等都是通过他们来完成的</p>
<p><strong>sed</strong>：本身是一个管线命令，可以分析 <strong>standard input</strong> 的数据，还可以将数据进行替换、新增、截取特定行等功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed [-nefr] [动作]</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><p><strong>n</strong>：使用安静（<strong>silent</strong>）模式</p>
<p>在一般 <strong>sed</strong> 的用法中，所有来自 <strong>STDIN</strong> 的数据一般都会列出到屏幕上，加上 <strong>-n</strong> 之后，只有经过 <strong>sed</strong> 特殊处理的那一行（或则动作）才会被打印出来</p>
</li>
<li><p><strong>e</strong>：直接在指令模式上进行 <strong>sed</strong> 的动作编辑</p>
</li>
<li><p><strong>f</strong>：直接将 <strong>sed</strong> 的动作写在一个文件内，<code>- f filename</code> 则可以执行 <strong>filename</strong> 内的 <strong>sed</strong> 动作</p>
</li>
<li><p><strong>r</strong>：<strong>sed</strong> 的动作支持是延伸类型正则表达式的语法（预设是基础正则表达式语法）</p>
</li>
<li><p><strong>i</strong>：直接修改读取的文件内容，而不是由屏幕输出</p>
</li>
</ul>
<p>动作说明：<code>[n1[,n2]]function</code></p>
<p><code>n1,n2</code>：不见得会存在，一般代表「选择进行动作的行数」，比如：如果我的动作是需要再 <strong>10</strong> 到 <strong>20</strong> 行之间进行的，则「10,20[动作行为]」</p>
<p><strong>function</strong> 有如下：</p>
<ul>
<li><strong>a</strong>：新增，<strong>a</strong> 后面可以接字符串，这些字符串会在新的一行出现（当前的下一行）</li>
<li><strong>c</strong>：替换，<strong>c</strong> 后面可以接字符串，这些字符串替换 <strong>n1,n2</strong> 之间的行</li>
<li><strong>d</strong>：删除，后面不接任何字符串</li>
<li><strong>i</strong>：插入，<strong>i</strong> 的后面可以接字符串，而这些字符串会在新的一行出现（当前的上一行）</li>
<li><strong>p</strong>：打印，将某个选择的数据打印。通常 <strong>p</strong> 会参与 <strong>sed -n</strong> 一起运作</li>
<li><strong>s</strong>：替换，可以直接进行替换工作。通常这个 <strong>s</strong> 的动作可以搭配正则表达式，例如：<code>1,20s/old/new/g</code></li>
</ul>
<h4 id="以行为单位的新增-删除功能"><a href="#以行为单位的新增-删除功能" class="headerlink" title="以行为单位的新增/删除功能"></a><strong>以行为单位的新增/删除功能</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：将 /etc/passwd 的内容列出并且打印行号，同时将第 2~5 行删除</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2,5d&#x27;</span>   	<span class="comment"># 注意写法和结果</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     6  sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line"><span class="comment"># 另外这里，应该带上 sed -e &#x27;2,5d&#x27; 才标准，不过不带也可以，但是需要使用单引号括起来</span></span><br><span class="line"><span class="comment"># 实测不用单引号也可以实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例2：只删除第二行</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2d&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例3：删除第三行到最后一行</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;3,$d&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     2  bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例4：在第二行后（也就是加载第三行）加上「drink tea？」字样</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2a drink tea?&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     2  bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea?</span><br><span class="line">     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例5：在第二行后面加入两行字</span></span><br><span class="line"><span class="comment"># 注意：不要一开始就写好所有的单引号，因为需要使用 \ + 回车触发换行</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2a drink tea \</span></span><br><span class="line"><span class="string">&gt; drink beer?&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     2  bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea </span><br><span class="line">drink beer?</span><br></pre></td></tr></table></figure>

<h4 id="以行为单位的取代显示功能"><a href="#以行为单位的取代显示功能" class="headerlink" title="以行为单位的取代显示功能"></a>以行为单位的取代显示功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：将第 2-5 行的内容替换为 no 2-5 nuber</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2,5c no 2-5 number&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">no 2-5 number</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例2：取出第 11-20 行</span></span><br><span class="line"><span class="comment"># 通过之前的知识来达成需要这样写</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | head -n 20 | tail -n 10</span><br><span class="line">    11  games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">    12  ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">    13  nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">    14  systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">    15  dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">    16  polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">    17  colord:x:998:997:User <span class="keyword">for</span> colord:/var/lib/colord:/sbin/nologin</span><br><span class="line">    18  libstoragemgmt:x:997:995:daemon account <span class="keyword">for</span> libstoragemgmt:/var/run/lsm:/sbin/nologin</span><br><span class="line">    19  rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin</span><br><span class="line">    20  saslauth:x:996:76:Saslauthd user:/run/saslauthd:/sbin/nologin</span><br><span class="line"><span class="comment"># 注意需要使用 -n 只输出 sed 处理过的数据</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed -n <span class="string">&#x27;11,20p&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="部分数据的搜索并替换功能"><a href="#部分数据的搜索并替换功能" class="headerlink" title="部分数据的搜索并替换功能"></a>部分数据的搜索并替换功能</h4><p>除了整行的处理模式外，还可以用行为单位进行部分数据的搜索并替换的功能，基本上 <strong>sed</strong> 的搜索与替换与 <strong>vi</strong> 类似</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/要被替换的字符串/新的字符串/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：先观察原始信息，利用 /sbin/ifconfig 查询 IP</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig </span><br><span class="line">enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line">        inet6 fe80::deb9:3a1b:fd0f:f6c2  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:a0:49:8f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 2436261  bytes 219827411 (209.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2011081  bytes 319310584 (304.5 MiB)</span><br><span class="line"><span class="comment"># 还未讲解到 IP,这里先关注第二行的 IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用关键词配合 grep 截取出关键的一行数据</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span></span><br><span class="line">        inet 192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 ip 前面的信息删除，也就是 inet </span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span> | sed <span class="string">&#x27;s/inet //g&#x27;</span></span><br><span class="line">        192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line"><span class="comment"># 需要使用通配符，不然会留下前面的空白符号：任意字符开头另个或多个</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span> | sed <span class="string">&#x27;s/^.*inet //g&#x27;</span></span><br><span class="line">192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再删除后续部分，只剩下 192.168.0.128</span></span><br><span class="line"><span class="comment"># 注意这里需要使用：空格任意个，来匹配前面多个空格</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span> | sed <span class="string">&#x27;s/^.*inet //g&#x27;</span> | sed <span class="string">&#x27;s/ *netmask.*$//g&#x27;</span></span><br><span class="line">192.168.0.128</span><br></pre></td></tr></table></figure>

<p>上面例子建议一步一步的来做，下面继续研究 <strong>sed</strong> 与正则表示法配合练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例2：只要 MAN 存在的那几行数据，但是含有 # 在内的批注和空白行不要</span></span><br><span class="line"><span class="comment"># 步骤1：先使用 grep 将关键词 MAN 所在行取出来</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/man_db.conf | grep <span class="string">&#x27;MAN&#x27;</span></span><br><span class="line"><span class="comment"># MANDATORY_MANPATH                     manpath_element</span></span><br><span class="line"><span class="comment"># MANPATH_MAP           path_element    manpath_element</span></span><br><span class="line"><span class="comment"># MANDB_MAP             global_manpath  [relative_catpath]</span></span><br><span class="line"><span class="comment"># every automatically generated MANPATH includes these fields</span></span><br><span class="line"><span class="comment">#MANDATORY_MANPATH                      /usr/src/pvm3/man</span></span><br><span class="line">MANDATORY_MANPATH                       /usr/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/share/man</span><br><span class="line">...省略...</span><br><span class="line"><span class="comment"># 步骤2：删除掉批注数据行</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/man_db.conf | grep <span class="string">&#x27;MAN&#x27;</span> | sed <span class="string">&#x27;s/^#.*$//g&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MANDATORY_MANPATH                       /usr/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/share/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/<span class="built_in">local</span>/share/man</span><br><span class="line"><span class="comment"># 步骤3：删除空白行</span></span><br><span class="line"><span class="comment"># 注意这里使用了动作里面的 d 命令，前面是正则匹配？</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/man_db.conf | grep <span class="string">&#x27;MAN&#x27;</span> | sed <span class="string">&#x27;s/^#.*$//g&#x27;</span> | sed <span class="string">&#x27;/^$/d&#x27;</span></span><br><span class="line">MANDATORY_MANPATH                       /usr/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/share/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/<span class="built_in">local</span>/share/man</span><br></pre></td></tr></table></figure>

<h4 id="直接修改文件内容（危险动作）"><a href="#直接修改文件内容（危险动作）" class="headerlink" title="直接修改文件内容（危险动作）"></a>直接修改文件内容（危险动作）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：利用 sed 将 /tmp/regular_express.txt 内每一行结尾若为 . 则换成 ！</span></span><br><span class="line"><span class="comment"># 下面还是使用了动作 s 替换，后面的是转义 . 和 !</span></span><br><span class="line"><span class="comment"># 这样可以直接修改文件内容</span></span><br><span class="line">[mrcode@study tmp]$ sed -i <span class="string">&#x27;s/\./\!/g&#x27;</span> regular_express.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例2：利用 sed 直接在 /tmp/regular_express.txt 最后一行加入 # This is a test</span></span><br><span class="line"><span class="comment"># $ 表示最后一行</span></span><br><span class="line">[mrcode@study tmp]$ sed -i <span class="string">&#x27;$a # This is a test &#x27;</span> regular_express.txt </span><br><span class="line"><span class="comment"># 想要删除最后一行就简单了</span></span><br><span class="line">[mrcode@study tmp]$ sed -i <span class="string">&#x27;$d&#x27;</span> regular_express.txt</span><br></pre></td></tr></table></figure>

<h2 id="延伸正则表示法"><a href="#延伸正则表示法" class="headerlink" title="延伸正则表示法"></a>延伸正则表示法</h2><p>一般来说，只要了解了基础正则表示法大概就已经相当足够了，所谓技多不压身；还可以了解使用范围更广的延伸正则表示法。举个例子：前面讲解到要去除空白行与行首为 <code>#</code> 的行，使用的是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&#x27;^$&#x27;</span> regular_express.txt | grep -v <span class="string">&#x27;^#&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要使用到管线命令来搜寻两次，使用延伸的正则表示法则如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -v <span class="string">&#x27;^$|^#&#x27;</span> regular_express.txt</span><br></pre></td></tr></table></figure>

<p>此外，<strong>grep</strong> 预设仅支持基础的正则表示法，可以使用 <code>-E</code> 参数开启，不过建议用别名 <strong>egrep</strong></p>
<p>下面是延伸正则表示法的符号（RE 字符）说明：</p>
<p><code>+</code>：重复「一个或一个以上」的前一个 RE 字符</p>
<p>范例：搜索 <code>(god)(good)(goood)...</code>等字符串。 可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;go+d&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs!</span><br><span class="line">9:Oh! The soup taste good!</span><br><span class="line">13:Oh!  My god!</span><br></pre></td></tr></table></figure>

<p><code>?</code>：「<strong>0</strong> 个或 <strong>1</strong> 个」的前一个 <strong>RE</strong> 字符</p>
<p>范例：搜索 <strong>gd</strong>、<strong>god</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;go?d&#x27;</span> regular_express.txt </span><br><span class="line">13:Oh!  My god!</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs!</span><br></pre></td></tr></table></figure>

<p><code>|</code>：用或（or）的方式找出数个字符串</p>
<p>范例：搜索 <strong>gd</strong> 或 <strong>good</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;gd|good&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs!</span><br><span class="line">9:Oh! The soup taste good!</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs!</span><br></pre></td></tr></table></figure>

<p><code>()</code>：找出「群组」字符串</p>
<p>范例：搜索 <strong>glad</strong> 或 <strong>good</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当然，这里使用上面完整的或来匹配两个固定单词也是可以的</span></span><br><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;g(la)|(oo)d&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs!</span><br><span class="line">2:apple is my favorite food!</span><br><span class="line">9:Oh! The soup taste good!</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>!</span><br></pre></td></tr></table></figure>

<p><code>()+</code>：多个重复群组的判别</p>
<p>范例：将「<strong>AxyzxyzxyzxyzC</strong>」用 <strong>echo</strong> 叫出，然后再使用如下的方法搜索</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ <span class="built_in">echo</span> <span class="string">&#x27;AxyzxyzxyzxyzC&#x27;</span> | egrep <span class="string">&#x27;A(xyz)&#x27;</span></span><br><span class="line">Axyz xyzxyzxyzC <span class="comment"># 在命令行中是有红色高亮的，这个只能高亮到 Axyz</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">echo</span> <span class="string">&#x27;AxyzxyzxyzxyzC&#x27;</span> | egrep <span class="string">&#x27;A(xyz)+&#x27;</span></span><br><span class="line">Axyzxyzxyzxyz C <span class="comment"># C 不会高亮</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">echo</span> <span class="string">&#x27;AxyzxyzxyzxyzC&#x27;</span> | egrep <span class="string">&#x27;A(xyz)+C&#x27;</span></span><br><span class="line">AxyzxyzxyzxyzC <span class="comment"># 完全匹配</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>TIP</strong></p>
<p>要特别注意：<code>grep -n &#39;[!&gt;]&#39; xx.txt</code> 的含义并不是除了 &gt; 字符之外的字符，因为 <code>!</code> 不是一个特殊符号</p>
<p>想要表示非，需要这样写 <code>grep -n &#39;[^a-z]&#39; xx.txt</code></p>
</blockquote>
<h2 id="文件的格式化与相关处理"><a href="#文件的格式化与相关处理" class="headerlink" title="文件的格式化与相关处理"></a>文件的格式化与相关处理</h2><p>不需要通过 <strong>vim</strong> 去编辑，而是通过数据流重导向配置 <strong>printf</strong> 功能以及 <strong>awk</strong> 指令，可以对文字信息进行排版显示</p>
<h3 id="格式化打印：printf"><a href="#格式化打印：printf" class="headerlink" title="格式化打印：printf"></a>格式化打印：printf</h3><p>比如将考试分数输出，姓名与科目及分数之间，稍微做个比较漂亮的版面，比如输出下面这样的表格</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name		Chinese		Enlish		Math		Average</span><br><span class="line">DmTsai		80				60				92			77.33</span><br><span class="line">VBird			75				55				80			70.00</span><br><span class="line">Ken				60				90				70			73.33</span><br></pre></td></tr></table></figure>

<p>上表数据主要分成 <strong>5</strong> 个字段，每个字段之间可以使用 <strong>tab</strong> 或空格进行分割。将上表存储到 <strong>printf.txt</strong> 文件中，后续会使用到这个文件进行练习。</p>
<p>由于每个字段的长度并不一样，所以要达到上表效果，就需要打印格式管理员 <strong>printf</strong> 来帮忙了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;打印格式&#x27;</span> 实际类容</span><br><span class="line">选项与参数：</span><br><span class="line"> 关于格式方面的几个特殊样式：</span><br><span class="line"> 		\a	警告剩余输出</span><br><span class="line"> 		\b	退格键（backspace）</span><br><span class="line"> 		\f	清楚屏幕（form feed）</span><br><span class="line"> 		\n 	输出新的一行</span><br><span class="line"> 		\r	Enter 按键，换行</span><br><span class="line"> 		\t	水平的 tab 按键</span><br><span class="line"> 		\v	垂直的 tab 按键</span><br><span class="line"> 		\xNN	NN 为两位数的数字，可以转换数字称为字符</span><br><span class="line"> 关于 C 程序语言内，常见的变量格式：</span><br><span class="line"> 		%ns		n 数字，s 表示 string，也就是多少个字符</span><br><span class="line"> 		%ni		n 数字，i 表示 <span class="built_in">integer</span>，多少整数数字</span><br><span class="line"> 		%N.nf 	n 与 N 都是数字，f 表示 floating（浮点），如果有小数，比如共 10 个位数，小数点 2 位数，则写成 %10.2f</span><br></pre></td></tr></table></figure>

<p>下面进行练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：将上面存储的 printf.txt 内容仅列出姓名与成绩，并且用 tab 分割</span></span><br><span class="line"><span class="comment"># 文件存储时，字段之间全部用 tab 隔开的，复制进去就变成下面展示这样了</span></span><br><span class="line"> [mrcode@study tmp]$ cat printf.txt </span><br><span class="line">Name            Chinese         Enlish          Math            Average</span><br><span class="line">DmTsai          80                              60                              92                      77.33</span><br><span class="line">VBird                   75                              55                              80                      70.00</span><br><span class="line">Ken                             60                              90                              70                      73.33</span><br><span class="line"><span class="comment"># 由于 printf 不是管线命令，需要通过 cat 先提取出来内容</span></span><br><span class="line"><span class="comment"># %s 表示不固定长度的字符串，后面跟了一个空格，并使用横向制表符 \t 来格式化</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">printf</span> <span class="string">&#x27;%s \t %s \t %s \t %s \t %s \t \n &#x27;</span> $(cat printf.txt)</span><br><span class="line">Name     Chinese         Enlish          Math    Average         </span><br><span class="line"> DmTsai          80      60      92      77.33   </span><br><span class="line"> VBird   75      55      80      70.00   </span><br><span class="line"> Ken     60      90      70      73.33 </span><br></pre></td></tr></table></figure>

<p>可以看到上述的效果虽然好多了，但是还是没有对齐。可能是由于 <strong>Chinese</strong> 比其他的长度要长，导致对不齐，那么下面来固定长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将上述第二行以后，分别以字符串、整数、小数点来显示</span></span><br><span class="line"><span class="comment"># grep -v Name 排除包含 Name 字符的行</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">printf</span> <span class="string">&#x27;%10s %5i %5i %5i %8.2f \n&#x27;</span> $(cat printf.txt | grep -v Name)</span><br><span class="line">    DmTsai    80    60    92    77.33 </span><br><span class="line">     VBird    75    55    80    70.00 </span><br><span class="line">       Ken    60    90    70    73.33 </span><br><span class="line"><span class="comment"># 由于这里是格式化数字，所以第一行无法使用这里的表达式，如果使用将得到数字 0 的展示</span></span><br><span class="line"><span class="comment"># 展示效果好了很多</span></span><br><span class="line"> %10s：这一个字段永远显示 10 个字符宽度，不足的用空格补位</span><br><span class="line"> %8.2f：表示 00000.00</span><br></pre></td></tr></table></figure>

<p><strong>printf</strong> 除了可以格式化处理之外，还可以根据 ASCII 的数字与图形对应来显示数据，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3： 列出 16 进制 45 代表的字符是什么</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">printf</span> <span class="string">&#x27;\x45\n&#x27;</span></span><br><span class="line">E</span><br><span class="line"><span class="comment"># 可以将数值转换为字符，如果你会写 script 的话</span></span><br><span class="line"><span class="comment"># 可以测试下，20~80 之间的数值表示的字符是什么</span></span><br></pre></td></tr></table></figure>

<p><strong>printf</strong> 使用相当广泛，包括后面提到的 <strong>awk</strong> 以及在 <strong>c</strong> 程序语言中使用的屏幕输出，都是利用 <strong>printf</strong>。</p>
<p><strong>printf</strong> 使用场景就是格式化输出，如果你要写自己的软件，把信息漂亮的输出到屏幕的话，可是很有用的</p>
<h3 id="awk：好用的数据处理工具"><a href="#awk：好用的数据处理工具" class="headerlink" title="awk：好用的数据处理工具"></a>awk：好用的数据处理工具</h3><ul>
<li><strong>sed</strong>：常常用于一整行的处理</li>
<li><strong>awk</strong>：倾向于将一行分成数个字段来处理</li>
</ul>
<p>因此，<strong>awk</strong> 适合处理小型的数据处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#x27;</span> filename</span><br><span class="line"></span><br><span class="line">awk 后可以跟文件，也可以接受前个指令的 standard output</span><br><span class="line">awk 主要处理每一行的字段内的数据，他默认的分隔符为「空格键」或「tab 键」</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例：使用 last 将登录者数据取出来</span></span><br><span class="line">[mrcode@study tmp]$ last -n 5		<span class="comment"># 取出前 5 行</span></span><br><span class="line">mrcode   pts/1        192.168.0.105    Wed Jan 15 22:20   still logged <span class="keyword">in</span>   </span><br><span class="line">mrcode   pts/0        192.168.0.105    Wed Jan 15 22:20   still logged <span class="keyword">in</span>   </span><br><span class="line">reboot   system boot  3.10.0-1062.el7. Wed Jan 15 22:19 - 23:05  (00:45)    </span><br><span class="line">mrcode   pts/1        192.168.0.105    Mon Jan 13 22:51 - 23:13  (00:22)    </span><br><span class="line">mrcode   pts/0        192.168.0.105    Mon Jan 13 22:51 - 23:13  (00:22) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要取出账户与登录 IP ，且账户与 IP 之间以 tab 隔开，可以这样写</span></span><br><span class="line">[mrcode@study tmp]$ last -n 5 | awk <span class="string">&#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">reboot  boot</span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">        </span><br><span class="line">wtmp    Fri</span><br><span class="line"><span class="comment"># 由于每一行数据都需要处理，所以不需要有条件类型</span></span><br><span class="line"><span class="comment"># 通过 print 功能将数据列出来</span></span><br><span class="line"><span class="comment"># 第 3 行数据被误判了，第二个字段中包含了空格</span></span><br><span class="line"><span class="comment"># 那么 $1 开始的变量表示哪一个字段，要注意的是：$0 表示整行数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于上面示例，<strong>awk</strong> 的处理流程是：</p>
<ol>
<li>读入第一行，并将第一行的内容填入 <code>$0、$1...</code> 变量中</li>
<li>依据 条件类型 的限制，判断是否需要进行后面的 动作</li>
<li>做完所有的动作与条件类型</li>
<li>若还有后续的「行」数据，则重复上面 <strong>1~3</strong> 步骤，直到所有数据都处理完为止</li>
</ol>
<p><strong>awk</strong> 是「以行为一次处理的单位」而「以字段为最小的处理单位」，那么 <strong>awk</strong> 中还提供了以下变量信息</p>
<table>
<thead>
<tr>
<th align="center">变量名称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NF</td>
<td align="center">每一行（<code>$0</code>）拥有的字段总数</td>
</tr>
<tr>
<td align="center">NR</td>
<td align="center">目前 awk 所处理的是「第几行」数据</td>
</tr>
<tr>
<td align="center">FS</td>
<td align="center">目前的分割字符，默认是空格</td>
</tr>
</tbody></table>
<p>继续上面 <strong>last -n 5</strong> 的例子来做说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要列出每一行的账户：就是 $1</span></span><br><span class="line"><span class="comment"># 列出目前处理的行数：NR 变量</span></span><br><span class="line"><span class="comment"># 该行有多少字段：NF 变量</span></span><br><span class="line"><span class="comment"># 注意：在 awk 的格式内使用 print 打印时，非变量部分需要用双引号引用起来，因为 awk 动作是以单引号的</span></span><br><span class="line">[mrcode@study ~]$ last -n 5 | awk <span class="string">&#x27;&#123;print $1 &quot;\t lines:&quot; NR &quot;\t columns:&quot; NF&#125;&#x27;</span></span><br><span class="line">mrcode   lines:1         columns:10</span><br><span class="line">mrcode   lines:2         columns:10</span><br><span class="line">reboot   lines:3         columns:11</span><br><span class="line">mrcode   lines:4         columns:10</span><br><span class="line">mrcode   lines:5         columns:10</span><br><span class="line">         lines:6         columns:0</span><br><span class="line">wtmp     lines:7         columns:7</span><br><span class="line"><span class="comment"># 注意 NF 等变量不需要有 $ 并且需要大写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="awk-的逻辑运算字符"><a href="#awk-的逻辑运算字符" class="headerlink" title="awk 的逻辑运算字符"></a>awk 的逻辑运算字符</h3><p>既然有「条件」，那么就有逻辑运算符号</p>
<table>
<thead>
<tr>
<th align="center">运算单元</th>
<th align="center">代表意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&gt;</code></td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">大于或等于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">小于或等于</td>
</tr>
<tr>
<td align="center"><code>==</code></td>
<td align="center"><strong>等于</strong></td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">不等于</td>
</tr>
</tbody></table>
<p>范例：在 <strong>/etc/passwd</strong> 中是以冒号「:」来分割字段的，第一个字段为账户，第三字段则是 <strong>UID</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查阅 第三栏小于 10 以下的数据，并且仅列出账户与第三栏</span></span><br><span class="line"><span class="comment"># FS 是字段分隔符</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/passwd | awk <span class="string">&#x27;&#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin     1</span><br><span class="line">daemon  2</span><br><span class="line">adm     3</span><br><span class="line">lp      4</span><br><span class="line">sync    5</span><br><span class="line">shutdown        6</span><br><span class="line">halt    7</span><br><span class="line">mail    8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行，没有生效是为啥呢？在 <strong>awk</strong> 中，在上述定义中，<strong>FS</strong> 仅能在第二行开始，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要使用关键字 BEGIN，对应的还有 END</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/passwd | awk <span class="string">&#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line">root    0</span><br><span class="line">bin     1</span><br><span class="line">daemon  2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <strong>awk</strong> 的计算功能，比如有如下的数据 <strong>pay.txt</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name		1st		2nd		3th</span><br><span class="line">Mrcode	2300	2400	2500</span><br><span class="line">DMTsai	2100	2000	2300</span><br><span class="line">Mrcode2	4300	4200	4100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每个人的总额，而且还要格式化输出</span></span><br><span class="line"> - 第一行是说明，不需要计算，所以需要使用条件 NR=1 时再处理</span><br><span class="line"> - 第二行才开始计算，NR &gt;=2 才处理</span><br><span class="line"></span><br><span class="line">[mrcode@study tmp]$ cat pay.txt | </span><br><span class="line">&gt; awk <span class="string">&#x27;NR==1 &#123;printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125;</span></span><br><span class="line"><span class="string">&gt; NR&gt;=2 &#123;total = $2 + $3 + $4 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line">      Name        1st        2nd        3th      Total</span><br><span class="line">    Mrcode       2300       2400       2500    7200.00</span><br><span class="line">    DMTsai       2100       2000       2300    6400.00</span><br><span class="line">   Mrcode2       4300       4200       4100   12600.00</span><br><span class="line"></span><br><span class="line">为了方便复制，这里粘贴上完整的一行命令：cat pay.txt |  awk <span class="string">&#x27;NR==1 &#123;printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125; NR&gt;=2 &#123;total = $2 + $3 + $4 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在来分解上面指令</span></span><br><span class="line"><span class="comment"># 1. 在 awk 中，非变量需要使用双引号引用起来</span></span><br><span class="line"><span class="comment"># 2. 使用 printf 时，需要加上 \n 才能换行</span></span><br><span class="line"><span class="comment"># 下面的含义是，当是第一行的时候，执行打印个格式化，前面是格式化表达式</span></span><br><span class="line"><span class="comment"># 后面用逗号分割，给出对应内容，这里给出了 1~4 个字段，并新增了一个 total 字段</span></span><br><span class="line">[mrcode@study tmp]$ cat pay.txt | awk <span class="string">&#x27;NR==1 &#123;printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;total&quot;&#125;&#x27;</span></span><br><span class="line">      Name        1st        2nd        3th      total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于计算的讲解</span></span><br><span class="line"><span class="comment"># 1. 在&#123;&#125; 动作中可以设置变量，进行运算；这里设置了一个 total 变量，并把 1~3 个字段相加</span></span><br><span class="line"><span class="comment"># 2. 由于这里有多个指令，所以需要使用冒号 「;」 进行分割</span></span><br><span class="line"><span class="comment"># 3. 使用 printf 常规打印，第 5 个字段引用了动作内设置的变量 total，记住 awk 中引用变量不需要使用 % 符号</span></span><br><span class="line">[mrcode@study tmp]$ cat pay.txt | awk <span class="string">&#x27;NR&gt;=2 &#123;total=$1+$2+$3 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line">    Mrcode       2300       2400       2500    4700.00</span><br><span class="line">    DMTsai       2100       2000       2300    4100.00</span><br><span class="line">   Mrcode2       4300       4200       4100    8500.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么上面两条是针对各自条件进行处理的，相当于 if 语句；多个条件动作之间使用空格分割；链接起来就完成了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用 <strong>awk</strong> 可以帮助我们处理很多日常工作了，在 <strong>awk</strong> 的输出格式中，常常会以 <strong>printf</strong> 来辅助。另外在 <strong>{}</strong> 动作内，也支持 <strong>if</strong>(条件) 语句。那么上面的指令可以使用 <strong>if</strong> 来做，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat pay.txt | awk <span class="string">&#x27;&#123;if(NR==1) printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125; NR&gt;=2 &#123;total = $2 + $3 + $4 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>笔者没有感觉这个 <strong>if</strong> 有多方便啊？</p>
<p>另外，<strong>awk</strong> 还可以进行循环计算，不过这个属于比较进阶的单独课程了</p>
<h2 id="文件比对工具"><a href="#文件比对工具" class="headerlink" title="文件比对工具"></a>文件比对工具</h2><p>通常会在同一个软件包的不同版本之间，比较配置文件与原始文件的差异的时候，就会用到文件对比。</p>
<p>很多时候所谓的对比，通常是用在 <strong>ASCII</strong> 纯文本的比对。常见的指令有 <strong>diff</strong>，还可以使用 <strong>cmp</strong> 来对比非纯文本。同时也可以使用 <strong>diff</strong> 建立分析文档，以处理补丁 <strong>patch</strong> 功能的文件</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p><strong>diff</strong> 用在比对两个文件之间的差异，以行为单位来比对的。一般是用在 <strong>ASCII</strong> 纯文本文件的比对上。</p>
<p>比如：将 <strong>/etc/passwd</strong> 删除第 4 行，第 6 行则替换为「<strong>no six line</strong>」，新文件放置到 <strong>/tmp/test</strong> 里，该如何做？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试目录</span></span><br><span class="line">[mrcode@study tmp]$ mkdir -p /tmp/testpw</span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">cd</span> /tmp/testpw/</span><br><span class="line">[mrcode@study testpw]$ cp /etc/passwd passwd.old </span><br><span class="line"><span class="comment"># sed -e 直接在命令行模式上修改；d 是删除，c是替换；前面 sed 中有讲到过的</span></span><br><span class="line"><span class="comment"># 这里把修改后的内容存到了 passwd.new 文件中</span></span><br><span class="line"><span class="comment"># sed 中有超过两个以上的动作时需要加 -e</span></span><br><span class="line">[mrcode@study testpw]$ cat /etc/passwd | sed -e <span class="string">&#x27;4d&#x27;</span> -e <span class="string">&#x27;6c no six line&#x27;</span> &gt; passwd.new</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diff [-bBi] from-file to-file</span><br><span class="line">选项与参数：</span><br><span class="line"></span><br><span class="line">from-file：文件名，原始对比文件</span><br><span class="line">to-file：文件名，目的比较文件</span><br><span class="line">注意：两个文件，都可以使用 - 表示，- 代表 standard input</span><br><span class="line"></span><br><span class="line">-b：忽略一行当中，仅有多个空白的差异；例如：“about me“ 与 “about         me” 视为相同</span><br><span class="line">-B：忽略空白行的差异</span><br><span class="line">-i：忽略大小写的不同</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：比对 passwd.old passwd.new 文件</span></span><br><span class="line">[mrcode@study testpw]$ diff passwd.old passwd.new </span><br><span class="line">4d3						<span class="comment"># 左边第 4 行被删除(d)掉了，基准是右边第 3 行</span></span><br><span class="line">&lt; adm:x:3:4:adm:/var/adm:/sbin/nologin				<span class="comment"># 列出了左边被删除的那一行内容</span></span><br><span class="line">6c5						<span class="comment"># 左边第 6 行，被替换（c）成右边文件的第 5 行</span></span><br><span class="line">&lt; sync:x:5:0:sync:/sbin:/bin/sync			<span class="comment"># 左边文件第 6 行内容</span></span><br><span class="line">---	</span><br><span class="line">&gt; no six line								<span class="comment"># 右边文件第 5 行内容</span></span><br><span class="line"><span class="comment"># 注意这里的，左边第 4 行被删除意思是：左边文件是完整的，右边是修改之后的，右边与左边对比，原来的第 4 行被删除了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果用 <strong>diff</strong> 去对比两个完全不相干的文件，是对比不出来什么的；另外 <strong>diff</strong> 还可以对比整个目录下的差异</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例：了解一下不同的开机执行等级（runlevel）内容有啥不同？假设你已经知道执行等级 0 与 5的启动脚本分别放置到 /etc/rc0.d 及 /etc/rc5.d 则可以对比下</span></span><br><span class="line">[mrcode@study testpw]$ diff /etc/rc0.d/ /etc/rc5.d/</span><br><span class="line">只在 /etc/rc0.d/ 存在：K90network</span><br><span class="line">只在 /etc/rc5.d/ 存在：S10network</span><br></pre></td></tr></table></figure>

<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p><strong>cmp</strong> 主要也是对比两个文件，主要利用字节单位去对比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp [-l] file1 file2</span><br><span class="line">-i：将所有的不同点的字节处都列出来。因为 cmp 预设仅会输出第一个发现的不同点</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：用 cmp 比较 passwd.old 与 passwd.new</span></span><br><span class="line">[mrcode@study testpw]$ cmp passwd.old passwd.new </span><br><span class="line">passwd.old passwd.new 不同：第 106 字节，第 4 行</span><br></pre></td></tr></table></figure>

<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p><strong>patch</strong> 与 <strong>diff</strong> 可配合使用，<strong>diff</strong> 比较出不同，而 <strong>patch</strong> 则可以将「旧文件升级为新的文件」。</p>
<ol>
<li>先比较新旧版本的差异</li>
<li>将差异制作成补丁文件</li>
<li>再由补丁文件更新旧文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：以 /tmp/testpw 内的 passwd.old 与 passwd.new 制作补丁文件</span></span><br><span class="line">[mrcode@study testpw]$ diff -Naur passwd.old passwd.new &gt; passwd.patch</span><br><span class="line">[mrcode@study testpw]$ cat passwd.patch </span><br><span class="line">--- passwd.old	2020-01-17 15:58:55.405462402 +0800			<span class="comment"># 新旧文件的信息</span></span><br><span class="line">+++ passwd.new	2020-01-17 16:01:03.115462402 +0800</span><br><span class="line">@@ -1,9 +1,8 @@		<span class="comment"># 新旧文件要修改数据的界定范围，旧文件在 1-0 行，新文件在 1-8 行</span></span><br><span class="line"> root:x:0:0:root:/root:/bin/bash</span><br><span class="line"> bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line"> daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">-adm:x:3:4:adm:/var/adm:/sbin/nologin			<span class="comment"># 左侧文件删除</span></span><br><span class="line"> lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">-sync:x:5:0:sync:/sbin:/bin/sync				<span class="comment"># 左侧文件删除</span></span><br><span class="line">+no six line									<span class="comment"># 右侧新加入</span></span><br><span class="line"> shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line"> halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line"> mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 这里怎么理解？ 可以理解为 old 文件是基准文件</span></span><br><span class="line"> <span class="comment"># 根据这里的基准文件，看到 - 就剪掉，看到 + 就增加；执行完成后，则会得到 new 这个文件；</span></span><br><span class="line"> <span class="comment"># 并且补丁中限制了行数。</span></span><br></pre></td></tr></table></figure>

<p>将 <strong>passwd.old</strong> 同步为 <strong>passwd.new</strong> 相同的内容，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于系统未预装 patch 软件，需要将之前的 iso 镜像文件挂载</span></span><br><span class="line"><span class="comment"># 在虚拟机上找到顺序为 0 的控制器位置，选择 iso 文件，设备就能被 linux 找到了</span></span><br><span class="line">[root@study ~]<span class="comment"># mount /dev/sr0 /mnt/</span></span><br><span class="line">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class="line">[root@study ~]<span class="comment"># rpm -ivh /mnt/Packages/patch-2.*</span></span><br><span class="line">警告：/mnt/Packages/patch-2.7.1-11.el7.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID f4a80eb5: NOKEY</span><br><span class="line">准备中...                          <span class="comment">################################# [100%]</span></span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:patch-2.7.1-11.el7               <span class="comment">################################# [100%]</span></span><br><span class="line">[root@study ~]<span class="comment"># umount /mnt/</span></span><br><span class="line">[root@study ~]<span class="comment"># exit</span></span><br><span class="line"><span class="comment"># 透过上述方式安装所需软件</span></span><br></pre></td></tr></table></figure>

<p>语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">patch -pN &lt; patch_file  <span class="comment"># 更新</span></span><br><span class="line">patch -R -pN &lt; patch_file  <span class="comment"># 还原</span></span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-p：后面可以接 取消几层目录 的意思</span><br><span class="line">-R：代表还原，将新的文件还原成原来的旧文件</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将刚刚制作出来的 patch file 用来更新旧版本数据</span></span><br><span class="line">[mrcode@study testpw]$ patch -p0 &lt; passwd.patch </span><br><span class="line">patching file passwd.old</span><br><span class="line">[mrcode@study testpw]$ ll passwd.*</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode 2266 1月  17 16:01 passwd.new</span><br><span class="line">-rw-r--r--. 1 mrcode mrcode 2266 1月  17 16:50 passwd.old	<span class="comment"># 文件大小和new文件一样了</span></span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode  480 1月  17 16:38 passwd.patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：恢复旧文件内容</span></span><br><span class="line">[mrcode@study testpw]$ patch -R -p0 &lt; passwd.patch </span><br><span class="line">patching file passwd.old</span><br><span class="line">[mrcode@study testpw]$ ll passwd.*</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode 2266 1月  17 16:01 passwd.new</span><br><span class="line">-rw-r--r--. 1 mrcode mrcode 2323 1月  17 16:52 passwd.old</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里为什么会使用 <code>-p0</code> ？因为两个文件在同一个目录下，因此不需要减去目录。如果是整体目录比对（<strong>diff</strong> 旧目录 新目录）时，就要依据建立 <strong>patch</strong> 文件所在目录来进行目录删减</p>
<p>更详细的 <strong>patch</strong> 用法在后续的第二十章「原始码编译」</p>
<h3 id="文件打印准备：pr"><a href="#文件打印准备：pr" class="headerlink" title="文件打印准备：pr"></a>文件打印准备：pr</h3><p>在图形界面中的文字处理软件，打印时可以选择每一页的标头和页码，在文字界面下，可以使用 <strong>pr</strong> 来实现，由于 <strong>pr</strong> 参数实在太多了，这里使用最简单的方式来处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印 /etc/man_db.conf</span></span><br><span class="line">[mrcode@study testpw]$ pr /etc/man_db.conf </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2018-10-31 04:26                /etc/man_db.conf                 第 1 页</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is used by the man-db package to configure the man and cat paths.</span></span><br><span class="line"><span class="comment"># It is also used to provide a manpath for those without one by examining</span></span><br><span class="line"><span class="comment"># their PATH environment variable. For details see the manpath(5) man page.</span></span><br></pre></td></tr></table></figure>

<p>最上面的一行就是 <strong>pr</strong> 处理之后的效果。依次是：文件时间、文件名、页码</p>
<h1 id="学习-Shell-Scripts"><a href="#学习-Shell-Scripts" class="headerlink" title="学习 Shell Scripts"></a>学习 Shell Scripts</h1><p>基本上 <strong>shell script</strong> 类似早期的批处理文件，将一些指令汇总起来一次执行，但是 <strong>shell script</strong> 拥有更强大的功能，可以进行类似程序的编写，并且不需要经过编译就可以执行。</p>
<p>我们可以通过 <strong>shell script</strong> 来简化我们日常的管理工作，而且整个 <strong>Linux</strong> 环境中，一些服务（<strong>services</strong>）的启动都是透过 <strong>shell script</strong> 的。</p>
<p>所以 <strong>shell scripts</strong> 是很重要的课程</p>
<h2 id="什么是-Shell-Scripts"><a href="#什么是-Shell-Scripts" class="headerlink" title="什么是 Shell Scripts"></a>什么是 Shell Scripts</h2><p>Shell Scripts ：程序化脚本；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- shell ：在前面第十章中讲过的 BASH，是一个文字接口让我们与系统沟通的一个工具接口。</span><br><span class="line">- script：脚本</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>那么就是针对 <strong>shell</strong> 写的脚本</p>
<p><strong>shell script</strong> 可以简单的看成是批处理文件，也可以称为一种程序语言，该语言是利用 <strong>shell</strong> 与相关工具指令，所以不需要编译即可执行，且有不错的 <strong>debug</strong> 工具，所以，它可以帮助系统管理员快速的管理好主机</p>
<h2 id="为什么要学习-shell-scripts"><a href="#为什么要学习-shell-scripts" class="headerlink" title="为什么要学习 shell scripts?"></a>为什么要学习 shell scripts?</h2><p>简单说：想要玩清楚 <strong>Linux</strong> 的来龙去脉，<strong>shell script</strong> 是必须的知识，因为：</p>
<ul>
<li><p>自动化管理的重要依据</p>
<p>管理一部主机每天要进行的任务就有：</p>
<ul>
<li>查询登录文件</li>
<li>追踪流量</li>
<li>监控用户使用主机状态</li>
<li>主机各项硬件设备状态</li>
<li>主机软件更新查询</li>
</ul>
<p>等等，这里白不包括有其他使用者突然的要求了。这些工作进行又可以分为：</p>
<ol>
<li>自行手动处理</li>
<li>写个简单的程序来帮你每日「自动处理分析」</li>
</ol>
</li>
<li><p>追踪与管理系统的重要工作</p>
<p> 在 <strong>CentOS 6.x</strong> 以前的版本中，系统的服务（<strong>services</strong>）启动的接口是在 <code>/etc/init.d</code> 目录下，所有文件都是 <strong>scripts</strong>；另外，包括开机（<strong>booting</strong>）过程也是利用 <strong>shell script</strong> 来帮忙搜索系统的相关设置数据，再代入各个服务的设置参数。</p>
<p> 比如：想要重新启动系统注册表，可以使用 <code>/etc/init.d/rsyslogd restart</code> <strong>rsyslogd</strong> 文件就是 <strong>script</strong> 了</p>
<p> 另外，比如 <strong>Mysql</strong> 数据库服务启动时，有可能就在 <strong>script</strong> 中主动以「空密码」尝试登陆 <strong>Mysql</strong>，为了安全性，那么你就可以修改这个 <strong>script</strong> 文件。</p>
<p> 虽然 <code>/etc/init.d/*</code> 这个脚本目前的启动方式（<strong>systemV</strong>）已经被新一代的 <strong>systemd</strong> 所代替了（从 CentOS 7 开始），但是很多的个别服务在管理他们的服务启动方面，还是使用 <strong>shell script</strong> 的机制</p>
</li>
<li><p>简单入侵检测功能</p>
<p>当系统有异常状态时，大多会讲这些记录在「系统注册表」中（系统记录器），那么就可以在固定的几分钟内主动的去分析注册表文件，若察觉有问题，就立刻通知管理员，或者是立刻加强防火墙的规则，如此一来，主机就能过达到自我保护的聪明学习功能了。</p>
<p>比如：可以通过 <strong>shell script</strong> 分析「当该封包尝试几次还是联机失败之后，就抵挡住该 <strong>IP</strong>」之类的动作</p>
</li>
<li><p>连续指令单一化</p>
<p>简单说，<strong>script</strong> 最简单的功能就是，将一批指令写入 <strong>script</strong> 中，达到执行一个文件就能下达一批指令的目的。</p>
<p>比如：防火墙连续规则（<strong>iptables</strong>）、开机加载程序的项目（<B>/etc/rc.d/rc.local</B>） 等等</p>
</li>
<li><p>简易的数据处理</p>
<p>前面几章讲解的如 <strong>awk</strong> 等指令就可以用来处理简单的数据。配合各种指令来达到处理数据的目的</p>
</li>
<li><p>跨平台支持与学习历程较短</p>
<p>几乎所有的 <strong>Unix Like</strong> 上都可以运行 <strong>shell script</strong>，连 <strong>MS Windows</strong> 系列也有相关的 <strong>script</strong> 仿真器可以用</p>
</li>
</ul>
<p>虽然 <strong>shell script</strong> 号称是程序，实际上，<strong>shell script</strong> 处理数据的速度上还是不够快，因为用的是外部的指令与 <strong>bash shell</strong> 的一些默认工具，所以常常去调用外部的函数库，因此指令周期上面比不上传统的程序语言</p>
<p>所以，<strong>shell script</strong> 用在系统管理上是很好的一项工具，但是用在处理大量数值运算上，就不行了，速度较慢，使用 <strong>CPU</strong> 资源较多，造成主机资源的分配不良。我们通常利用 <strong>shell script</strong> 来处理服务器的侦测就比较合适</p>
<h2 id="第一支-script-的编写与执行"><a href="#第一支-script-的编写与执行" class="headerlink" title="第一支 script 的编写与执行"></a>第一支 script 的编写与执行</h2><p><strong>shell script</strong> 是纯文本文件，可以在里面一次性执行多个指令，或者是利用一些运算与逻辑判断来帮助我们达成某些功能。所以需要具备 <strong>bash</strong> 指令下达相关知识（第四章中开始下达指令中讲过），除此之外，还有以下知识需要了解：</p>
<ol>
<li>指令的执行是从上而下、从左而右的分析与执行</li>
<li>指令的下达：指令、选项与参数间的多个空白都会被忽略掉</li>
<li>空白行也将被忽略，并且「<strong>tab</strong>」按键锁推开的空白行同样视为空格</li>
<li>如果读取到一个 <strong>enter</strong> 符号（<strong>CR</strong>），就尝试开始执行改行（或该串）命令</li>
<li>如果一行内容太多，则可以使用「<code>\[Enter]</code>」来延伸至下一行</li>
<li><code>#</code>可作为批注。任何加在 <code>#</code>后面的文字将被视为批注文字而被忽略</li>
</ol>
<p>假设现在存在一个 <strong>script</strong> 是 <code>/home/mrcode/shell.sh</code>，有如下的方式执行这个文件</p>
<ul>
<li>直接指令下达：<strong>shell.sh</strong> 文件必须有可读与执行权限（rx）<ul>
<li>绝对路径：使用 <code>/home/mrcode/shell.sh</code>执行</li>
<li>相对路径：假设工作目录在 <code>/home/mnrcode</code>，就使用 <code>./shell.sh</code>执行</li>
<li>变量「<strong>PATH</strong>」功能：将 <strong>shell.sh</strong> 放在 <strong>PATH</strong> 指定目录内，例如 ~<code>/bin/</code></li>
</ul>
</li>
<li>以 <strong>bash</strong> 程序来执行：<code>bash shell.sh</code> 或 <code>sh shell.sh</code> 执行</li>
</ul>
<p>至于那个相对路径 <code>./shell.sh</code> 为什么需要这样，是因为 <a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/04.html">路径与指令搜索顺序</a> 的关系；</p>
<p><code>sh shell.sh</code> 为啥可以执行？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">type</span> -a sh</span><br><span class="line">sh is /usr/bin/sh</span><br><span class="line">[mrcode@study ~]$ ll /usr/bin/sh</span><br><span class="line">lrwxrwxrwx. 1 root root 4 Jan 17 14:32 /usr/bin/sh -&gt; bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 <strong>sh</strong> 是 <strong>bash</strong> 的链接文件，同时还可以使用参数 <code>-n 和 -x</code> 来检查与追踪 <strong>shell.sh</strong> 的语法是否正确</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>先来一个 <strong>Hello World</strong> 脚本，再来逐步说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/mrcode</span><br><span class="line">[mrcode@study ~]$ mkdir bin; <span class="built_in">cd</span> bin</span><br><span class="line">[mrcode@study bin]$ vi hello.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows &quot;Hello World&quot; in your screen.</span></span><br><span class="line"><span class="comment"># HIstory:</span></span><br><span class="line"><span class="comment"># 2020/02/19    mrcode  first release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Hello World! \a \n&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>在本章中，请将所有编写的 <strong>script</strong> 放置到你家目录的 <code>~/bin</code> 目录内，未来比较好管理，针对如上脚本的写法，分段说明：</p>
<ol>
<li><p><code>#!/bin/bash</code>：宣告这个 <strong>script</strong> 使用的 <strong>shell</strong> 名称</p>
<p>因为我们使用的是 <strong>bash</strong>，所以必须以 <code>#!/bin/bash</code> 来声明该文件内的语法使用 <strong>bash</strong> 语法。</p>
<p>当这个程序被执行时，能够加载 <strong>bash</strong> 的相关环境配置文件（一般来说是 <strong>non-login shell</strong> 的 <code>~/.bashrc</code>），并且执行 <strong>bash</strong> 来使指令能够执行。很多情况下导致无法执行可能就是因为这一行的原因，系统无法判断该 <strong>sh</strong> 文件使用什么 <strong>shell</strong> 来执行</p>
</li>
<li><p>程序内容说明</p>
<p>整个文件中，除了第一行的 <code>#!</code> 是用来声明 <strong>shell</strong> 之外，其他的 <code>#</code>都是批注信息。一般来说，建议一定要养成说明该 <strong>script</strong> 的：</p>
<ol>
<li>内容与功能</li>
<li>版本信息</li>
<li>作者与联络方式</li>
<li>建档日期</li>
<li>历史记录</li>
</ol>
<p>等等，这将有助于未来程序的改写与 <strong>debug</strong></p>
</li>
<li><p>主要环境变量的声明</p>
<p>建议务必将一些重要的环境变量设置好，<strong>PATH</strong> 与 <strong>LANG</strong>（输出相关信息时） 是当中最重要的，如此一来就可以直接下达外部指令，而不用写绝对路径，比较方便</p>
</li>
<li><p>主要程序部分</p>
<p>在本例中，就是 <strong>echo</strong> 那一行</p>
</li>
<li><p>执行结果告知（定义回传值）</p>
<p><a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/05.html#%E6%8C%87%E4%BB%A4%E5%9B%9E%E4%BC%A0%E5%80%BC-%E4%B8%8E-%E5%92%8C">指令回传值</a> 中讲解到，可以使用 <code>$?</code> 来观察，那么可以利用 <strong>exit</strong> 这个指令来让程序中断，并且回传一个数值给系统。</p>
<p>本例中使用的是 <code>exit 0</code>，表示离开 <strong>script</strong> 并且回传一个 <strong>0</strong> 给系统，所以执行完这个 <strong>shell.sh</strong> 之后，下达 <code>echo $?</code> 则可以得到 <strong>0</strong> 的值。</p>
<p>利用这个 <strong>exit n</strong>（<strong>n</strong> 是数字）的功能，还可以自定义错误信息，让这支程序变得更加智能</p>
</li>
</ol>
<p>执行与观察结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察权限，目前没有 x 执行权限</span></span><br><span class="line">[mrcode@study bin]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode 239 Jan 19 11:25 hello.sh</span><br><span class="line"><span class="comment"># 尝试执行，报错无权限</span></span><br><span class="line">[mrcode@study bin]$ ./hello.sh</span><br><span class="line">-bash: ./hello.sh: Permission denied</span><br><span class="line"><span class="comment"># 添加执行权限</span></span><br><span class="line">[mrcode@study bin]$ chmod u+x hello.sh </span><br><span class="line">[mrcode@study bin]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rwxrw-r--. 1 mrcode mrcode 239 Jan 19 11:25 hello.sh</span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">[mrcode@study bin]$ ./hello.sh </span><br><span class="line">Hello World!  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看回传值</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="编写-shell-script-的良好习惯建立"><a href="#编写-shell-script-的良好习惯建立" class="headerlink" title="编写 shell script 的良好习惯建立"></a>编写 shell script 的良好习惯建立</h2><p>一个良好习惯的养成至关重要，往往最开始时最容易忽视这部分的，觉得程序只要写出来就可以了，但是随着时间的拉长，不断的维护和修改。后续维护就可能出现问题</p>
<p>比如：作者管理很多计算机，由于太懒，经常同一个程序在不同的主机上进行修改，最最后也不知道哪一个程序是最新的，其中做了什么修改，又为什么做那样的修改。</p>
<p>所以，在写程序时，需要仔细的将程序的设计过程记录下来，而且还会记录一些历史记录，这样会导致维护成本降低</p>
<p>另外，在一些环节设置上面，毕竟每个人的环境都不相同，为了取得较佳的执行环境，一般都会预先定义一些一定会被用到的环境变量，例如上面的 <strong>PATH</strong>。因此养成良好的 <strong>script</strong> 编写习惯，建议在每个 <strong>script</strong> 文件头记录如下信息：</p>
<ul>
<li>功能描述</li>
<li>版本信息</li>
<li>作者与联系方式</li>
<li>版权信息</li>
<li>历史记录（<strong>History</strong>）</li>
<li><strong>script</strong> 内较为特殊的指令，使用「绝对路径」方式来下达</li>
<li><strong>script</strong> 运作时需要的环境变量预先声明与设置</li>
</ul>
<p>除了这些信息之外，在关键和难理解的代码部分添加批注信息。另外推荐代码编排格式使用 「巢状方式」，使用 <strong>tab</strong> 来缩进。编写 <strong>script</strong> 的工具是 <strong>vim</strong> 而不是 <strong>vi</strong>，因为 <strong>vim</strong> 有额外的语法校验机制</p>
<h2 id="简单的-Shell-Script-练习"><a href="#简单的-Shell-Script-练习" class="headerlink" title="简单的 Shell Script 练习"></a>简单的 Shell Script 练习</h2><p>本章 范例中，实现的方式很多，建议先自行编写，再参考例子，才能加深概念</p>
<h3 id="简单范例"><a href="#简单范例" class="headerlink" title="简单范例"></a>简单范例</h3><p>本小节范例在很多脚本程序中都会用到，而且简单</p>
<h3 id="对谈式脚本：变量类容由用户决定"><a href="#对谈式脚本：变量类容由用户决定" class="headerlink" title="对谈式脚本：变量类容由用户决定"></a>对谈式脚本：变量类容由用户决定</h3><p>在很多场景中，需要用户输入一些内容，让程序可以顺利运行。比如，安装软件时，让用户选择安装目录；</p>
<p><a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.mdl#read">BASH 中的变量读取指令 read</a> ，那么以 <strong>read</strong> 指令的用途实现：</p>
<ol>
<li>用户输入 <strong>first name</strong></li>
<li>用户输入 <strong>last name</strong></li>
<li>最后在屏幕上显示：<strong>You full name is：xxx</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ vim read.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;first name: &#x27;</span> firstName</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;last name: &#x27;</span> lastName</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You full name: <span class="variable">$&#123;firstName&#125;</span><span class="variable">$&#123;lastName&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加执行权限</span></span><br><span class="line">[mrcode@study bin]$ chmod a+x read.sh</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">[mrcode@study bin]$ ./read.sh </span><br><span class="line">first name: zhu</span><br><span class="line">last name: mrcode</span><br><span class="line">You full name: zhumrcode</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是书上的程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim showname.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program：</span></span><br><span class="line"><span class="comment">#	用户输入姓名，程序显示出输入的姓名</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#	2020/01/19	mrcode	first release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input you first name: &quot;</span> firstname		<span class="comment"># 提示使用者输入</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input you last name: &quot;</span> lastname			<span class="comment"># 提示使用者输入</span></span><br><span class="line"><span class="comment"># -e 开启反斜杠转移的特殊字符显示，比如下面的 \n 换行显示</span></span><br><span class="line"><span class="built_in">echo</span> -e “\n Your full name is: <span class="variable">$&#123;firstname&#125;</span><span class="variable">$&#123;lastname&#125;</span>”	<span class="comment"># 结果由屏幕输出	</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">[mrcode@study bin]$ ./showname.sh </span><br><span class="line">Please input you first name: zhu</span><br><span class="line">Please input you last name: mrcode</span><br><span class="line"></span><br><span class="line"> Your full name is: zhumrcode</span><br></pre></td></tr></table></figure>

<p>笔者小结：可以看到上面这个脚本，增加了一个良好的习惯，就是脚本说明等信息</p>
<h3 id="随日期变化：利用-date-进行文件的建立"><a href="#随日期变化：利用-date-进行文件的建立" class="headerlink" title="随日期变化：利用 date 进行文件的建立"></a>随日期变化：利用 date 进行文件的建立</h3><p>考虑一个场景，每天备份 <strong>MySql</strong> 的数据文件，备份文件名以当天日期命名，如 <code>backup.2020-01-19.data</code>.</p>
<p>重点是 <code>2020-01-19</code> 是怎么来的？范例需求如下：</p>
<ol>
<li>用户输入一个文件名前缀</li>
<li>创建出以日期为名的三个空文件（通过 <strong>touch</strong> 指令），生成 前天、昨天、今天 日期，及格式为：<strong>filename_2020-01-19</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vim create_3_filename.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program: </span></span><br><span class="line"><span class="comment">#       用户输入文件名前缀，生成前天、昨天、今天的三个空文件</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#       2020/01/19      mrcode          first release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;将使用 ‘touch’ 命令创建 3 个文件&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入文件名：&quot;</span> fileuser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容错，使用变量功能判定与赋值默认值</span></span><br><span class="line">filename=<span class="variable">$&#123;fileuser:-&quot;filename&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># date 命令的使用</span></span><br><span class="line">date1=$(date --date=<span class="string">&#x27;2 days ago&#x27;</span> +%Y-%m-%d)		<span class="comment"># 两天前的日期，并格式化显示</span></span><br><span class="line">date2=$(date --date=<span class="string">&#x27;1 days ago&#x27;</span> +%Y-%m-%d)	</span><br><span class="line">date3=$(date +%Y-%m-%d)</span><br><span class="line"></span><br><span class="line">file1=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date1&#125;</span>&quot;</span></span><br><span class="line">file2=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date2&#125;</span>&quot;</span></span><br><span class="line">file3=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date3&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这里其实可以直接拼接文件名</span></span><br><span class="line">touch <span class="string">&quot;<span class="variable">$&#123;file1&#125;</span>&quot;</span></span><br><span class="line">touch <span class="string">&quot;<span class="variable">$&#123;file2&#125;</span>&quot;</span></span><br><span class="line">touch <span class="string">&quot;<span class="variable">$&#123;file3&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里使用了变量的赋值相关功能，详参考：<a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.html#%E5%8F%98%E9%87%8F%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%86%85%E5%AE%B9%E6%9B%BF%E6%8D%A2">变量功能</a></p>
<p>运行测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./create_3_filename.sh </span><br><span class="line">将使用 ‘touch’ 命令创建 3 个文件</span><br><span class="line">请输入文件名：mrcode</span><br><span class="line">[mrcode@study bin]$ ll</span><br><span class="line">总用量 16</span><br><span class="line">-rwxrwxr-x. 1 mrcode mrcode 677 1月  19 14:15 create_3_filename.sh</span><br><span class="line">-rwxrwxr-x. 1 mrcode mrcode 239 1月  19 11:25 hello.sh</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode   0 1月  19 14:15 mrcode_2020-01-17</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode   0 1月  19 14:15 mrcode_2020-01-18</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode   0 1月  19 14:15 mrcode_2020-01-19</span><br><span class="line"><span class="comment"># 一次正常输入文件名，一次直接按 enter 按键完成输入，查看是否达到默认赋值等功能</span></span><br></pre></td></tr></table></figure>

<h3 id="数值运算：简单的加减乘除"><a href="#数值运算：简单的加减乘除" class="headerlink" title="数值运算：简单的加减乘除"></a>数值运算：简单的加减乘除</h3><p>在变量功能课程中讲解到，需要使用 <a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.html#declare-%E3%80%81-typeset">declare</a> 来定义变量为正数才能进行计算，此外，也可以利用 <code>$((计算表达式))</code> 来进行数值运算，可惜的是，<strong>bashe shell</strong> 预设仅支持整数数据。</p>
<p>范例需求：</p>
<ol>
<li>要求用户输入两个变量</li>
<li>将两个变量相乘后输出到屏幕</li>
</ol>
<p>下面是笔者自己写的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       用户输入 2 个整数；输出相乘后的结果</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#       2020/01/19      mrcode          first release</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第一个整数：&#x27;</span> intUser1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第二个整数：&#x27;</span> intUser2</span><br><span class="line"><span class="built_in">declare</span> -i int1=<span class="variable">$&#123;intUser1&#125;</span></span><br><span class="line"><span class="built_in">declare</span> -i int2=<span class="variable">$&#123;intUser2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="string">&quot;\n <span class="variable">$&#123;int1&#125;</span> x <span class="variable">$&#123;int2&#125;</span> = <span class="subst">$((int1*int2)</span>)&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./multiplying.sh </span><br><span class="line">请输入第一个整数：2</span><br><span class="line">请输入第二个整数：3</span><br><span class="line"></span><br><span class="line"> 2 x 3 = 6</span><br></pre></td></tr></table></figure>

<p>其实用下面这样的方式来定义和输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第一个整数：&#x27;</span> intUser1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第二个整数：&#x27;</span> intUser2</span><br><span class="line">total=$((<span class="variable">$&#123;intUser1&#125;</span>*<span class="variable">$&#123;intUser2&#125;</span>))		<span class="comment"># 使用 $((运算内容)) 方式计算</span></span><br><span class="line"><span class="comment"># declare -i total=$&#123;intUser1&#125;*$&#123;intUser2&#125;		# 还可以使用此种方式</span></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="string">&quot;\n <span class="variable">$&#123;intUser1&#125;</span> x <span class="variable">$&#123;intUser2&#125;</span> = <span class="variable">$&#123;total&#125;</span>&quot;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>建议用 <code>var = $((计算内容))</code> 方式来计算，此种方式简单。比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取余数</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> $((<span class="number">3</span> % <span class="number">2</span>))</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于小数，可以使用 bc 指令来协助</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> $((<span class="number">3</span> / <span class="number">2</span>)); <span class="built_in">echo</span> <span class="string">&quot;3/2&quot;</span> | bc -l</span><br><span class="line">1</span><br><span class="line">1.50000000000000000000</span><br></pre></td></tr></table></figure>

<h3 id="数值运算：通过-bc-计算-pi"><a href="#数值运算：通过-bc-计算-pi" class="headerlink" title="数值运算：通过 bc 计算 pi"></a>数值运算：通过 bc 计算 pi</h3><p>bc 提供了一个计算 pi 的公式： <code>pi=$(echo &quot;scale=10; 4*a(1)&quot; | bc -l)</code>，此计算公式可以通过 <code>man bc | grep &#39;pi&#39;</code> 定位到相关文档。这里的 <strong>scale</strong> 是计算 <strong>pi</strong> 的精度，越高则利用到的 <strong>cpu</strong> 资源越多，计算时间越长。</p>
<p>好了，了解到怎么启用 <strong>pi</strong> 计算，这里要求用户输入 <strong>scale</strong> 进行计算 <strong>pi</strong> 值，并输出显示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim cal_pi.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program：</span></span><br><span class="line"><span class="comment">#	用户输入 scale 的值，程序计算出 scale 精度的 pi 值，并显示</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#	2020/01/19		mrcode		first release</span></span><br><span class="line"><span class="comment"># PATH 常规赋值</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入 scale 的值（10~10000）？&#x27;</span> checking</span><br><span class="line">num=<span class="variable">$&#123;checking:-&quot;10&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\n开始计算 pi 的值&#x27;</span></span><br><span class="line">time <span class="built_in">echo</span> <span class="string">&quot;scale=<span class="variable">$&#123;num&#125;</span>; 4*a(1)&quot;</span> | bc -l</span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./cal_pi.sh </span><br><span class="line">请输入 scale 的值（10~10000）？20</span><br><span class="line"></span><br><span class="line">开始计算 pi 的值</span><br><span class="line">3.14159265358979323844</span><br><span class="line"></span><br><span class="line">real	0m0.002s</span><br><span class="line">user	0m0.000s</span><br><span class="line">sys	0m0.001s</span><br></pre></td></tr></table></figure>

<h2 id="script-的执行方式差异（source、sh-script、-script）"><a href="#script-的执行方式差异（source、sh-script、-script）" class="headerlink" title="script 的执行方式差异（source、sh script、./script）"></a>script 的执行方式差异（source、sh script、./script）</h2><p>不同的方式执行执行会造成不一样的结果，尤其影响 <strong>bash</strong> 的环境很大。</p>
<h3 id="利用直接执行的方式来执行-script：在子程序中执行"><a href="#利用直接执行的方式来执行-script：在子程序中执行" class="headerlink" title="利用直接执行的方式来执行 script：在子程序中执行"></a>利用直接执行的方式来执行 script：在子程序中执行</h3><p><a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/12/01.html#%E7%AC%AC%E4%B8%80%E6%94%AF-script-%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C">直接指令下达</a> 或者是利用 <strong>bash</strong>（<strong>sh</strong>）来运行脚本时，都会使用一个新的 <strong>bash</strong> 环境来执行脚本的指令。也就是说这种方式执行是在子程序的 <strong>bash</strong> 内执行的。在第十章 <strong>BASH</strong> 内谈到 <a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.html"><code>export</code> 自定义变量转成环境变量</a> 的功能时，重点在于：当子程序完成后，子程序内的各项变量或动作将会结束儿不会传回到父程序中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行上面范例的姓名打印</span></span><br><span class="line">[mrcode@study bin]$ ./showname.sh </span><br><span class="line">Please input you first name: m</span><br><span class="line">Please input you last name: q</span><br><span class="line"></span><br><span class="line"> Your full name is: mq		<span class="comment">#  echo -e &quot;\n Your full name is: $&#123;firstname&#125;$&#123;lastname&#125;&quot; 打印出来了信息</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> <span class="variable">$&#123;fristname&#125;</span><span class="variable">$&#123;lastname&#125;</span>		<span class="comment"># 但是在父程序中却没有信息</span></span><br></pre></td></tr></table></figure>

<h3 id="利用-source-来执行脚本：在父程序中执行"><a href="#利用-source-来执行脚本：在父程序中执行" class="headerlink" title="利用 source 来执行脚本：在父程序中执行"></a>利用 source 来执行脚本：在父程序中执行</h3><p>同样的测试代码，使用 <strong>source</strong> 就不一样了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ <span class="built_in">source</span> showname.sh </span><br><span class="line">Please input you first name: m</span><br><span class="line">Please input you last name: q</span><br><span class="line"></span><br><span class="line"> Your full name is: mq</span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> <span class="variable">$&#123;firstname&#125;</span><span class="variable">$&#123;lastname&#125;</span></span><br><span class="line">mq			<span class="comment"># 在父程序中还能获取到</span></span><br></pre></td></tr></table></figure>

<h2 id="善用判断"><a href="#善用判断" class="headerlink" title="善用判断"></a>善用判断</h2><p>在 上一章中，提到过 <code>$?</code> 这个变量所代表的含义，以及通过 <code>&amp;&amp; 和 ||</code> 来判定前一个指令执行回传值对于后一个指令是否要进行的依据。</p>
<p>在上一章中，判定一个目录是否存在，使用了 <code>ll 目录 &amp;&amp; 执行指令</code> 的方式来判定 <strong>xx</strong> 目录是否存在，从而决定后续指令是否执行，但是有更简单的方式进行条件判断，就是通过 <strong>test</strong> 指令</p>
<h3 id="使用-test-指令的测试功能"><a href="#使用-test-指令的测试功能" class="headerlink" title="使用 test 指令的测试功能"></a>使用 test 指令的测试功能</h3><p><strong>test</strong> 指令主要用于检测文件或相关属性时的指令和比较值，比如检查 <strong>/mrcode</strong> 是否存在时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -e 是检测文件是否存在的选项</span></span><br><span class="line">[root@cloud-08 script]<span class="comment"># test -e /mrcode</span></span><br></pre></td></tr></table></figure>

<p>上面命令没有任何输出值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cloud-08 script]<span class="comment"># test -e /mrcode &amp;&amp; echo &quot;exist&quot; || &quot;not exist&quot;</span></span><br><span class="line">exist</span><br><span class="line"><span class="comment"># 通过与 &amp;&amp; 或 || 可以知道是存在还是不存在了</span></span><br></pre></td></tr></table></figure>

<p>要善用 man 查看该指令的信息，下面是整理翻译出来的其他选项</p>
<p>关于某个文件名的 <strong>文件类型</strong> 判断。如 <code>test -e filename</code> 标识是否存在</p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-e</strong></td>
<td align="left">文件是否存在；<strong>常用</strong></td>
</tr>
<tr>
<td align="center"><strong>-f</strong></td>
<td align="left">该文件是否存在且为文件（<strong>file</strong>）？<strong>常用</strong></td>
</tr>
<tr>
<td align="center"><strong>-d</strong></td>
<td align="left">该文件是否存在且为目录（<strong>directory</strong>）？<strong>常用</strong></td>
</tr>
<tr>
<td align="center"><strong>-b</strong></td>
<td align="left">该文件是否存在且为一个 <strong>block device</strong> 装置？</td>
</tr>
<tr>
<td align="center"><strong>-c</strong></td>
<td align="left">该文件是否存在且为一个 <strong>character device</strong> 装置？</td>
</tr>
<tr>
<td align="center"><strong>-S</strong></td>
<td align="left">该文件是否存在且为一个 <strong>Socket</strong> 文件？</td>
</tr>
<tr>
<td align="center"><strong>-p</strong></td>
<td align="left">该文件是否存在且为一个 <strong>FIFO</strong>（<strong>pipe</strong>）文件？</td>
</tr>
<tr>
<td align="center"><strong>-L</strong></td>
<td align="left">该文件是否存在且为一个连接文件？</td>
</tr>
</tbody></table>
<p>关于文件的 <strong>权限</strong> 判定。如 <code>test -r filename</code> 标识是否可读？（但 <strong>root</strong> 权限常有例外）</p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-r</strong></td>
<td align="left">该文件是否存在且具有可读权限？</td>
</tr>
<tr>
<td align="center"><strong>-w</strong></td>
<td align="left">该文件是否存在且具有可写权限？</td>
</tr>
<tr>
<td align="center"><strong>-x</strong></td>
<td align="left">该文件是否存在且具有可执行权限？</td>
</tr>
<tr>
<td align="center"><strong>-u</strong></td>
<td align="left">该文件是否存在且具有 <strong>SUID</strong> 属性？</td>
</tr>
<tr>
<td align="center"><strong>-g</strong></td>
<td align="left">该文件是否存在且具有 <strong>SGID</strong> 属性？</td>
</tr>
<tr>
<td align="center"><strong>-k</strong></td>
<td align="left">该文件是否存在且具有 <strong>Sticky bit</strong> 属性？</td>
</tr>
<tr>
<td align="center"><strong>-s</strong></td>
<td align="left">该文件是否存在且为「非空白文件」？</td>
</tr>
</tbody></table>
<p>两个文件之间的比较。如 <code>test file1 -nt file2</code></p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-nt</strong></td>
<td align="left">（<strong>newer than</strong>）判断 <strong>file1</strong> 是否比 <strong>file2</strong> 新</td>
</tr>
<tr>
<td align="center"><strong>-ot</strong></td>
<td align="left">（<strong>older than</strong>）判断 <strong>file1</strong> 是否比 <strong>file2</strong> 旧</td>
</tr>
<tr>
<td align="center"><strong>-ef</strong></td>
<td align="left">判断 <strong>file1</strong> 与 <strong>file2</strong> 是否是同一文件，可用在判断 <strong>hard link</strong> 的判定上。主要意义在判定两个文件是否均指向同一个 <strong>inode</strong></td>
</tr>
</tbody></table>
<p>两个整数之间的判定。<code>test nl -eq n2</code></p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-eq</strong></td>
<td align="left">两数值相等（<strong>equal</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-ne</strong></td>
<td align="left">不相等（<strong>not equal</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-gt</strong></td>
<td align="left">大于（<strong>greater than</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-lt</strong></td>
<td align="left">小于（<strong>less than</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-ge</strong></td>
<td align="left">大于等于（<strong>greater than or equal</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-le</strong></td>
<td align="left">小于等于（<strong>less than or equal</strong>）</td>
</tr>
</tbody></table>
<p>判定字符串的数据</p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>test -z string</strong></td>
<td align="left">判定字符串是否为 <strong>0</strong>？若为空串，则为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>test -n string</strong></td>
<td align="left">判定字符串是否不为 <strong>0</strong>？若为空串，则为 <strong>false</strong>；注意：<strong>-n</strong> 可省略</td>
</tr>
<tr>
<td align="center"><strong>test str1 == str2</strong></td>
<td align="left">是否相等，相等则为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>test str1 != str2</strong></td>
<td align="left">是否不相等，相等则为 <strong>false</strong></td>
</tr>
</tbody></table>
<p>多重条件判断。比如 <code>test -r filename -a -x filename</code></p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-a</strong></td>
<td align="left">（<strong>and</strong>）两状况同时成立；如：<code>test -r filename -a -x filename</code>，则 <strong>file</strong> 同时具有 <strong>r</strong> 与 <strong>x</strong> 权限时才为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>-o</strong></td>
<td align="left">（<strong>or</strong>）任意一个成立。如：<code>test -r filename -o -x filename</code>，则 <strong>file</strong> 具有 <strong>r</strong> 或 <strong>x</strong> 权限时就为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>!</strong></td>
<td align="left">反向状态。</td>
</tr>
</tbody></table>
<p>总结完这么多的判定，就可以来写几个简单的例子。让用户输入一个文件名，我们判断：</p>
<ol>
<li>该文件是否存在，若不存在则给予一个「<strong>Filename does not exist</strong>」 提示，并中断程序</li>
<li>若该文件存在，则判断是文件还是目录：文件输出「<strong>Filename is regular file</strong>」，目录输出 「<strong>Filename is directory</strong>」</li>
<li>判断执行者的身份对这个文件或目录所拥有的权限，并输出权限数据</li>
</ol>
<p>下面是笔者写的思路，代码组织方面有点糟糕。还有指令使用不太熟悉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># History</span></span><br><span class="line"><span class="comment">#       2020/01/19              mrcode          first relese</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个文件名：&quot;</span> filename</span><br><span class="line"><span class="comment"># 判断是否输入了字符串</span></span><br><span class="line"><span class="built_in">test</span> -z <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;请输入一个有效的文件名！&quot;</span> &amp;&amp; <span class="built_in">exit</span> -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断该文件是否存在: 不存在输出提示信息并退出</span></span><br><span class="line"><span class="comment"># 特别是这里的多条指令的执行，使用 || 会很难处理，只能转成 true</span></span><br><span class="line"><span class="built_in">test</span> ! -e <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> does not exist&quot;</span> &amp;&amp; <span class="built_in">exit</span> -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示是文件还是目录</span></span><br><span class="line"><span class="built_in">test</span> -f <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> is regular file&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> is directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断执行者的身份对这个文件拥有的权限，并输出</span></span><br><span class="line"><span class="built_in">test</span> -r <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> 可读&quot;</span></span><br><span class="line"><span class="built_in">test</span> -w <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> 可写&quot;</span></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> 可执行&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./file_perm.sh </span><br><span class="line">请输入一个文件名：ss</span><br><span class="line">ss does not exist</span><br><span class="line">[mrcode@study bin]$ ./file_perm.sh </span><br><span class="line">请输入一个文件名：/etc</span><br><span class="line">/etc is directory</span><br><span class="line">/etc 可读</span><br><span class="line">/etc 可执行</span><br></pre></td></tr></table></figure>

<p>书上代码如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim file_perm.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program</span></span><br><span class="line"><span class="comment">#   User input a filename,program will check the flowing:</span></span><br><span class="line"><span class="comment">#	1.) exist?</span></span><br><span class="line"><span class="comment">#	2.) file/directory?</span></span><br><span class="line"><span class="comment">#	3.) file permissions</span></span><br><span class="line"><span class="comment"># History</span></span><br><span class="line"><span class="comment">#       2020/01/19              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Please input a filename,I will check the filename&#x27;s type and permission. \n\n&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Input a filename ：&quot;</span> filename</span><br><span class="line"><span class="comment"># 判断是否输入了字符串</span></span><br><span class="line"><span class="built_in">test</span> -z <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;You MUST input a filename. &quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断该文件是否存在: 不存在输出提示信息并退出</span></span><br><span class="line"><span class="built_in">test</span> ! -e <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;The filename <span class="variable">$&#123;filename&#125;</span> does not exist&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始判断文件类型与属性</span></span><br><span class="line"><span class="built_in">test</span> -f <span class="variable">$&#123;filename&#125;</span> &amp;&amp; filetype=<span class="string">&quot;regulare file&quot;</span></span><br><span class="line"><span class="built_in">test</span> -d <span class="variable">$&#123;filename&#125;</span> &amp;&amp; filetype=<span class="string">&quot;directory&quot;</span></span><br><span class="line"><span class="built_in">test</span> -r <span class="variable">$&#123;filename&#125;</span> &amp;&amp; perm=<span class="string">&quot;readable&quot;</span></span><br><span class="line"><span class="built_in">test</span> -w <span class="variable">$&#123;filename&#125;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> writable&quot;</span></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$&#123;filename&#125;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> executable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信息输出</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The filename: <span class="variable">$&#123;filename&#125;</span> is a <span class="variable">$&#123;filetype&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;And the permissions for you are : <span class="variable">$&#123;perm&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./file_perm.sh </span><br><span class="line">Please input a filename,I will check the filename<span class="string">&#x27;s type and permission. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input a filename ：ss</span></span><br><span class="line"><span class="string">The filename ss does not exist</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./file_perm.sh </span></span><br><span class="line"><span class="string">Please input a filename,I will check the filename&#x27;</span>s <span class="built_in">type</span> and permission. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input a filename ：/etc</span><br><span class="line">The filename: /etc is a directory</span><br><span class="line">And the permissions <span class="keyword">for</span> you are : readable executable</span><br></pre></td></tr></table></figure>

<p>自己写的脚本组织来看，除了不熟悉指令用法之外，对于程序结构的抽象不够好，对比书上的，发觉这个代码组织的不错</p>
<p>另外，该脚本检查权限的指令是针对运行该脚本的用户所反馈的，所以当使用 <strong>root</strong> 的时候，常常会发现与 <strong>ls -l</strong> 观察到的结果并不相同</p>
<h3 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号 []"></a>利用判断符号 <code>[]</code></h3><p>除了 <strong>test</strong> 外，还可以使用中括号 <code>[]</code> 来判定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断 $&#123;HOME&#125; 这个变量是否为空</span></span><br><span class="line">[mrcode@study bin]$ [ -z <span class="string">&quot;<span class="variable">$&#123;HOME&#125;</span>&quot;</span> ]; <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>使用该种方式需要特别注意，因为中括号在很多地方都代表特殊符号，在 <strong>bash</strong> 的语法中作为 <strong>shell</strong> 判断时，必须要注意 <strong>中括号的两端需要有空格符来分隔</strong></p>
<ul>
<li>在中括号内的每个组件都需要有空格来分隔</li>
<li>在中括号内的变量，最好都以双引号括起来</li>
<li>在中括号内的常量，都好都以单或双引号括起来</li>
</ul>
<p>看一个例子，设置一个 <strong>name</strong> 变量，再用中括号方式判断</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ name=<span class="string">&quot;Mrcode Tset&quot;</span></span><br><span class="line">[mrcode@study bin]$ [ <span class="variable">$&#123;name&#125;</span> == <span class="string">&quot;Mrcode&quot;</span> ]</span><br><span class="line">-bash: [: 参数太多</span><br><span class="line"><span class="comment"># 是因为，如果 $&#123;name&#125; 没有使用双引号括起来就会变成  [ Mrcode Test  == &quot;Mrcode&quot; ]</span></span><br><span class="line"><span class="comment"># 中括号内的变量是以空格来分隔的，那么这里就出现了 Mrcode Test “Mrcode” 三个比较对象了</span></span><br><span class="line"><span class="comment"># 那么使用 [ “$&#123;name&#125;” == &quot;Mrcode&quot; ] 就变成了 [ “Mrcode Test”  == &quot;Mrcode&quot; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了以上注意之外，中括号使用方式与 <strong>test</strong> 几乎一模一样，只是中括号比较常用在 <strong>条件判断 if…then..fi</strong> 的情况中。</p>
<p>实践范例需求如下：</p>
<ol>
<li>当执行一个程序的时候，要求用户选择 <strong>Y</strong> 或 <strong>N</strong></li>
<li>如果用户输入 <strong>Y</strong> 或 <strong>y</strong> 时，就显示「<strong>Ok，continue</strong>」</li>
<li>如果用户输入 <strong>N</strong> 或 n 时，就显示「<strong>Oh，interrupt！</strong>」</li>
<li>如果不是以上规定字符，则显示「<strong>I don’t know what your choice is</strong>」</li>
</ol>
<p>利用中括号、<code>&amp;&amp;</code>、<code>||</code> 来达成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi ans_yn.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#	This program shows the user&#x27;s choice</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#	2020/01/20		mrcode		first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入 Y/N：&quot;</span> yn</span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> -o <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Ok，continue&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;N&quot;</span> -o <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;n&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Oh，interrupt！&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know what your choice is&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里报错时因为 [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; || &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]  中使用了 || 来达成条件判定</span></span><br><span class="line">[mrcode@study bin]$ ./ans_yn.sh </span><br><span class="line">请输入 Y/N：n</span><br><span class="line">./ans_yn.sh: 第 10 行:[: 缺少 `]<span class="string">&#x27;</span></span><br><span class="line"><span class="string">./ans_yn.sh:行10: n: 未找到命令</span></span><br><span class="line"><span class="string">./ans_yn.sh: 第 11 行:[: 缺少 `]&#x27;</span></span><br><span class="line">./ans_yn.sh:行11: n: 未找到命令</span><br><span class="line">I don<span class="string">&#x27;t know what your choice is</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] 使用了 test 中的参数， -o 只要任意一个成立都算 true</span></span><br><span class="line"><span class="string"># 程序正常</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ vim ans_yn.sh </span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./ans_yn.sh </span></span><br><span class="line"><span class="string">请输入 Y/N：n</span></span><br><span class="line"><span class="string">Oh，interrupt！</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./ans_yn.sh </span></span><br><span class="line"><span class="string">请输入 Y/N：y</span></span><br><span class="line"><span class="string">Ok，continue</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./ans_yn.sh </span></span><br><span class="line"><span class="string">请输入 Y/N：</span></span><br><span class="line"><span class="string">I don&#x27;</span>t know what your choice is</span><br></pre></td></tr></table></figure>

<h3 id="shell-script-的默认变量-0-1"><a href="#shell-script-的默认变量-0-1" class="headerlink" title="shell script 的默认变量 $0,$1..."></a>shell script 的默认变量 <code>$0,$1...</code></h3><p>指令可以带有选项与参数，如 <code>ls -la</code> 可以查看包含隐藏文件的所有属性。那么 <strong>script</strong> 也可以携带参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动系统的网络</span></span><br><span class="line">[mrcode@study bin]$ file /etc/init.d/network </span><br><span class="line">/etc/init.d/network: Bourne-Again shell script, ASCII text executable</span><br><span class="line"><span class="comment"># 利用 file 指令查询该文件，显示是个可执行的 shell script 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里携带 restart 参数，如果替换成 stop 参数就是关闭该服务了</span></span><br><span class="line">[mrcode@study bin]$ /etc/init.d/network restart </span><br></pre></td></tr></table></figure>

<p><strong>read</strong> 是使用过程中需要手动输入，而参数是可以跟随在执行命令后的，这样就比较方便</p>
<p><strong>script</strong> 针对参数已经设置好一些变量名称了，对应如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/path/to/scriptname		opt1	opt2	opt3	opt4</span><br><span class="line"> 		&amp;0				 &amp;1		 &amp;2		 &amp;3		 &amp;4</span><br></pre></td></tr></table></figure>

<p>除了这些数字的变量参数外，还有一些较为特殊的变量可以使用</p>
<ul>
<li><code>$#</code>：代表后接的参数「个数」，以上表为例这里显示「<strong>4</strong>」</li>
<li><code>$@</code>：代表 「<code>&quot;&amp;1&quot; &quot;&amp;2&quot; &quot;&amp;3&quot; &quot;&amp;4&quot;</code>」 的意思，每个变量是独立的（用双引号括起来）</li>
<li><code>$*</code>：代表「<code>&quot;&amp;1c&amp;2c&amp;3c&amp;4&quot;</code>」，其中 <strong>c</strong> 为分隔符，默认为空格，所以本例中代表「<code>&quot;&amp;1 &amp;2 &amp;3 &amp;4&quot;</code>」</li>
</ul>
<p><code>$@ 与 $*</code> 基本上还是有所不同，一般使用 <code>$@</code> 较多。</p>
<p>范例需求：输出如下数据</p>
<ul>
<li>程序的文件名</li>
<li>共有几个参数</li>
<li>若参数小于 <strong>2</strong> ，则告知使用者参数数量太少</li>
<li>全部的参数内容</li>
<li>第一个参数</li>
<li>第二个参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vi prit_info.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       输出脚本文件名，与相关参数信息</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"><span class="comment"># 这样写，语法是错误的，要记得这里是使用 test 里面的语法</span></span><br><span class="line"><span class="comment"># 并且，不能用 $&#123;变量&#125; 的方式来写</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;$#&#125;</span>&quot;</span> &lt; <span class="string">&quot;2&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;参数数量太少，比如大于等于 2 个&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./print_info.sh </span><br><span class="line">./print_info.sh</span><br><span class="line">0</span><br><span class="line">./print_info.sh:行11: 2: 没有那个文件或目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./print_info.sh a b</span><br><span class="line">./print_info.sh</span><br><span class="line">2</span><br><span class="line">./print_info.sh:行11: 2: 没有那个文件或目录</span><br><span class="line">a b</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>以下是书上的写法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vi how_paras.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       输出脚本文件名，与相关参数信息</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The script name is			==&gt; <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -lt 2 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;参数数量太少，比如大于等于 2 个&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The 1st parameter 			==&gt; <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The 2nd parameter 			==&gt; <span class="variable">$2</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./how_paras.sh </span><br><span class="line">The script name is			==&gt; ./how_paras.sh</span><br><span class="line">Total parameter number is		==&gt; 0</span><br><span class="line">参数数量太少，比如大于等于 2 个</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./how_paras.sh a b</span><br><span class="line">The script name is			==&gt; ./how_paras.sh</span><br><span class="line">Total parameter number is		==&gt; 2</span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b&#x27;</span></span><br><span class="line">The 1st parameter 			==&gt; a</span><br><span class="line">The 2nd parameter 			==&gt; b</span><br></pre></td></tr></table></figure>

<h3 id="shift：造成参数变量位置偏移"><a href="#shift：造成参数变量位置偏移" class="headerlink" title="shift：造成参数变量位置偏移"></a>shift：造成参数变量位置偏移</h3><p>先修改下上面的范例，<code>how_paras.sh</code> 先来看看效果什么是偏移</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vi how_paras.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Program shows the effect of shift function</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27; \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span>	<span class="comment"># 进行第一次 一个变量的 shift</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27; \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> 3	<span class="comment"># 进行第二次 三个变量的 shift</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./how_paras.sh a b c d e f</span><br><span class="line">Total parameter number is		==&gt; 6		<span class="comment"># 位偏移的参数数量，是 6 个</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b c d e f&#x27;</span></span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 5		<span class="comment"># 偏移一次后，只剩下 5 个，并且第一个参数 a 不见了</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c d e f&#x27;</span></span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 2		<span class="comment"># 第二次偏移掉 3 个后，b c d 不见了</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;e f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来看看如果参数不够偏移会出现什么情况</span></span><br><span class="line">[mrcode@study bin]$ ./how_paras.sh a b c	<span class="comment"># 给 3 个参数</span></span><br><span class="line">Total parameter number is		==&gt; 3</span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b c&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 2		<span class="comment"># 第一次偏移 1 个，只生效 2 个了</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 2		<span class="comment"># 第二次偏移 3 个，发现没有生效，不够偏移</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./how_paras.sh a b c d		<span class="comment"># 给 4 个参数</span></span><br><span class="line">Total parameter number is		==&gt; 4</span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b c d&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 3		<span class="comment"># 第一次偏移 1 个，还剩下 3 个</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c d&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 0		<span class="comment"># 第二次偏移 3 个，剩下 0 个</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>总结如下：</p>
<ul>
<li><strong>shift</strong> 可以忽略掉 <strong>n</strong> 个参数</li>
<li><strong>shif</strong> 中的 <strong>n</strong> 必须要有足够的参数才会生效，否则不会偏移</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>在程序中，没有条件判断 <code>if then</code> 方式的话，在执行多条指令的时候，就会很麻烦。</p>
<h3 id="利用-if-then"><a href="#利用-if-then" class="headerlink" title="利用 if...then"></a>利用 <code>if...then</code></h3><p><strong>单层、简单条件判断</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 表达式 ]; <span class="keyword">then</span></span><br><span class="line">	当条件成立时，可以进行的指令工作内容</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>至于表达式的编码，与上一章的 <strong>test</strong> 一致，但是有一个特别的是，可以使用 <code>&amp;&amp;</code> 与 <code>||</code> 来连接多个中括号，在这里他们的含义就是表示 并且 和 或者 的意思</p>
<p>所以在使用中括号的时候， <code>&amp;&amp;</code> 和 <code>||</code> 与指令状态下的含义不同。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> -o <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]</span><br><span class="line">可以替换为下面的方式</span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>这样就很方便维护了，一个中括号一个表达式。那么将这个 <strong>script</strong> 修改为 <code>if...then</code> 的形式如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ vi ans_yn.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows the user&#x27;s choice</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入 Y/N：&quot;</span> yn</span><br><span class="line"><span class="comment"># [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;Ok，continue&quot; &amp;&amp; exit 0</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Ok，continue&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh，interrupt！&quot; &amp;&amp; exit 0</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;N&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;n&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Oh，interrupt！&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know what your choice is&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>此方式只是在代码组织上更偏向于笔者所学的 JAVA 语言了，对于变量的判定还可以使用如下的多重判断来达到效果</p>
<p><strong>多重、复杂条件判断</strong></p>
<p>简单说，上述实例对于变量 <code>$&#123;yn&#125;</code> 使用了两次 <strong>if</strong>，那么可以使用如下方式简化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件表达式 ]; <span class="keyword">then</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>更复杂的情况，增加 <strong>elseif</strong> ，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件表达式 ]; <span class="keyword">then</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">elif</span> [ 条件表达式 ]; <span class="keyword">then</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>改写 <code>ans_yn.sh</code> 脚本如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows the user&#x27;s choice</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入 Y/N：&quot;</span> yn</span><br><span class="line"><span class="comment"># [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;Ok，continue&quot; &amp;&amp; exit 0</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Ok，continue&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Oh，interrupt！&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know what your choice is&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>另一个范例知识，上一节提到参数功能（**$1<strong>），让用户在下达指令的时候将参数带进去，让用户输入 **hello</strong> 关键词，利用参数的方法可以如下设计：</p>
<ol>
<li>判断 <code>$1</code> 是否为 <strong>hello</strong> ，如果是，则显示「**Hello, how ary you?**」</li>
<li>如果无参数，则提示使用者必须要使用的参数下达方法</li>
<li>如果参数不是 <strong>hello</strong>，则提示使用者仅能使用 <strong>hello</strong> 为参数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       直接携带参数提示</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;hello&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;请携带参数&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;只能携带参数 hello&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./hello-2.sh </span><br><span class="line">请携带参数</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hello</span><br><span class="line">Hello, how ary you?</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hellox</span><br><span class="line">只能携带参数 hello</span><br></pre></td></tr></table></figure>

<p>书上例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Chek $1 is equal to &quot;hello&quot;</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;hello&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;You MUST input parameters, ex&gt; &#123;<span class="variable">$&#123;0&#125;</span> someword&#125;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;The only parameter is &#x27;hello&#x27;, ex&gt; &#123;<span class="variable">$&#123;0&#125;</span> hello&#125;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>信息输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./hello-2.sh </span><br><span class="line">You MUST input parameters, ex&gt; &#123;./hello-2.sh someword&#125;</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hell</span><br><span class="line">The only parameter is <span class="string">&#x27;hello&#x27;</span>, ex&gt; &#123;./hello-2.sh hello&#125;</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hello</span><br><span class="line">Hello, how ary you?</span><br></pre></td></tr></table></figure>

<p>那么深入练习。</p>
<p>在第十章学习了 grep 指令，现在多了解一个 netstat 指令，可以查询到目前主机有开启的网络服务端口（service ports），相关功能会在 <strong>服务器架设篇</strong> 继续介绍；这里只需要知道 <code>netstat -tuln</code>可以取得目前主机有启动的服务，而且取得的信息类似下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ netstat -tuln</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line"><span class="comment"># 封包格式			 本地 IP:端口			  远程 IP:端口				是否监听</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:6011                :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN     </span><br><span class="line">udp        0      0 0.0.0.0:48829           0.0.0.0:*                          </span><br><span class="line">udp        0      0 192.168.122.1:53        0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:67              0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                          </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:672             0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                          </span><br><span class="line">udp6       0      0 :::111                  :::*                               </span><br><span class="line">udp6       0      0 ::1:323                 :::*                               </span><br><span class="line">udp6       0      0 :::672                  :::*  </span><br></pre></td></tr></table></figure>

<p>重点关注 <strong>Local Address</strong> 字段（本地主机 <strong>IP</strong> 与端口对应），代表本机所启动的网络服务，<strong>127.0.0.1</strong> 则是针对本机开放，若是 <strong>0.0.0.0 或 :::</strong> 则代表对整个 <strong>Internet</strong> 开放。每个端口 <strong>port</strong> 都有其特定的网络服务，几个常见的 <strong>port</strong> 与网络服务的关系是：</p>
<ul>
<li><strong>80</strong>：<strong>www</strong></li>
<li><strong>22</strong>：<strong>ssh</strong></li>
<li><strong>21</strong>：<strong>ftp</strong></li>
<li><strong>25</strong>：<strong>mail</strong></li>
<li><strong>111</strong>：<strong>RPC</strong></li>
<li><strong>631</strong>：<strong>CUPS</strong>（打印服务功能）</li>
</ul>
<p>假设我要检测常见端口 <strong>port 21、22、25、80</strong> 时，可以通过 <strong>netstat</strong> 检测主机是否有开启这四个主要的网络服务端口，由于每个服务的关键词都是接在冒号「**:<strong>」后面，所以可以截取类似「</strong>:80**」来检测。那么程序如下</p>
<p>下面是笔者写的脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim netstat.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;现在开始检测当前主机上的服务&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;www、ftp、mail、www 服务将被检测 \n&quot;</span></span><br><span class="line"><span class="comment"># 将 local Address 字段截取出来</span></span><br><span class="line">datas=$(netstat -tuln | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line">testing=$(grep <span class="string">&quot;:80&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;www&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:22&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;ssh&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:21&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;ftp&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:25&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;mail&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>不过很遗憾，<strong>grep</strong> 后只能跟一个文件路径。那么正确的做法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Using netstat and grep to detect www⽀~Assh⽀~Aftp and mail services</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 佅~H佑~J潟¥彎¥䷾K彝¥襾A佁~Z亾@举H</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;潎°作¨廾@妾K梾@派K弾S佉~M主彜º䷾J潚~D彜~M佊¡&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;www⽀~Aftp⽀~Amail⽀~Awww 彜~M佊¡対F被梾@派K \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 达[蠾L佈¤孾Z佒~L信彁¯轾S佇º </span></span><br><span class="line"><span class="comment"># 対F local Address 嬾W段彈ª住~V佇º彝¥﻾L并潔~_彈~P彖~G件</span></span><br><span class="line">testfile=/dev/shm/netstat_checking.txt</span><br><span class="line">netstat -tuln | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> &gt; <span class="variable">$&#123;testfile&#125;</span></span><br><span class="line"></span><br><span class="line">testing=$(grep <span class="string">&quot;:80&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;www is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">testing=$(grep <span class="string">&quot;:22&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ssh  is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">testing=$(grep <span class="string">&quot;:21&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ftp  is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:25&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;mail  is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>输出信息如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./netstat.sh </span><br><span class="line">现在开始检测当前主机上的服务</span><br><span class="line">www、ftp、mail、www 服务将被检测 </span><br><span class="line"></span><br><span class="line">ssh  is running <span class="keyword">in</span> you system. </span><br><span class="line">mail  is running <span class="keyword">in</span> you system.</span><br></pre></td></tr></table></figure>

<p>条件判断还可以更复杂，比如：在台湾当兵是国民应尽的义务，不过，在当兵的时候总是很想退伍，那么写个脚本程序来实现：让用户输入他的退伍日期，计算出还有多少天才退伍？的功能</p>
<p>那么思路如下：</p>
<ol>
<li>用户输入自己的退伍日期</li>
<li>由现在的日期对比退伍日期</li>
<li>由两个日期的比较来显示「还需要几天」才能够退伍的字样</li>
</ol>
<p>温馨提示：日期可以使用 <code>date --date=&quot;YYYYMMDD&quot; +%s</code> 来取得指定日期的秒数，再利用秒数相减，再计算到天</p>
<p>笔者从现在开始，就不再贴出自己写的代码了，先自己写，然后对照书上的，最后部分修改成书上的展示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vim cal_retired.sh</span><br><span class="line">  </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       You input you demobilization date,I calculate how many days before you demobilize.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 告知用户程序的用途，并且告知应该如何输入日期格式</span></span><br><span class="line"><span class="comment"># 这个程序将尝试计算出，您的退伍日期还有多少天</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This program will try to calculate :&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;How many days before your demobilization date...&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input your demobilization date (YYYYMMDD ex&gt;20200112)：&quot;</span> date2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 测试判定，输入内容是否正确，使用正则表达式</span></span><br><span class="line">date_d=$(<span class="built_in">echo</span> <span class="variable">$&#123;date2&#125;</span> | grep <span class="string">&#x27;[0-9]\&#123;8\&#125;&#x27;</span>)             <span class="comment"># 匹配 8 位数的字符串</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;date_d&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 您输入了错误的日期格式</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;You input the wrong date format...&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 开始计算日期</span></span><br><span class="line"><span class="built_in">declare</span> -i date_dem=$(date --date=<span class="string">&quot;<span class="variable">$&#123;date_d&#125;</span>&quot;</span> +%s)              <span class="comment"># 退伍日期秒数</span></span><br><span class="line"><span class="built_in">declare</span> -i date_now=$(date +%s)                                 <span class="comment"># 当前日期秒数</span></span><br><span class="line"><span class="built_in">declare</span> -i date_total_s=$((<span class="variable">$&#123;date_dem&#125;</span>-<span class="variable">$&#123;date_now&#125;</span>))    		<span class="comment"># 剩余秒数</span></span><br><span class="line"><span class="comment"># 需要注意的是：这种嵌套执行的时候，括号一定要嵌套对位置</span></span><br><span class="line"><span class="built_in">declare</span> -i date_d=$((<span class="variable">$&#123;date_total_s&#125;</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>))                 <span class="comment"># 转换为日</span></span><br><span class="line"><span class="comment"># 中括号里面不能直接使用 &lt; 这种符号</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;date_total_s&#125;</span>&quot;</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="comment"># 这里是用 -1 乘，得到是正数，标识已经退伍多少天了</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;You had been demobilization before:  <span class="subst">$((-1*$&#123;date_d&#125;)</span>)  ago&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 这里使用 总秒数 - 转换为日的变量（这里只是转换为了天），剩余数据转成小时</span></span><br><span class="line">        <span class="comment"># 则计算到 n 天 n 小时</span></span><br><span class="line">        <span class="built_in">declare</span> -i date_h=$(($((<span class="variable">$&#123;date_total_s&#125;</span>-<span class="variable">$&#123;date_d&#125;</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>))/60/60))</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;You will demobilize after <span class="variable">$&#123;date_d&#125;</span> days and <span class="variable">$&#123;date_h&#125;</span> hours.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20200120	<span class="comment"># 输入当天</span></span><br><span class="line">You had been demobilization before:  0  ago</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20200119	<span class="comment"># 输入前一天</span></span><br><span class="line">You had been demobilization before:  1  ago</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20200121	<span class="comment"># 输入明天</span></span><br><span class="line">You will demobilize after 0 days and 8 hours.</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：2020^H^H3	<span class="comment"># 输入错误的格式</span></span><br><span class="line">You input the wrong date format...</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20300120	<span class="comment"># 输入10 年后</span></span><br><span class="line">You will demobilize after 3652 days and 8 hours.</span><br></pre></td></tr></table></figure>

<p>笔者总结：</p>
<ul>
<li>本例结合了 <strong>grep</strong> 查找符合条件的参数，如果完全不符合，则为空白返回了</li>
<li>结合了 <strong>declare -i</strong> 定义整数变量</li>
<li>使用了 <code>$(($(())))</code> 嵌套指令执行语法</li>
<li>该范例还是有难度的，难点在于 用正则检查输入参数 和 计算 天 并计算小时</li>
</ul>
<h3 id="利用-case-esac-判断"><a href="#利用-case-esac-判断" class="headerlink" title="利用 case...esac 判断"></a>利用 <code>case...esac</code> 判断</h3><p>作为 <strong>JAVA</strong> 程序员，这个不用多解释，直接看语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名称 <span class="keyword">in</span>		<span class="comment"># 关键词为 case 还有 变量前的 $ 符号</span></span><br><span class="line">	“变量内容 1”)		<span class="comment"># 每个变量内容建议用双引号括起来，关键词则为小括号</span></span><br><span class="line">	 	程序段</span><br><span class="line">	 ;;				  <span class="comment"># 使用两个连续的分号来结尾</span></span><br><span class="line">	“变量内容 2”)</span><br><span class="line">	 	程序段</span><br><span class="line">	 ;;</span><br><span class="line">	*)			 	  <span class="comment"># 最后一个变量内容需要用 * 来代表所有其他值</span></span><br><span class="line">		程序段</span><br><span class="line">	 ;;</span><br><span class="line"><span class="keyword">esac</span>				  <span class="comment"># 最终的 case 结尾，就是反过来拼写的字符 esac</span></span><br></pre></td></tr></table></figure>

<p>将上面 <code>./hello-2.sh</code> 的例子使用该语法修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">./hello-3.sh </span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       直接携带参数提示</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">	<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line">	;;</span><br><span class="line">	<span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;请携带参数&quot;</span></span><br><span class="line">	;;</span><br><span class="line">	*)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;只能携带参数 hello&quot;</span></span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>此种判定方式，针对于判定字符串时会更加的方便，<strong>CentOS6.x</strong> 以前系统很多服务的启动都是使用使用这种写法写的。虽然 <strong>CentOS7</strong> 已经使用 <strong>systemd</strong> ，不过任然有数个服务时放在 <code>/etc/init.d</code> 目录下的、比如有个名为 <code>netconsole</code> 的服务在该目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动该服务</span></span><br><span class="line"><span class="comment"># 注意该服务需要使用 root 身份才行，一般账户可以执行，但是不会成功</span></span><br><span class="line">/etc/init.d/netconsole restart</span><br></pre></td></tr></table></figure>

<p>查阅该文件，找到文件末尾为发现以下的内容，这里就判定了输入的参数，使用的就是 case 语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    stop) stop ;;</span><br><span class="line">    status) status ;;</span><br><span class="line">    start|restart|reload|force-reload) restart ;;</span><br><span class="line">    condrestart) condrestart ;;</span><br><span class="line">    *) usage ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>所以对于脚本的编写，可以参考这些已经有的，看看人家是怎么写的</p>
<p>一般来说，使用「<code>case $变量 in</code>」语法，那个变量大致有两种取得方式：</p>
<ul>
<li>直接下达：利用 <code>script.sh variable</code> 方式直接给 <strong>$1</strong> 变量，这也是在 <code>/etc/init.d</code> 目录下大多数程序的设计方式</li>
<li>交互式：通过 <strong>read</strong> 指令让用户输入变量内容</li>
</ul>
<p>下面来演示下：</p>
<ul>
<li>用户输入 <code>one、two、three</code> 并显示在屏幕上</li>
<li>如果不是以上变量，那么提示用户只有这三种选择</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim show123.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如需要让用户交互性输入，那么可以用这两行代替：case &quot;$1&quot; in</span></span><br><span class="line"><span class="comment"># read -p &quot;请输入您的选择：&quot; choice</span></span><br><span class="line"><span class="comment"># case &quot;$&#123;choice&#125;&quot; in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">	<span class="string">&quot;one&quot;</span>) <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	<span class="string">&quot;two&quot;</span>) <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	<span class="string">&quot;three&quot;</span>) <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">&quot;只能输入 one、two、three&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./show123.sh </span><br><span class="line">只能输入 one、two、three</span><br><span class="line">[mrcode@study bin]$ ./show123.sh one</span><br><span class="line">one</span><br><span class="line">[mrcode@study bin]$ ./show123.sh two</span><br><span class="line">two</span><br><span class="line">[mrcode@study bin]$ ./show123.sh three</span><br><span class="line">three</span><br><span class="line">[mrcode@study bin]$ ./show123.sh three111</span><br><span class="line">只能输入 one、two、three</span><br></pre></td></tr></table></figure>

<h3 id="利用-function-功能"><a href="#利用-function-功能" class="headerlink" title="利用 function 功能"></a>利用 function 功能</h3><p>函数功能，不用多说，可以被复用，优化程序结构，语法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fname</span></span>()&#123;</span><br><span class="line">	程序段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><p><strong>TIP</strong></p>
<p>由于 <strong>shell script</strong> 执行方式是由上而下，由左而右，因此 <strong>function</strong> 的代码一定要在程序的最前面</p>
</div>

<p>下面将 <strong>show123.sh</strong> 改写成使用 <strong>function</strong> 方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim show123-2.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如需要让用户交互性输入，那么可以用这两行代替：case &quot;$1&quot; in</span></span><br><span class="line"><span class="comment"># read -p &quot;请输入您的选择：&quot; choice</span></span><br><span class="line"><span class="comment"># case &quot;$&#123;choice&#125;&quot; in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printit</span></span>()&#123;</span><br><span class="line">	<span class="built_in">echo</span> -n <span class="string">&quot;Your choice is &quot;</span> <span class="comment"># -n 可以不断行连续在同一行显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">	<span class="string">&quot;one&quot;</span>) printit; <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	<span class="string">&quot;two&quot;</span>) printit; <span class="built_in">echo</span> <span class="variable">$1</span> | tr <span class="string">&#x27;a-z&#x27;</span> <span class="string">&#x27;A-z&#x27;</span> ;;  <span class="comment"># 转换为大写</span></span><br><span class="line">	<span class="string">&quot;three&quot;</span>) printit; <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">&quot;只能输入 one、two、three&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>输出信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./show123-2.sh one</span><br><span class="line">Your choice is one</span><br><span class="line">[mrcode@study bin]$ vim show123-2.sh</span><br><span class="line">[mrcode@study bin]$ ./show123-2.sh tow</span><br><span class="line">只能输入 one、two、three</span><br><span class="line">[mrcode@study bin]$ ./show123-2.sh two</span><br><span class="line">Your choice is TWO</span><br></pre></td></tr></table></figure>

<p>上述代码，做了一个打印部分重复信息的功能，这个例子比较简单，当在程序中有大量重复，和大量逻辑的时候，就会体现出来了</p>
<p>同样，<strong>function</strong> 也可以有参数变量，改写成有参数调用函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim show123-3.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printit</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Your choice is <span class="variable">$&#123;1&#125;</span>&quot;</span> <span class="comment"># 在函数域中，的参数变量，与外部的不一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;one&quot;</span>) printit 1 ;;</span><br><span class="line">        <span class="string">&quot;two&quot;</span>) printit 2 ;;</span><br><span class="line">        <span class="string">&quot;three&quot;</span>) printit <span class="variable">$1</span> ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;只能输入 one、two、three&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./show123-3.sh one</span><br><span class="line">Your choice is 1			</span><br><span class="line">[mrcode@study bin]$ ./show123-3.sh two</span><br><span class="line">Your choice is 2 	<span class="comment"># 可以看到，这里给定参数 1，那么在里面获取 $&#123;1&#125;，的时候就获取到了</span></span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./show123-3.sh three		</span><br><span class="line">Your choice is three	<span class="comment"># 在外部给定的是脚本中的变量 $1, 在内部也能获取到变量的具体内容</span></span><br><span class="line">[mrcode@study bin]$ ./show123-3.sh threex</span><br><span class="line">只能输入 one、two、three</span><br></pre></td></tr></table></figure>

<h2 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h2><p>循环可以不断执行某个程序段楼，直到用户设定的条件达成为止。</p>
<h3 id="while-do-done、until-do-done（不定循环）"><a href="#while-do-done、until-do-done（不定循环）" class="headerlink" title="while do done、until do done（不定循环）"></a>while do done、until do done（不定循环）</h3><p>当条件成立时，执行循环体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]   <span class="comment"># 中括号中条件判断</span></span><br><span class="line"><span class="keyword">do</span>    <span class="comment"># 循环开始</span></span><br><span class="line">  程序段落</span><br><span class="line"><span class="keyword">done</span>  <span class="comment"># 循环结束</span></span><br></pre></td></tr></table></figure>

<p>还有一种不定循环的方式，当条件成立时退出循环体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>范例：让使用者输入 <strong>yes</strong> 或则是 <strong>YES</strong> 才结束程序的执行，否则就一直告知用户输入字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim yes_to_stop.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> != <span class="string">&#x27;yes&#x27;</span> -a <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> != <span class="string">&#x27;YES&#x27;</span> ]</span><br><span class="line"><span class="comment"># 使用 until 则是如下</span></span><br><span class="line"><span class="comment"># until [ &quot;$&#123;yn&#125;&quot; == &#x27;yes&#x27; -o &quot;$&#123;yn&#125;&quot; == &#x27;YES&#x27; ]</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">read</span> -p <span class="string">&#x27;请输入 yes 或 YES 退出程序&#x27;</span> yn</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你输入了正确答案&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./yes_to_stop.sh</span><br><span class="line">请输入 yes 或 YES 退出程序j</span><br><span class="line">请输入 yes 或 YES 退出程序jj</span><br><span class="line">请输入 yes 或 YES 退出程序yes</span><br><span class="line">你输入了正确答案</span><br></pre></td></tr></table></figure>

<p>如果想要计算 <code>1+2+3+..100</code>则如下写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim cal_1_100.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       计算 1+2+3+..100 的结果</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">total=0	<span class="comment"># 计算结果</span></span><br><span class="line">i=0			<span class="comment"># 当前数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;i&#125;</span>&quot;</span> != 100 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	i=$((<span class="variable">$i</span>+<span class="number">1</span>))		<span class="comment"># 每次增加 1</span></span><br><span class="line">	total=$((<span class="variable">$total</span>+<span class="variable">$i</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1+2+3+..100 = <span class="variable">$&#123;total&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="for-do-done-固定循环"><a href="#for-do-done-固定循环" class="headerlink" title="for...do...done 固定循环"></a><code>for...do...done</code> 固定循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	循环体</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>范例：假设有三种动物，分别是 <strong>dog</strong>、<strong>cat</strong>、<strong>elephant</strong> 三种，输出三行信息，如 <code>There are dogs...</code> 之类的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim show_animal.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;There are <span class="variable">$&#123;animal&#125;</span>s...&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>/etc/passwd</strong> 中第一个字段存放了用户名，使用循环打印出每个用户名的 <strong>id</strong> 信息；可使用 <strong>cut</strong> 截取第一字段，使用 <strong>id</strong>指令获取用户名的信息（标识符与特殊参数）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim userid.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">users=$(cut -d <span class="string">&#x27;:&#x27;</span> -f1 /etc/passwd)		<span class="comment"># 获取到所有的用户名</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> <span class="variable">$&#123;users&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	id <span class="variable">$&#123;user&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然还可以使用数字来做循环项，比如需要执行 <code>ping 192.168.1.1~192.168.1.100</code> 也就是从 <strong>1 ping</strong> 到 <strong>100</strong>，但是不可能需要我们手动输入 <strong>100</strong> 个数字吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim pingip.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">network=<span class="string">&quot;192.168.0&quot;</span>			<span class="comment"># 先定义一个网域的前部分</span></span><br><span class="line"><span class="keyword">for</span> sitenu <span class="keyword">in</span> $(seq 1 100)	<span class="comment"># seq 为 sequence 连续的意思</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="comment"># ping -c 1 -w 1 192.168.0.101 &amp;&gt; /dev/null &amp;&amp; echo &quot;1&quot; || echo &quot;0&quot;</span></span><br><span class="line">	<span class="comment"># 不显示执行结果，并获取命令是否执行成功</span></span><br><span class="line">	ping -c 1 -w 1 <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> &amp;&gt; /dev/null &amp;&amp; result=0 || result=1</span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;result&#125;</span>&quot;</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is up&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is down&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./pingip.sh</span><br><span class="line">192.168.0.1 is up</span><br><span class="line">192.168.0.2 is down</span><br><span class="line">192.168.0.3 is down</span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p>对于 <code>$(seq 1 100)</code> 来说，还可以使用 <strong>bash</strong> 的内建机制 <code>&#123;1..100&#125;</code> 来代替，中间两个点表示连续的意思，比如想要输出 <strong>a~g</strong> 则可以使用 <code>a..g</code></p>
<p>最后一个范例：</p>
<ol>
<li>让用户输入一个目录</li>
<li>如果目录不存在，则提示并退出程序</li>
<li>如果目录存在，则获取该目录下第一级文件是否可读、可写、可执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vim dir_perm.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个目录，将会检测该目录是否可读、可写、可执行：&quot;</span> dir</span><br><span class="line"><span class="comment"># 判定输入不为空，并且目录存在</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span> == <span class="string">&#x27;&#x27;</span> -o ! -d <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;The <span class="variable">$&#123;dir&#125;</span> is NOT exist in your system&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取该目录下的文件权限信息</span></span><br><span class="line">filelist=$(ls <span class="variable">$&#123;dir&#125;</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;filelist&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        perm=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">test</span> -r <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&quot;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> readable&quot;</span></span><br><span class="line">        <span class="built_in">test</span> -w <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&quot;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> writable&quot;</span></span><br><span class="line">        <span class="built_in">test</span> -x <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&quot;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> executable&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;The file <span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&#x27;s permission is <span class="variable">$&#123;perm&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用这种方式，可以很轻易的来处理一些文件的特性</p>
<h3 id="for-do-done-数值处理"><a href="#for-do-done-数值处理" class="headerlink" title="for...do...done 数值处理"></a><code>for...do...done</code> 数值处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( 初始值; 限制值; 执行步阶))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	循环体</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始值：某个变量在循环中的起始值，可以以 <strong>i=1</strong> 设置好初始值</li>
<li>限制值：当变量值在这个限制值范围内，则继续循环。例如 <strong>i&lt;=100</strong></li>
<li>执行步阶：每执行一次循环时，变量的变化量。例如 <strong>i=i+1</strong>，如果是自增则可以使用 <strong>i++</strong> 来替代</li>
</ul>
<p>范例：计算从 <strong>1</strong> 累加到指定数值的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim cal_1_100-2.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个数值，将计算出从 1 累加到该数值的计算结果&quot;</span> nu</span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=<span class="variable">$&#123;nu&#125;</span>; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	total=$((<span class="variable">$&#123;total&#125;</span>+<span class="variable">$&#123;i&#125;</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1+..+<span class="variable">$&#123;nu&#125;</span> = <span class="variable">$&#123;total&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./cal_1_100-2.sh</span><br><span class="line">请输入一个数值，将计算出从 1 累加到该数值的计算结果2</span><br><span class="line">1+..+2 = 3</span><br><span class="line">[mrcode@study bin]$ ./cal_1_100-2.sh</span><br><span class="line">请输入一个数值，将计算出从 1 累加到该数值的计算结果100</span><br><span class="line">1+..+100 = 5050</span><br></pre></td></tr></table></figure>

<h3 id="搭配随机数与数组的实验"><a href="#搭配随机数与数组的实验" class="headerlink" title="搭配随机数与数组的实验"></a>搭配随机数与数组的实验</h3><p>现在大概已经能够掌握 <strong>shell script</strong> 了。</p>
<p>现在来做个有趣的小东西，今天中午吃啥？要完成这个脚本，首先需要将全部的店家输入到一组数组中，再通过随机数的处理，获得可能的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vim what_to_eat.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义你搜集到的店家信息</span></span><br><span class="line">eat[1]=<span class="string">&quot;卖当当汉堡&quot;</span></span><br><span class="line">eat[2]=<span class="string">&quot;肯爷爷炸鸡&quot;</span></span><br><span class="line">eat[3]=<span class="string">&quot;彩虹日式便当&quot;</span></span><br><span class="line">eat[4]=<span class="string">&quot;越油越好吃打呀&quot;</span></span><br><span class="line">eat[5]=<span class="string">&quot;想不出吃什么&quot;</span></span><br><span class="line">eat[6]=<span class="string">&quot;太师傅便当&quot;</span></span><br><span class="line">eat[7]=<span class="string">&quot;池上便当&quot;</span></span><br><span class="line">eat[8]=<span class="string">&quot;怀恋火车便当&quot;</span></span><br><span class="line">eat[9]=<span class="string">&quot;一起吃泡面&quot;</span></span><br><span class="line">eat[10]=<span class="string">&quot;太上皇&quot;</span></span><br><span class="line">eatnum=10		<span class="comment"># 一共有几家可用的店铺</span></span><br><span class="line"></span><br><span class="line">check=$((<span class="variable">$&#123;RANDOM&#125;</span> * <span class="variable">$&#123;eatnum&#125;</span> / <span class="number">32767</span> + <span class="number">1</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your may eat <span class="variable">$&#123;eat[<span class="variable">$&#123;check&#125;</span>]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br><span class="line">your may eat 太上皇</span><br><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br><span class="line">your may eat 越油越好吃打呀</span><br><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br><span class="line">your may eat 想不出吃什么</span><br><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br></pre></td></tr></table></figure>

<p>继续深入，一次性输出 3 个选择，并且不能重复</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vim what_to_eat-2.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义你搜集到的店家信息</span></span><br><span class="line">eat[1]=<span class="string">&quot;卖当当汉堡&quot;</span></span><br><span class="line">eat[2]=<span class="string">&quot;肯爷爷炸鸡&quot;</span></span><br><span class="line">eat[3]=<span class="string">&quot;彩虹日式便当&quot;</span></span><br><span class="line">eat[4]=<span class="string">&quot;越油越好吃打呀&quot;</span></span><br><span class="line">eat[5]=<span class="string">&quot;想不出吃什么&quot;</span></span><br><span class="line">eat[6]=<span class="string">&quot;太师傅便当&quot;</span></span><br><span class="line">eat[7]=<span class="string">&quot;池上便当&quot;</span></span><br><span class="line">eat[8]=<span class="string">&quot;怀恋火车便当&quot;</span></span><br><span class="line">eat[9]=<span class="string">&quot;一起吃泡面&quot;</span></span><br><span class="line">eat[10]=<span class="string">&quot;太上皇&quot;</span></span><br><span class="line">eatnum=10		<span class="comment"># 一共有几家可用的店铺</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实就是需要轮询出来 3 个不同的索引结果</span></span><br><span class="line"></span><br><span class="line">eated=0	<span class="comment"># 已选中数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;eated&#125;</span>&quot;</span> -lt 3 ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	check=$((<span class="variable">$&#123;RANDOM&#125;</span> * <span class="variable">$&#123;eatnum&#125;</span> / <span class="number">32767</span> + <span class="number">1</span>))</span><br><span class="line">	mycheck=0		<span class="comment"># 当为 0 时，表示不重复</span></span><br><span class="line">	<span class="comment"># 去重检查</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$&#123;eated&#125;</span> -gt 0 ]; <span class="keyword">then</span>			<span class="comment"># 当已选中至少一个店铺的时候，才执行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 <span class="variable">$&#123;eated&#125;</span>)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;eatedcon[$i]&#125;</span>&quot;</span> == <span class="variable">$check</span> ]; <span class="keyword">then</span></span><br><span class="line">        mycheck=1</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$&#123;mycheck&#125;</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;your may eat <span class="variable">$&#123;eat[<span class="variable">$&#123;check&#125;</span>]&#125;</span>&quot;</span></span><br><span class="line">		eated=$(( <span class="variable">$&#123;eated&#125;</span> + <span class="number">1</span> ))</span><br><span class="line">		eatedcon[<span class="variable">$&#123;eated&#125;</span>]=<span class="variable">$&#123;check&#125;</span>		<span class="comment"># 将已选中结果存储起来</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="Shell-Script-的追踪与-debug"><a href="#Shell-Script-的追踪与-debug" class="headerlink" title="Shell Script 的追踪与 debug"></a>Shell Script 的追踪与 debug</h2><p><strong>scripts</strong> 在执行前，最怕出现语法错误问题了，可以通过 <strong>bash</strong> 相关参数来检测</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sh [-nvx] scripts.sh</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-n：不执行 script，仅检查语法问题</span><br><span class="line">-v：执行 script 前，先将 scripts 内容输出到屏幕上</span><br><span class="line">-x：将执行到的 script 内容显示到屏幕上，相当于 debug 了</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：测试 dir_perm.sh 有无语法问题？</span></span><br><span class="line">sh -n dir_perm.sh</span><br><span class="line"><span class="comment"># 如果没有语法问题，则不会显示任何信息</span></span><br><span class="line"><span class="comment"># 笔者实测，貌似语法检测效果并不强大</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将 show_animal.sh 的执行过程全部列出来</span></span><br><span class="line">[mrcode@study bin]$ sh -x show_animal.sh </span><br><span class="line">+ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:/home/mrcode/bin</span><br><span class="line">+ <span class="built_in">export</span> PATH</span><br><span class="line">+ <span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;There are dogs...&#x27;</span></span><br><span class="line">There are dogs...</span><br><span class="line">+ <span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;There are cats...&#x27;</span></span><br><span class="line">There are cats...</span><br><span class="line">+ <span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;There are elephants...&#x27;</span></span><br><span class="line">There are elephants...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是原始脚本，方便对比</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;There are <span class="variable">$&#123;animal&#125;</span>s...&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 可以看到，每次循环执行，都打印出来了关键信息，</span></span><br><span class="line"><span class="comment"># 该功能非常有用，可以当成 debug 来使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>熟悉 <strong>sh</strong> 的用法，可以使你在管理 <strong>Linux</strong> 的过程中得心应手，至于在 <strong>shell script</strong> 的学习方法上，需要多看、多模仿、并加以修改成自己的代码，是最快的学习手段了。网络有上相当多的有用的 <strong>scripts</strong>，你可以将其拿来进行修改成自己的代码</p>
<p>另外，<strong>Linux</strong> 系统本来就有很多的服务启动脚本，如果想要知道每个 <strong>script</strong> 所代表的功能是什么，直接 <strong>vim</strong> 进入该 <strong>script</strong> 查阅下，通常就知道了。比如说之前提到的 <code>/etc/init.d/netconsole</code> 是做什么的？直接查看他的前几行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/netconsole </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># netconsole    This loads the netconsole module with the configured parameters.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: - 50 50</span></span><br><span class="line"><span class="comment"># description: Initializes network console logging</span></span><br><span class="line"><span class="comment"># config: /etc/sysconfig/netconsole</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          netconsole</span></span><br><span class="line"><span class="comment"># Required-Start:    $network</span></span><br><span class="line"><span class="comment"># Short-Description: Initializes network console logging</span></span><br><span class="line"><span class="comment"># Description:       Initializes network console logging of kernel messages.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copyright 2002 Red Hat, Inc.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Based in part on a shell script by</span></span><br><span class="line"><span class="comment"># Andreas Dilger &lt;adilger@turbolinux.com&gt;  Sep 26, 2001</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="进程管理与-SELinux-初探"><a href="#进程管理与-SELinux-初探" class="headerlink" title="进程管理与 SELinux 初探"></a>进程管理与 SELinux 初探</h1><p>一个程序被加载到内存中运行，那么在内存中的那个数据就称为进程（<strong>process</strong>）。</p>
<p>所有系统上跑的数据都会以进程的形态存在，进程有哪些状态？不同的状态会如何影响听的运行？进程之间是否可以互相控管？等等，这些是我们所必须要知道的项目</p>
<p>与进程有关的还有 <strong>SELinux</strong> 加强文件存取安全性的东西</p>
<h2 id="什么是进程（process）"><a href="#什么是进程（process）" class="headerlink" title="什么是进程（process）"></a>什么是进程（process）</h2><p>在 Linux 系统中：<strong>触发任何一个事件事，系统都会将它定义成一个进程，并且给予这个进程一个 ID，称为 PID，同时依据启发这个进程的用户与相关属性关系，给予这个 PID 一组有效的权限设置</strong>。</p>
<h3 id="进程与程序-（process-amp-program）"><a href="#进程与程序-（process-amp-program）" class="headerlink" title="进程与程序 （process &amp; program）"></a>进程与程序 （process &amp; program）</h3><p>执行一个程序或指令，就可以触发一个事件而取得一个 <strong>PID</strong></p>
<p>不同的用户运行程序，程序所拥有的权限也是不同的，概念如下图</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/Linux-pid.png" style="zoom: 67%;" />

<p>系统通过这个 <strong>PID</strong> 来判断该 <strong>process</strong> 是否具有权限进行工作的。</p>
<p>比如我们登陆的 <strong>bash tty</strong>，它是一个程序，登陆之后，系统会根据登陆者的 <strong>UID/GID（/etc/paswd）</strong>来分配一个 <strong>PID</strong>，比如执行了一个 <strong>touch</strong> 的执行，那么由这个进程 <strong>衍生出来的其他进程在一般状态下，也会沿用这个进程的相关权限</strong></p>
<p>程序与进程总结：</p>
<ul>
<li>程序 <strong>program</strong>：通常为 <strong>binary program</strong>，实体文件的形态存在</li>
<li>进程 <strong>process</strong>：程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统并给予这个内存单元一个标识符（<strong>PID</strong>），可以说，进程就是一个正在运行的程序</li>
</ul>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title="子进程与父进程"></a>子进程与父进程</h3><p>上面提到 <strong>衍生出来的进程</strong>，我们登陆到 <strong>bash</strong>，该 <strong>bash</strong> 是一个程序，并有一个 <strong>PID</strong>，在这个 <strong>bash</strong> 上执行指令，触发了相关指令的程序运行，从而得到该程序的 <strong>PID</strong>，这个 <strong>PID</strong> 就是一个子进程，原本的 <strong>bash</strong> 就是一个父进程</p>
<p>下面以一个小练习，来了解什么是子进程/父进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在目前的 bash 环境下，再触发一次 bash，并以 ps -l 指令管擦进程相关的输出信息</span></span><br><span class="line"><span class="comment"># 直接执行 bash 指令，会进入到子进程的环境中</span></span><br><span class="line">[root@study ~]<span class="comment"># bash</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  5713  1923  0  80   0 - 32064 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0  5862  5713  0  80   0 - 29218 do_wai pts/0    00:00:00 bash</span><br><span class="line">4 S     0 10917  5862  0  80   0 -  3184 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 R     0 11193 10917  0  80   0 - 12407 -      pts/0    00:00:00 ps</span><br><span class="line"><span class="comment"># 注意 PID 与 PPID，第 1 行的 PID 与第 2 行的 PPID 是一样的</span></span><br><span class="line"><span class="comment"># 第 2 行的 CMD 是 bash，就是从第一行中执行 bash 产生出来的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你发现，你杀掉了一个进程，不多久又出现了，这样的情况，如果不是 <strong>crontab</strong> 的定时任务产生的，那么就是有一个父进程在产生新的子进程</p>
<h3 id="fork-and-exec：进程呼叫的流程"><a href="#fork-and-exec：进程呼叫的流程" class="headerlink" title="fork and exec：进程呼叫的流程"></a>fork and exec：进程呼叫的流程</h3><p>进程与父进程的关系最为复杂的在于进程相互间的呼叫。</p>
<p>在 <strong>Linux</strong> 的进程呼叫通常称为 <strong>fork-and-exec</strong> 的流程，进程都会借由父进程以复制（<strong>fork</strong>）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 <strong>exec</strong> 的方式来执行时机要进行的程序，最终就成为一个子进程的存在。整个流程类似下图：</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/linux-fork-exec.png" style="zoom:67%;" />

<h3 id="系统或网络服务：常驻在内存的进程"><a href="#系统或网络服务：常驻在内存的进程" class="headerlink" title="系统或网络服务：常驻在内存的进程"></a>系统或网络服务：常驻在内存的进程</h3><p>常驻就是一直在运行的程序，比如 <strong>crond</strong> 程序，每分钟都会扫描 <code>/etc/crontab</code> 以及相关的配置文件，将它启动在背景当中一直持续不断的运行，这就是常驻在内存中的进程</p>
<p>这些进程通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻程序称为 <strong>服务（daemon）</strong>。系统的服务非常多，主要大致分为系统本身所需要的服务，如 <strong>crond</strong>、<strong>atd</strong>、<strong>rsyslogd</strong> 等。还有一些则负责网络联机服务，例如 <strong>Apache</strong>、<strong>named</strong>、<strong>postfix</strong>、<strong>vsftpd</strong> 等，这些网络服务程序被执行后，会启动一个可以负责网络监听的端口 port，以提供外部客户端的联机要求</p>
<div class="note info"><p><strong>TIP</strong></p>
<p><strong>cron</strong> 和 <strong>at</strong> 是他们主要执行的程序名称，但是后面加了一个 <strong>d</strong>，成为 <strong>crond</strong>、<strong>atd</strong> ，是因为这样可以简单的判定为该程序是一个服务 <strong>daemon</strong>，所以一般 <strong>daemon</strong> 类型的程序都会加上 <strong>d</strong> 的文件名，比如服务器篇中会看到的 <strong>httpd</strong>、<strong>vsftpd</strong> 等</p>
</div>

<h3 id="Linux-的多人多任务环境"><a href="#Linux-的多人多任务环境" class="headerlink" title="Linux 的多人多任务环境"></a>Linux 的多人多任务环境</h3><p>了解了进程的知识点后，你可以简单的认为进程的出现，让我们多用户在 <strong>Linux</strong> 都能拥有自己的环境了。</p>
<ul>
<li><p>多人环境</p>
<p><strong>Linux</strong> 最棒的地方就在于它的多人多任务环境。什么是多人多任务？每个账户都有其特殊的权限，除了 <strong>root</strong> 之外，其他人都必须受一些限制，而每个人进入 <strong>Linux</strong> 的环境设置都可以自定义，所以每个人登录后取得的 <strong>shell PI</strong>D 不同，是因为不在同一个进程程序中</p>
</li>
<li><p>多任务行为</p>
<p><strong>CPU</strong> 多在各个进程之间进行切换工作，因此当多人同时登录系统时，你的感觉就像整部主机好像就是你一个人的一样</p>
</li>
<li><p>多重登录环境的七个基本终端窗口</p>
<p>在 <strong>Linux</strong> 中，默认提供了 6 个文字界面登录窗口和一个图形界面，可以使用 <code>alt+F&#123;1-7&#125;</code>来切换不同的终端机界面，每个终端机界面的登录者可以是不同用户</p>
<p>这也是多任务环境下所产生的一个情况，<strong>Linux</strong> 默认会启动 <strong>6</strong> 个终端机登录环境的程序，所以才可以切换，在后续第 19 章开机管理流程中会仔细介绍的。</p>
</li>
<li><p>特殊的进程管理行为</p>
<p>对于宕机情况，在 <strong>Linux</strong> 上，几乎不会出现，因为他可以在任何时候，将某个困住的进程杀掉，然后在重新执行该进程而不用重新启动。</p>
<p>比如在 <strong>Linux</strong> 下以文字界面登录，在屏幕中显示错误信息后就挂了，不能动了。这个时候你可以切换到另外的 6 个终端机接口，以 <code>ps -aux</code> 找出刚刚的错误进程，<strong>kiil</strong> 掉它，再回到刚刚的终端机界面就好了（笔者疑问？<strong>kill</strong> 后会自动重启？有点不太理解）</p>
</li>
<li><p><strong>bash</strong> 环境下的工作管理</p>
<p>当我们登录 <strong>bash</strong> 后，取到了一个 <strong>PID</strong>，那么在这个环境下执行的其他指令，几乎是子进程了，在这个单一的 <strong>bash</strong> 接口中，可以如下进行多个工作，并且是同时进行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述指令串中，<code>&amp;</code> 表示把 <strong>file1</strong> 复制为 <strong>file2</strong>，并放到背景中执行。也就是说，下达完这一串指令后，马上就可以下达其他的指令串了，当着一个指令执行完成后，系统将会在你的终端接口显示完成的消息</p>
</li>
<li><p>多人多任务的系统资源分配问题考虑</p>
<p>当人多的时候，由于是共用计算机资源，所以有可能会导致资源不够用的情况发生，这个时候就需要升级机器了</p>
</li>
</ul>
<hr>
<h2 id="工作管理（job-control）"><a href="#工作管理（job-control）" class="headerlink" title="工作管理（job control）"></a>工作管理（job control）</h2><p>是在 <strong>bash</strong> 环境下的概念，当我们登录系统取得 <strong>bash shell</strong> 后，在单一终端机下同时进行多个工作的行为管理。</p>
<h3 id="什么是工作管理？"><a href="#什么是工作管理？" class="headerlink" title="什么是工作管理？"></a>什么是工作管理？</h3><p>进行工作管理的行为中，其实每个工作都是目前 bash 的子进程，彼此之间是有相关性的。我们<strong>无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash</strong></p>
<p>为什么会有工作管理？系统有多个 tty 使用，这样切换很麻烦，还有之前讲解的 <code>/etc/security/limits.conf(第 13 章)</code>可以设置同时登录的联机数量，假设只允许一个呢？</p>
<p>假设我们只有一个终端机接口，因此在可以出现提示字符让你操作的环境称为 <strong>前景 foreground</strong>，其他工作可以放入 <strong>背景 background</strong> 去暂停或运行。要注意的是：放入背景的工作在运行时，不能与使用者互动。比如 <strong>vim</strong> 不能再背景里面执行（<strong>running</strong>）的，因为你没有输入数据它就不会运行。<strong>而且放入背景的工作是不可以使用 ctrl+c 来终止的</strong></p>
<p>进行 <strong>bash</strong> 的 <strong>job control</strong> 必须要注意的限制是：</p>
<ul>
<li>这些工作所触发的进程必须来自于你的 <strong>shell</strong> 的子进程（只管理自己的 <strong>bash</strong>）</li>
<li>前景 <strong>foreground</strong>：你可以控制与下达指令的环境</li>
<li>背景：可以自动运行的工作，你无法使用 <strong>ctrl + c</strong> 终止它，可以使用 <strong>bg</strong>、<strong>fg</strong> 呼叫该工作</li>
<li>背景中<strong>执行</strong>的进程不能等待 <strong>terminal/shell</strong> 的输入（<strong>input</strong>）</li>
</ul>
<h3 id="job-control-的管理"><a href="#job-control-的管理" class="headerlink" title="job control 的管理"></a>job control 的管理</h3><h4 id="直接将指令丢到背景中-执行-的-amp"><a href="#直接将指令丢到背景中-执行-的-amp" class="headerlink" title="直接将指令丢到背景中 执行 的 &amp;"></a>直接将指令丢到背景中 <em>执行</em> 的 <code>&amp;</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 &amp; 将 /etc/ 整个备份为 /tmp/etc/tar.gz 工作丢到背景中执行</span></span><br><span class="line"><span class="comment"># 原因就是，压缩费时，不想一直就在当前界面看着他完成</span></span><br><span class="line">[root@study ~]<span class="comment"># tar -zpcf /tmp/etc.tar.gz /etc &amp;</span></span><br><span class="line">[1] 19763			<span class="comment"># job number 与 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># tar: Removing leading `/&#x27; from member names</span></span><br><span class="line"><span class="comment"># PID 与 bash 的控制有关，后续出现的数据信息是 tar 执行的数据流</span></span><br><span class="line"><span class="comment"># 由于没有加上数据流重导向，所以会影响画面，不过不会影响前景的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那他什么时候完成呢？当你输入几个指令后，发现出现了这一行</span></span><br><span class="line"><span class="comment"># 那么久表示在背景中的工作已经完成了</span></span><br><span class="line">[1]+  Done                    tar -zpcf /tmp/etc.tar.gz /etc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>[1]+</code> 表示这个工作已经完成（<strong>Done</strong>），后面是具体的指令串。如果有有信息出现，那么你的前景会出现干扰，只需要按下 <strong>enter</strong> 键就会出现提示字符，更下下指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># tar -zpcvf /tmp/etc.tar.gz /etc &amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于输出了信息，<strong>stdout</strong> 和 <strong>stderr</strong> 都会输出到屏幕上，这样就会影响前景终端，所以一般都利用数据流重导向，将输出数据传送至某个文件中，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># tar -zpcvf /tmp/etc.tar.gz /etc  &gt; /tmp/log.txt 2&gt;&amp;1 &amp;</span></span><br><span class="line">[1] 16592</span><br><span class="line">[root@study ~]<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="将-目前-的工作丢到背景中-暂停-：ctrl-z"><a href="#将-目前-的工作丢到背景中-暂停-：ctrl-z" class="headerlink" title="将 目前 的工作丢到背景中_暂停_：ctrl+z"></a>将 <em>目前</em> 的工作丢到背景中_暂停_：ctrl+z</h4><p>考虑这个场景，我正在使用 <strong>vim</strong>，却发现某个文件的路径不记得了，需要到 <strong>bash</strong> 环境下进程搜索，此时不需要结束 <strong>vim</strong>，可以把它丢到背景中等待</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># vim ~/.bashrc </span></span><br><span class="line"><span class="comment"># 在 vim 环境下按 ctrl + z 组合键</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[root@study ~]<span class="comment"># 		# 这就取得了前景</span></span><br><span class="line">[root@study ~]<span class="comment"># find / -print</span></span><br><span class="line"><span class="comment"># 会大量输出信息，我们把这个工作也丢到背景中执行</span></span><br><span class="line">[3]+  Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[root@study ~]<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>[2]+</code> 表示这个是加入到背景中的第二个工作，<strong>Stopped</strong> 是状态，预设情况下，使用 <strong>ctrl+z</strong> 丢到背景中的工作都是暂停状态</p>
<h4 id="观察目前的背景工作状态：jobs"><a href="#观察目前的背景工作状态：jobs" class="headerlink" title="观察目前的背景工作状态：jobs"></a>观察目前的背景工作状态：jobs</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span> [-lrs]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-l：除了列出 job number 与指令之外，同时列出 PID 的号码</span><br><span class="line">	-r：仅列出正在背景 run 的工作</span><br><span class="line">	-s：仅列出正在背景中暂停 stop 的工作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：观察目前的 bash 中，所有工作与队友的 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># jobs -l</span></span><br><span class="line">[2]- 26476 Stopped                 vim ~/.bashrc</span><br><span class="line">[3]+  2207 Stopped                 find / -<span class="built_in">print</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仔细看上面有减号和加号：</p>
<ul>
<li><code>+</code>：表示最近被放到背景的工作；如果只输入 <strong>fg</strong> 指令，那么 <code>[3]</code> 会被拿到前景中来处理</li>
<li><code>-</code>：表示最近最后第二个被放置到背景中的工作。如果超过最后第三个以后的工作，就不会有 <code>-、+</code> 符号了</li>
</ul>
<h4 id="将背景工作拿到前景来处理：fg"><a href="#将背景工作拿到前景来处理：fg" class="headerlink" title="将背景工作拿到前景来处理：fg"></a>将背景工作拿到前景来处理：fg</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> %jobnumber</span><br><span class="line"></span><br><span class="line"><span class="variable">$jobnumber</span>: jobnumber 是工作号码（数字），哪个 % 是可有可无的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：先以 jobs 管擦工作，再将工作取出</span></span><br><span class="line">[root@study ~]<span class="comment"># jobs -l</span></span><br><span class="line">[2]- 26476 Stopped                 vim ~/.bashrc</span><br><span class="line">[3]+  2207 Stopped                 find / -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 取出 + 号的工作，注意会刷屏，马上按下 ctrl + z ，再次放入到背景中</span></span><br><span class="line">[root@study ~]<span class="comment"># fg</span></span><br><span class="line"><span class="comment"># 直接取出 2 的工作，在放到背景中</span></span><br><span class="line">[root@study ~]<span class="comment"># fg %2</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[root@study ~]<span class="comment"># jobs -l</span></span><br><span class="line">[2]+ 26476 Stopped                 vim ~/.bashrc</span><br><span class="line">[3]-  2207 Stopped                 find / -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到， 2 的工作被标记为了 + 号，表示是最近放进去的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="让工作在背景下的状态变成运行中：bg"><a href="#让工作在背景下的状态变成运行中：bg" class="headerlink" title="让工作在背景下的状态变成运行中：bg"></a>让工作在背景下的状态变成运行中：bg</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1： 执行 find / -perm /7000 &gt; /tmp/text.txt，立刻丢到背景去暂停</span></span><br><span class="line">[root@study ~]<span class="comment"># find / -perm /7000 &gt; /tmp/text.txt</span></span><br><span class="line">find: <span class="string">&#x27;/proc/29541/task/29541/fd/5&#x27;</span>: No such file or directory</span><br><span class="line">find: <span class="string">&#x27;/proc/29541/task/29541/fdinfo/5&#x27;</span>: No such file or directory</span><br><span class="line">find: <span class="string">&#x27;/proc/29541/fd/6&#x27;</span>: No such file or directory</span><br><span class="line">find: <span class="string">&#x27;/proc/29541/fdinfo/6&#x27;</span>: No such file or directory</span><br><span class="line">^Z</span><br><span class="line">[4]+  Stopped                 find / -perm /7000 &gt; /tmp/text.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：让该工作在背景下进行，并且观察他</span></span><br><span class="line">[root@study ~]<span class="comment"># jobs ; bg %4; jobs</span></span><br><span class="line">[2]-  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[4]+  Stopped                 find / -perm /7000 &gt; /tmp/text.txt</span><br><span class="line"></span><br><span class="line">[4]+ find / -perm /7000 &gt; /tmp/text.txt &amp;</span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[4]-  Running                 find / -perm /7000 &gt; /tmp/text.txt &amp;</span><br><span class="line"><span class="comment"># 第 4 个由 Stopped 变成了 Running 状态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="管理背景中的工作：kill"><a href="#管理背景中的工作：kill" class="headerlink" title="管理背景中的工作：kill"></a>管理背景中的工作：kill</h4><p>通过 <strong>fg</strong> 拿到前景来，可以通过 <strong>kill</strong> 将该工作直接移除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -signal <span class="variable">$jobnumber</span></span><br><span class="line"><span class="built_in">kill</span> -l</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-l：L 的小写，列出目前 <span class="built_in">kill</span> 能够使用的信号（signal）有哪些？</span><br><span class="line">	signal：给予后续工作什么指示，用 man 7 signal 可知：</span><br><span class="line">		-1：重新读取一次参数的配置文件（类似 reload）</span><br><span class="line">		-2：代表与由键盘输入 ctrl+c 同样的动作</span><br><span class="line">		-9：立刻强制删除一个工作</span><br><span class="line">		-15：已正常的进程方式终止一项工作。与  -9 是不一样的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">范例 1： 找出目前 bash 环境下的背景工作，并将该工作 强制删除</span><br><span class="line">[root@study ~]<span class="comment"># jobs</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[4]-  Exit 1                  find / -perm /7000 &gt; /tmp/text.txt</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># kill -9 %3; jobs</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Killed                  find / -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 过几秒再运行 jobs 会发现 killed 的不见了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：找出目前 bash 环境下的而背景工作，并将该工作 正常 终止</span></span><br><span class="line">[root@study ~]<span class="comment"># kill -SIGTERM %2</span></span><br><span class="line"></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[root@study ~]<span class="comment"># jobs</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line"><span class="comment"># -SIGTERM 与 -15 同效果，可以用哪个 kill -l 来查阅</span></span><br><span class="line"><span class="comment"># 在这个案例中，会发现 vim 的工作无法被结束，无法通过 kill 正常终止</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <strong>vim</strong> 时候，会产生一个 <code>.filename.swp</code> 文件，使用 <strong>-15</strong> 这个 <strong>signal</strong> 时，<strong>vim</strong> 会尝试以正常的步骤来结束掉该 <strong>vi</strong> 的工作，使用 <code>.filename.swp</code> 会主动的被移除，若是使用 <strong>-9</strong>，那么 <strong>swp</strong> 文件不会被移除调用</p>
<p><strong>kill</strong> 需要了解 <strong>1</strong>、9、15 的 signal 的含义，可以用 man 7 signal 查询相关资料，还有一个 killall 也是同样的用法。</p>
<p>kill 后面接的数字，默认是 PID，要管理 bash 的工作控制，需要加上 %数字 的方式</p>
<h3 id="脱机管理问题"><a href="#脱机管理问题" class="headerlink" title="脱机管理问题"></a>脱机管理问题</h3><p><strong>注意</strong>：前面工作管理中的「背景」是指在终端机模式下可以避免「ctrl+c」中断，可以理解为是这个 bash 的背景，并 <strong>不是放到系统的背景</strong> 中去。所以，工作管理的背景依旧与终端机有关</p>
<p>如果你是以远程方式连接到 Linux 主机，并且将工作以 &amp; 的方式放到背景中去，在工作未结束时，你脱机了，该工作不会继续进行，而是会被中断掉</p>
<p>那么可以使用前一章学习的 at 指令，因为它是将工作放置到系统背景，还可以使用 nohup 指令来达到效果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup [指令与参数]		<span class="comment"># 在终端机前景中工作</span></span><br><span class="line">nohup [指令与参数]		<span class="comment"># 在终端机背景中工作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>TIP</strong></p>
<p><strong>nohup</strong> 后面的指令不支持 <strong>bash</strong> 内置指令！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 编辑一个会随眠  500 秒的程序</span></span><br><span class="line">[root@study ~]<span class="comment"># vim sleep500.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/bin/sleep 500s</span><br><span class="line">/bin/<span class="built_in">echo</span> <span class="string">&quot;I have sleep 500 seconds.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 丢到背景中执行</span></span><br><span class="line">[root@study ~]<span class="comment"># chmod a+x sleep500.sh </span></span><br><span class="line">[root@study ~]<span class="comment"># nohup ./sleep500.sh &amp;</span></span><br><span class="line">[3] 14915</span><br><span class="line">[root@study ~]<span class="comment"># nohup: ignoring input and appending output to &#x27;nohup.out&#x27;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>你登出登录后，再次登录系统，使用 <strong>pstree</strong> （这里没有说是什么）去查询你的进程，会发现它还在执行，还输出了一个信息，<strong>nohup</strong> 与终端机无关了，因此整个信息的输出就会被导向 <code>~/nohup.out</code></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>为什么进程管理这么重要？是因为：</p>
<ul>
<li>我们在操作系统时的各项工作都是经过某个 <strong>PID</strong> 来达成的（包括你的 <strong>bash</strong> 环境），因此，能不能进行某项工作，与该进程的权限有关</li>
<li>如果你的 <strong>LInux</strong> 是个很忙碌的系统，当整个系统资源要被使用光的时候，你是否能够找出最耗资源的哪个进程，然后删除该进程，让系统恢复正常？</li>
<li>由于某个程序写的不好，导致产生一个有问题的进程在内存中，如何找出它，将它移除呢？</li>
<li>如果有 5、6 项工作在系统中运行，但其中有一项工作才是最重要的，该如何让那一项重要的工作被最优先执行？</li>
</ul>
<p>以上几点，在系统使用中都是很重要且常见的问题</p>
<h3 id="进程的观察"><a href="#进程的观察" class="headerlink" title="进程的观察"></a>进程的观察</h3><h4 id="ps：将某个时间点的进程运行情况截取下来"><a href="#ps：将某个时间点的进程运行情况截取下来" class="headerlink" title="ps：将某个时间点的进程运行情况截取下来"></a>ps：将某个时间点的进程运行情况截取下来</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ps aux		<span class="comment"># 观察系统所有的进程数据</span></span><br><span class="line">ps -l 		<span class="comment"># 观察与当前终端机相关的进程</span></span><br><span class="line">ps -lA 		<span class="comment"># 观察系统所有的进程数据（显示内容项同 ps -l 的项一样，只不过是系统所有进程）</span></span><br><span class="line">ps axjf		<span class="comment"># 连同部分进程树状态</span></span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：所有的 process 都显示出来，与 -e 具有同样的效果</span><br><span class="line">	-a：不与 terminal 有关的所有 process</span><br><span class="line">	-u：有效使用者（effective user）相关的 process</span><br><span class="line">	x：通常与 a 一起使用，可列出完整信息</span><br><span class="line">输出格式规划：</span><br><span class="line">	l：较长、较详细的将该 PID 的信息列出</span><br><span class="line">	j：工作的格式（<span class="built_in">jobs</span> format）</span><br><span class="line">	-f：做一个更为完整的输出</span><br></pre></td></tr></table></figure>

<p><strong>ps</strong> 指令的 <strong>man page</strong> 不太好查阅，不同的 <strong>Unix</strong> 都使用 <strong>ps</strong> 来查阅进程状态，为了符合不同版本的需求，该 <strong>man page</strong> 写的非常庞大，因此建议你有两个选择：</p>
<ol>
<li>只能查询自己 <strong>bash</strong> 进程的 <code>ps -l</code></li>
<li>可以查询所有系统运行的进程 <code>ps aux</code></li>
</ol>
<h4 id="仅查看自己的-bash-相关进程：ps-l"><a href="#仅查看自己的-bash-相关进程：ps-l" class="headerlink" title="仅查看自己的 bash 相关进程：ps -l"></a>仅查看自己的 bash 相关进程：<code>ps -l</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1： 将目前属于您自己这次登录的 PID 与相关信息列出来（只与自己的 bash 有关）</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0 29260 28796  0  80   0 - 57972 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0 29473 29260  0  80   0 - 29090 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 R     0 30444 29473  0  80   0 - 12407 -      pts/0    00:00:00 ps</span><br><span class="line"><span class="comment"># 前面三项，最初是用了普通账户登录的，使用了 su - 切换到了一个 bash</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里列出的只是与你操作环境 <strong>bash</strong> 有关的进程，没有延伸到 <strong>systemd</strong>（后续交代）：</p>
<ul>
<li><strong>F</strong>：进程旗标（<strong>process flags</strong>），说明这个进程的总结权限，常见的号码有：<ul>
<li><strong>4</strong>：表示此进程的权限为 <strong>root</strong></li>
<li><strong>1</strong>：则表示此子进程仅进行 <strong>复制（fork）而没有实际执行（exec）</strong></li>
</ul>
</li>
<li><strong>S</strong>：进程状态（<strong>STAT</strong>），主要状态有：<ul>
<li><strong>R</strong>（<strong>Running</strong>）：正在运行中</li>
<li><strong>S</strong>（<strong>Sleep</strong>）：该程序目前正在睡眠状态（<strong>idle</strong>），但可以被唤醒（<strong>signal</strong>）</li>
<li><strong>D</strong>：不可被唤醒的睡眠状态，通常该程序可能在等待 <strong>I/O</strong> 的情况</li>
<li><strong>T</strong>：停止状态（<strong>stop</strong>），可能是在工作控制（背景暂停）或除错（<strong>traced</strong>）状态</li>
<li><strong>Z</strong>（<strong>Zombie</strong>）：僵尸状态，进程已终止但却无法被移除至内存外</li>
</ul>
</li>
<li><strong>UUID/PID/PPID</strong>：代表此进程被该 <strong>UID</strong> 所拥有、进程的 <strong>PID</strong> 、此进程的父进程 <strong>PID</strong></li>
<li><strong>C</strong>：代表 <strong>CPU</strong> 使用率，单位为百分比</li>
<li><strong>PRI/NI</strong>：<strong>Priority/Nice</strong> 的缩写，代表此进程被 <strong>CPU</strong> 所执行的优先级，数值越小表示该进程越快被 <strong>CPU</strong> 执行。详细的 <strong>PRI</strong> 与 <strong>NI</strong> 将在下一小节讲解</li>
<li><strong>ADDR/SZ/WCHAN</strong>：都与内存有关<ul>
<li><strong>ADDR</strong>：<strong>kernel function</strong>，该进程在内存的哪个部分，如果是 <strong>running</strong> 的进程，一般会显示 <code>-</code></li>
<li><strong>SZ</strong>：该进程用掉多少内存</li>
<li><strong>WCHAN</strong> 该进程是否运行中，若为 <code>-</code> 表示正在运行中</li>
</ul>
</li>
<li><strong>TTY</strong>：登陆者的终端机位置，若为远程登录则使用动态终端接口（<strong>pts/n</strong>）</li>
<li><strong>TIME</strong>：使用掉的 <strong>CPU</strong> 时间。注意：是此进程实际花费 <strong>CPU</strong> 运行的时间</li>
<li><strong>CMD</strong>：<strong>command</strong> 的缩写，此进程的触发程序指令</li>
</ul>
<p>如上列出的信息表示， <strong>bash</strong> 的程序属于 <strong>UID</strong> 为 0 的使用者，状态是睡眠（<strong>sleep</strong>），他睡眠是因为他触发了 <strong>ps</strong>（状态为 <strong>R</strong>，<strong>run</strong>）的原因，<strong>ps</strong> 的 PID=30444，优先执行顺序为 80，下达 bash 所取得的终端机接口为 pts/0，运行状态为 do_wai</p>
<h4 id="观察系统所有进程：ps-aux"><a href="#观察系统所有进程：ps-aux" class="headerlink" title="观察系统所有进程：ps aux"></a>观察系统所有进程：ps aux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ps aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.5 128372  6988 ?        Ss   21:14   0:01 /usr/lib/systemd/systemd --switched-root --system --deseriali</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    21:14   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        S&lt;   21:14   0:00 [kworker/0:0H]</span><br><span class="line">...</span><br><span class="line">root     27082  0.0  0.1  51752  1716 pts/2    R+   21:41   0:00 ps aux</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会发现 <code>ps -l</code> 与 <code>ps aux</code> 显示的项目也不一样</p>
<ul>
<li><strong>USER</strong>：该 <strong>process</strong> 属于哪个使用者账户</li>
<li><strong>PID</strong>：进程标识符</li>
<li><code>%CPU</code>：该进程使用掉的 <strong>CPU</strong> 资源百分比</li>
<li><code>%MEM</code>：占用的虚拟内存（<strong>KBytes</strong>）</li>
<li><strong>RSS</strong>：占用的固定内存（<strong>KBytes</strong>）</li>
<li><strong>TTY</strong>：在哪个终端机上面运行？<ul>
<li><code>?</code>：与终端机无关</li>
<li><code>tty1-tty6</code>：本机上登录的</li>
<li><code>pts/0</code>等：是由网络连接进入的进程</li>
</ul>
</li>
<li><strong>STAT</strong>：目前的状态，与 <code>ps -l</code> 中的状态相同含义</li>
<li><strong>START</strong>：该进程被触发启动时间（如果太久不会显示具体时间）</li>
<li><strong>TIME</strong>：该进程实际使用 <strong>CPU</strong> 运行的时间</li>
<li><strong>COMMAND</strong>：进程执行的指令</li>
</ul>
<p>一般来说，<strong>ps aux</strong> 会按照 <strong>PID</strong> 的顺序来排序显示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：以范例 1 的显示内容，显示出所有的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0 25710  1956  0  80   0 - 57972 do_wai pts/2    00:00:00 su</span><br><span class="line">4 S     0 25917 25710  0  80   0 - 29090 do_wai pts/2    00:00:00 bash</span><br><span class="line">0 R     0 32189 25917  0  80   0 - 12407 -      pts/2    00:00:00 ps</span><br><span class="line">[root@study ~]<span class="comment"># ps -lA</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0     1     0  0  80   0 - 32093 ep_pol ?        00:00:01 systemd</span><br><span class="line">1 S     0     2     0  0  80   0 -     0 kthrea ?        00:00:00 kthreadd</span><br><span class="line">1 S     0     4     2  0  60 -20 -     0 worker ?        00:00:00 kworker/0:0H</span><br><span class="line">1 S     0     6     2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/0</span><br><span class="line">1 S     0     7     2  0 -40   - -     0 smpboo ?        00:00:00 migration/0</span><br><span class="line">1 S     0     8     2  0  80   0 -     0 rcu_gp ?        00:00:00 rcu_bh</span><br><span class="line">1 R     0     9     2  0  80   0 -     0 -      ?        00:00:01 rcu_sched</span><br><span class="line"><span class="comment"># 会发现，与 ps -l 显示类似，不过显示的是系统的所有进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 4：列出类似进程树的进程显示</span></span><br><span class="line">[root@study ~]<span class="comment"># ps axjf</span></span><br><span class="line"> PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND</span><br><span class="line">    0     2     0     0 ?           -1 S        0   0:00 [kthreadd]</span><br><span class="line">    2     4     0     0 ?           -1 S&lt;       0   0:00  \_ [kworker/0:0H]</span><br><span class="line">    2     6     0     0 ?           -1 S        0   0:00  \_ [ksoftirqd/0]</span><br><span class="line">    1  1269  1269  1269 ?           -1 Ss       0   0:00 /usr/sbin/sshd -D</span><br><span class="line"> 1269  1922  1922  1922 ?           -1 Ss       0   0:01  \_ sshd: mrcode [priv]</span><br><span class="line"> 1922  1932  1922  1922 ?           -1 S     1000   0:09  |   \_ sshd: mrcode@pts/0,pts/1</span><br><span class="line"> 1932  1934  1934  1934 pts/0     1934 Ss+   1000   0:00  |       \_ -bash</span><br><span class="line"> 1932  1939  1939  1939 ?           -1 Ss    1000   0:00  |       \_ /usr/libexec/openssh/sftp-server</span><br><span class="line"> 1932  1941  1941  1941 pts/1     2573 Ss    1000   0:00  |       \_ -bash</span><br><span class="line"> 1941  2573  2573  1941 pts/1     2573 S+    1000   0:04  |       |   \_ top</span><br><span class="line"> 1932  7742  7742  7742 ?           -1 Ss    1000   0:00  |       \_ bash -c <span class="built_in">export</span> LANG=<span class="string">&quot;en_US.UTF-8&quot;</span>;<span class="built_in">export</span> LANGUAGE=<span class="string">&quot;en_US.</span></span><br><span class="line"><span class="string"> 7742  7789  7742  7742 ?           -1 S     1000   0:00  |           \_ sleep 1</span></span><br><span class="line"><span class="string"> 1269  1926  1926  1926 ?           -1 Ss       0   0:01  \_ sshd: mrcode [priv]</span></span><br><span class="line"><span class="string"> 1926  1950  1926  1926 ?           -1 S     1000   0:09      \_ sshd: mrcode@pts/2,pts/3</span></span><br><span class="line"><span class="string"> 1950  1956  1956  1956 pts/2     7790 Ss    1000   0:00          \_ -bash</span></span><br><span class="line"><span class="string"> 1956 25710 25710  1956 pts/2     7790 S        0   0:00          |   \_ su -</span></span><br><span class="line"><span class="string">25710 25917 25917  1956 pts/2     7790 S        0   0:00          |       \_ -bash</span></span><br><span class="line"><span class="string">25917  7790  7790  1956 pts/2     7790 R+       0   0:00          |           \_ ps axjf</span></span><br><span class="line"><span class="string"> 1950  2009  2009  2009 ?           -1 Ss    1000   0:00          \_ /usr/libexec/openssh/sftp-server</span></span><br><span class="line"><span class="string"> 1950  2012  2012  2012 pts/3     2574 Ss    1000   0:00          \_ -bash</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>看上面 <strong>PPID</strong> 为 <strong>1269</strong> 的那一行开始，我这里使用了 <strong>ssh</strong> 远程链接，用的是 <strong>mrcode</strong> 账户，登录成功后，获得了一个 <strong>bash</strong> 环境，后面我使用了 <code>su -</code> 指令切换到了 <strong>root</strong> 的 <strong>bash</strong> 环境，然后执行了刚刚的 <strong>ps axjf</strong> 指令。这样就比较清楚了。</p>
<p>还可以通过 <strong>pstree</strong> 指令来显示进程树，不过貌似没有这么详细</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 5：找出与 cron 和 rsyslog 这两个服务有关的 PID 号码</span></span><br><span class="line">[root@study ~]<span class="comment"># ps aux | egrep &#x27;(cron|rsyslog)&#x27;</span></span><br><span class="line">root      1273  0.0  0.3 215672  3652 ?        Ssl  21:15   0:00 /usr/sbin/rsyslogd -n</span><br><span class="line">root      1285  0.0  0.1 126288  1696 ?        Ss   21:15   0:00 /usr/sbin/crond -n</span><br><span class="line">root      4838  0.0  0.0   9096   932 pts/2    R+   21:58   0:00 grep -E --color=auto (cron|rsyslog)</span><br><span class="line"><span class="comment"># 对于上面为什么要使用 egrep，在第 11 章，延伸正则表示法中有介绍。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="僵尸进程-zombie"><a href="#僵尸进程-zombie" class="headerlink" title="僵尸进程 zombie"></a>僵尸进程 zombie</h4><p>僵尸 <strong>zombie</strong>：该进程以及执行完毕或则是因故应该要终止了，但是该进程的父进程却无法完整的将该进程结束掉，而造成哪个进程一直在内存中。</p>
<p>在进程中它的标识是在 <strong>CMD</strong> 后面有 <code>&lt;defunct&gt;</code> 标识,例如下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache 8683 0.0 0.9 83383 9992 ？Z 14:33 0:00 /usr/sbin/httpd&lt;defunct&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当系统不稳定时，容易造成僵尸进程，可能是因为程序有问题，或则是使用者的操作习惯不良等。</p>
<p>发现有僵尸进程时，应该找出来，分析原因，否则有可能一直产生僵尸进程</p>
<p>事实上，通常僵尸进程都已经无法管控，而直接交给 <strong>systemd</strong> 程序来负责了，偏偏 <strong>systemd</strong> 是系统第一个执行的程序，它是所有程序的父程序，无法杀掉该程序（杀掉它，系统就死了），所以，经过一段时间后，系统无法通过核心非经常性的特殊处理来将该进程删除时，那只有重启机器了</p>
<h3 id="top：动态观察进程的变化"><a href="#top：动态观察进程的变化" class="headerlink" title="top：动态观察进程的变化"></a>top：动态观察进程的变化</h3><p><strong>ps</strong> 可以显示一个时间点的进程状态，而 <strong>top</strong> 则可以持续的侦测进程运行状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">top [-d 数字] | top [-bnp]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-d：后面可以接秒数，整个进程画面更新的秒数，预设是 5 秒更新一次</span><br><span class="line">	-b：以批次的方式执行 top，还有更多的参数可以使用（莫名其妙啊，啥参数？），通常会搭配数据流重导向来将批次的结果输出为文件</span><br><span class="line">	-n：与 -b 搭配，需要进行几次 top 的输出</span><br><span class="line">	-p：指定某些 PID 来进行观察</span><br><span class="line"></span><br><span class="line">在 top 执行过程中可以使用的按键指令：</span><br><span class="line">	？：显示在 top 中可以输入的按键指令</span><br><span class="line">	P：以 CPU 的使用资源排序显示</span><br><span class="line">	M：以 Memory 的使用资源排序显示</span><br><span class="line">	N：以 PID 排序</span><br><span class="line">	T：由该进程使用 CPU 时间累积（TIME+）排序</span><br><span class="line">	k：给予某个 PID 一个信号（signal）</span><br><span class="line">	r：给予某个 PID 重新制定一个 nice 值</span><br><span class="line">	q：离开 top 软件的按键</span><br><span class="line">	E：切换单位显示，比如从 KB 切换为 G 显示</span><br><span class="line">	c：切换 COMMAND 的信息，name/完成指令</span><br></pre></td></tr></table></figure>

<p><strong>top</strong> 的功能太多，可用的按键也很多，可以参考 <strong>man top</strong> 的内部文件说明，上面只是列出常用的选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：每两秒更新一次 top，观察整体信息</span></span><br><span class="line">[root@study ~]<span class="comment"># top -d 2</span></span><br><span class="line">top - 22:20:11 up  1:05,  4 users,  load average: 0.52, 0.53, 0.52</span><br><span class="line">Tasks: 186 total,   2 running, 184 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  7.7 us,  9.7 sy,  0.0 ni, 82.1 id,  0.0 wa,  0.0 hi,  0.5 si,  0.0 st</span><br><span class="line">KiB Mem :  1190952 total,   428928 free,   402624 used,   359400 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.   632160 avail Mem</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; 如果按下 k 或 r 时，有相关的提示在这里出现</span></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                    </span><br><span class="line"> 1699 gdm       20   0 2947388 136736  61224 S  0.5 11.5   0:04.00 gnome-shell                                                </span><br><span class="line"> 1932 mrcode    20   0  161324   3016   1296 S  0.5  0.3   0:17.28 sshd                                                       </span><br><span class="line"> 1950 mrcode    20   0  161324   3028   1296 S  0.5  0.3   0:17.41 sshd                                                       </span><br><span class="line"> 2573 mrcode    20   0  162820   3068   1576 S  0.5  0.3   0:07.43 top                                                        </span><br><span class="line">    1 root      20   0  128372   6988   4196 S  0.0  0.6   0:01.67 systemd</span><br></pre></td></tr></table></figure>

<p><strong>top</strong> 的信息基本上分为两个区域，上面 <strong>6</strong> 行，和下面的列表</p>
<ul>
<li><p>第一行信息：<strong>top</strong> -</p>
<ul>
<li><p>目前开机时间：<strong>22:20:11</strong> 这个</p>
</li>
<li><p>开机到目前为止所经过的时间：<strong>up 1:05</strong> 这个</p>
</li>
<li><p>已经登录系统的用户人数：<strong>4 users</strong></p>
</li>
<li><p>系统在 <strong>1、5、15</strong> 分钟的平均工作负载</p>
<p>在第 <strong>15</strong> 章谈到过 <strong>batch</strong> 工作方式负载小于 <strong>0.8</strong> 就是这里显示的值了。</p>
<p>表示的是，系统平均要负责运行几个进程，这里是三个值，也就是对应平均 1/5/15 分钟</p>
<p>越小达标系统越空闲，若高于 <strong>1</strong> ，那么你的系统进程执行太频繁了</p>
</li>
</ul>
</li>
<li><p>第二行：<strong>tasks</strong></p>
<p>显示的是目前进程的总量与各个状态（<strong>running、sleeping、stopped、zombie</strong>）的进程数量</p>
<p>如果发现有 <strong>zombie</strong> 进程的话，就需要找下是哪个进程变成了僵尸进程了</p>
</li>
<li><p>第三行：<code>$Cpus</code></p>
<p><strong>CPU</strong> 整体负载，每个项目可使用 ？ 查询。</p>
<p>需要特别注意的是 <strong>wa</strong> 项，表示 <strong>I/O wait</strong>，通常系统变慢，都是 <strong>I/O</strong> 产生的问题比较大，需要特别注意该项占用的 <strong>CPU</strong> 资源，如果是多核 <strong>CPU</strong>，可以按下数字键「<strong>1</strong>」来切换成不同 <strong>CPU</strong></p>
</li>
<li><p>第四行和第五行</p>
<p>目前的物理内存与虚拟内存（<strong>Mem/Swap</strong>）的使用情况。要注意的是 <strong>swap</strong> 的使用量要尽量的少，如果 <strong>swap</strong> 被大量使用，表示系统的物理内存不足</p>
</li>
<li><p>第六行：当在 <strong>top</strong> 程序中输入指令时，显示状态的地方</p>
</li>
</ul>
<p>下面的列表部分大部分都见过了，下面再列出含义：</p>
<ul>
<li><strong>PID</strong>：进程 <strong>ID</strong></li>
<li><strong>USER</strong>：进程所属使用者</li>
<li><strong>PR</strong>（<strong>priority</strong>）：进程优先执行顺序，越小越早被执行</li>
<li><strong>NI</strong>（<strong>nice</strong>）：与 <strong>PR</strong> 有关，越小越早被执行</li>
<li><code>%CPU</code>：<strong>CPU</strong> 使用率</li>
<li><code>%MEM</code>：内存使用率</li>
<li><code>TIME+</code> ：<strong>CPU</strong> 使用时间的累加</li>
</ul>
<p><strong>top</strong> 预设使用 <strong>CPU</strong> 使用率 <code>%CPU</code>作为排序的重点，如果想要使用内存使用率排序，可以按下 <strong>M</strong> 键，要离开按下 <strong>q</strong> 键</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将 top 的信息进行 2 次，然后将结果输出到 /tmp/top.txt</span></span><br><span class="line">[root@study ~]<span class="comment"># top -b -n 2 &gt; /tmp/top.txt</span></span><br><span class="line"><span class="comment"># 这里的结果就是，写入了执行 2 次的结果信息。是追加写入的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于只有一屏显示，所以当你要观察的进程没有排序到最前面的时候，还可以单独观察该线程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：我们自己的 bash PID 可以由 $$ 变量取得，使用 top 持续观察该 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># top -d 2 -p $$</span></span><br><span class="line">top - 22:53:55 up  1:39,  2 users,  load average: 0.59, 0.28, 0.32</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.1 us,  4.6 sy,  0.0 ni, 92.8 id,  0.0 wa,  0.0 hi,  0.5 si,  0.0 st</span><br><span class="line">KiB Mem :  1190952 total,   435612 free,   392456 used,   362884 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.   642448 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                    </span><br><span class="line"> 9051 root      20   0  116472   3172   1780 S  0.0  0.3   0:00.04 bash </span><br></pre></td></tr></table></figure>

<p>就只显示着一个程序给你看了，还可以修改 <strong>NI</strong> 值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 4：上题的 NI 指是 0，把它修改成 10</span></span><br><span class="line"><span class="comment"># 在上题的 top 画面中按下 r 键出现下面的提示</span></span><br><span class="line">PID to renice [default pid = 9051] 5501 		<span class="comment"># 输入要修改的 PID</span></span><br><span class="line">Renice PID 9051 to value 10		<span class="comment"># 输入要修改的 nice 值</span></span><br><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">9051 root      30  10  116472   3172   1780 S  0.0  0.3   0:00.04 bash </span><br><span class="line"></span><br><span class="line"><span class="comment"># 会发现 NI 值已经修改了</span></span><br></pre></td></tr></table></figure>

<h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pstree [-AIU] [-up]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：各进程之间的连接以  ASCII 字符来连接</span><br><span class="line">	-U：各进程之间的连接以万国码的字符来连接。在某些终端机接口下可能会有错误</span><br><span class="line">	-p：并同时列出每个 process 的 PID</span><br><span class="line">	-u：并同时列出每个 process 的所属账户名称</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上所有的进程树的相关性</span></span><br><span class="line">[root@study ~]<span class="comment"># pstree -A</span></span><br><span class="line">systemd-+-ModemManager---2*[&#123;ModemManager&#125;]				<span class="comment"># ModenManager 与其子进程</span></span><br><span class="line">        |-NetworkManager---2*[&#123;NetworkManager&#125;]</span><br><span class="line">        |-2*[abrt-watch-log]</span><br><span class="line">        |-abrtd</span><br><span class="line">        |-accounts-daemon---2*[&#123;accounts-daemon&#125;]</span><br><span class="line">        ....</span><br><span class="line">        |-sshd---sshd---sshd-+-bash---su---bash---pstree		<span class="comment"># 我们指令执行的相依性</span></span><br><span class="line">        |                    |-bash---top</span><br><span class="line">        |                    |-bash</span><br><span class="line">        |                    `-sftp-server</span><br><span class="line"><span class="comment"># 看下这个相依性，差不多就是登陆之后，在 su 切换账户之后，执行的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：同时显示出 PID 与 users</span></span><br><span class="line">[root@study ~]<span class="comment"># pstree -Aup</span></span><br><span class="line">systemd(1)-+-ModemManager(871)-+-&#123;ModemManager&#125;(881)</span><br><span class="line">           |                   `-&#123;ModemManager&#125;(891)</span><br><span class="line">           |-NetworkManager(935)-+-&#123;NetworkManager&#125;(941)</span><br><span class="line">           |                     `-&#123;NetworkManager&#125;(945)</span><br><span class="line">           |-abrt-watch-log(856)</span><br><span class="line">           |-sshd(1269)---sshd(7771)---sshd(7779,mrcode)-+-bash(3239)---sleep(3263)</span><br><span class="line">           |                                             |-bash(7780)---su(8985,root)---bash(9051)---pstree(3264)</span><br><span class="line">           |                                             |-bash(7835)---top(8102)</span><br><span class="line">           |                                             `-sftp-server(7833)</span><br><span class="line"><span class="comment"># 可以看到 sshd 登录的 PID 是 7779 ，用 mrcode 账户登录的。后续用 su 切换到了 root，这个时候新开了一个进程 7780 的 bash</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用 <strong>pstree</strong> 来找相关性，同时使用 <code>-A</code> 来让连线不断开。默认的 <strong>Unicode</strong> 连线有可能出现断线，整体画面显示错位的问题</p>
<p>由 <strong>pstree</strong> 的输出我们可以知道，所有的进程都是依附在 <strong>systemd</strong> 程序下面的，<strong>systemd</strong> 的进程 <strong>ID</strong> 是 1 号，是 <strong>LInux</strong> 核心主动运行的第一个程序</p>
<p>之前讲解遇到僵尸进程为啥要重启，因为 <strong>systemd</strong> 要重启，那么就相当于重启系统了</p>
<h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>进程相互管理是通过一个信号（<strong>signal</strong>）去告知该进程你要它做什么。信号可以通过 <code>man 7 signal</code> 查阅，主要信号代号与名称含义如下：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>SIGHUP</strong></td>
<td>启动被终止的进程，可让该 PID 重新读取自己的配置文件，类似重新启动</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>SIGINT</strong></td>
<td>相当于用键盘输入 ctrl + c 来终端一个进程的运行</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>SIGKILL</strong></td>
<td>强制终端一个进程的运行，如果该进程进行到一半，那么尚未完成的部分可能会有半成品产生，类似 vim 会有 .filename.swp 保留下来</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td><strong>SIGTERM</strong></td>
<td>以正常的结束进程来终止该进程。由于是正常的终止，所以后续的动作会将他完成。不过，如果该进程已经发生问题，就无法使用正常的方法终止时，输入该 signal 也是没有用的</td>
</tr>
<tr>
<td><strong>19</strong></td>
<td><strong>SIGSTOP</strong></td>
<td>相当于用键盘输入 ctrl-z 来暂停一个进行的运行</td>
</tr>
</tbody></table>
<p>可以使用 <strong>kill</strong> 或 <strong>killall</strong> 把信号传递给进程</p>
<h3 id="kill-signal-PID"><a href="#kill-signal-PID" class="headerlink" title="kill -signal PID"></a>kill -signal PID</h3><p><strong>kill</strong> 可以将信号传递给某个工作（**%jobnumber<strong>） 或某个 **PID</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：以 ps 找出 rsyslogd 这个进程 PID 后，再使用 kill 传递信号，让它可以重新读取配置文件</span></span><br><span class="line">[root@study ~]<span class="comment"># ps aux | grep &#x27;rsyslogd&#x27;</span></span><br><span class="line">root      1273  0.0  0.3 215672  3728 ?        Ssl  21:15   0:00 /usr/sbin/rsyslogd -n</span><br><span class="line">root     18876  0.0  0.0   9096   928 pts/0    RN+  23:30   0:00 grep --color=auto rsyslogd</span><br><span class="line">[root@study ~]<span class="comment"># ps aux | grep &#x27;rsyslogd&#x27; | grep -v &#x27;grep&#x27;</span></span><br><span class="line">root      1273  0.0  0.3 215672  3728 ?        Ssl  21:15   0:00 /usr/sbin/rsyslogd -n</span><br><span class="line">[root@study ~]<span class="comment"># ps aux | grep &#x27;rsyslogd&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">1273</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终的指令是如下的</span></span><br><span class="line">[root@study ~]<span class="comment"># kill -SIGHUP $(ps aux | grep &#x27;rsyslogd&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;) </span></span><br><span class="line"><span class="comment"># 是否重启无法看通过看进程来知道，可以看日志</span></span><br><span class="line">[root@study ~]<span class="comment"># tail -5 /var/log/messages</span></span><br><span class="line">Mar  9 23:20:01 study systemd: Removed slice User Slice of root.</span><br><span class="line">Mar  9 23:30:01 study systemd: Created slice User Slice of root.</span><br><span class="line">Mar  9 23:30:01 study systemd: Started Session 19 of user root.</span><br><span class="line">Mar  9 23:30:01 study systemd: Removed slice User Slice of root.</span><br><span class="line">Mar  9 23:35:20 study rsyslogd: [origin software=<span class="string">&quot;rsyslogd&quot;</span> swVersion=<span class="string">&quot;8.24.0-38.el7&quot;</span> x-pid=<span class="string">&quot;1273&quot;</span> x-info=<span class="string">&quot;http://www.rsyslog.com&quot;</span>] rsyslogd was HUPed</span><br><span class="line"><span class="comment"># 看上面，rsyslogd was HUPed 的字样，表示有重新启动</span></span><br></pre></td></tr></table></figure>

<p>还记得可以查询到登录的 <strong>bash</strong> 的进程吗？也可以使用 <strong>kill -9</strong> 来删除，就意味着，该登陆者被踢下线了</p>
<h3 id="killall-signal-指令名称"><a href="#killall-signal-指令名称" class="headerlink" title="killall -signal 指令名称"></a>killall -signal 指令名称</h3><p>由于 <strong>kill</strong> 后面必须要加上 <strong>PID</strong> （或是 <strong>job number</strong>），所以通常需要配合 <strong>ps</strong>、<strong>pstree</strong> 等指令，还可以使用另外一种方法来达到效果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">killall [-iIe] [<span class="built_in">command</span> name]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-i：interactive ，交互式的，若需要删除时，会出现提示字符给用户确认</span><br><span class="line">	-e：exact，后面接的 <span class="built_in">command</span> name 要一致，但整个完整的指令不能超过 15 个字符</span><br><span class="line">	-I：指令名称（可能含参数）忽略大小写</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：给予 rsyslogd 指令启动的 PID 一个 SIGHUP 的信号</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -1 rsyslogd</span></span><br><span class="line"><span class="comment"># 这里 -1  是信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：强制终止所有以 httpd 启动的进程（其实当前没有该进程启动）</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -9 httpd         </span></span><br><span class="line">httpd: no process found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：依次询问每个 bash 程序是否需要被终止</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -i -9 bash</span></span><br><span class="line">Signal bash(7780) ? (y/N) n</span><br><span class="line">Signal bash(7835) ? (y/N) n</span><br><span class="line">Signal bash(9051) ? (y/N) n</span><br><span class="line">bash: no process found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里都选择了 n，所以提示没有进程被找到，按下 y 就杀掉了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于程序的执行顺序"><a href="#关于程序的执行顺序" class="headerlink" title="关于程序的执行顺序"></a>关于程序的执行顺序</h3><p><strong>CPU</strong> 是切换着执行进程，那么谁先执行？这个就要看进程的优先级 <strong>priority</strong> 与 <strong>CPU</strong> 排程（每个进程被 <strong>CPU</strong> 运行的演算规则）</p>
<h4 id="Priority-与-Nice-值"><a href="#Priority-与-Nice-值" class="headerlink" title="Priority 与 Nice 值"></a>Priority 与 Nice 值</h4><p><strong>CPU</strong> 一秒钟可以运行多达数 <strong>G</strong> 的微指令次数，通过核心的 <strong>CPU</strong> 调度可以让各程序 被 <strong>CPU</strong> 所切换运行， 因此每个程序在一秒钟内或多或少都会被 <strong>CPU</strong> 执行部分的指令码。</p>
<p>如果进程不分优先级顺序的话，那么就是排队执行，如果中间有个进程执行时间很长，其他进程就要等待很长时间</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/linux-queue-priority.jpg"></p>
<p>如上图，有了优先级之后，高优先级的可用被执行两次，低优先级则执行 <strong>1</strong> 次，但是上图仅是示意图，并非高优先级的就会执行两次，<strong>Linux</strong> 给予进程一个优先执行序（<strong>priority PRI</strong>），<strong>PRI</strong> 值越低优先级越高，不过该值是由核心动态调整的，用户无法直接调整 <strong>PRI</strong> 值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 R     0  7183  9051  0  90  10 - 12406 -      pts/0    00:00:00 ps</span><br><span class="line">4 S     0  8985  7780  0  80   0 - 57972 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0  9051  8985  0  90  10 - 29118 do_wai pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure>

<p>由于 <strong>PRI</strong> 是动态调整的，用户无法干涉，但是可以通过 Nice 值来达到一定的优先级调整，<strong>Nice</strong> 就是上述中的 <strong>NI</strong> 值，一般来说 <strong>PRI</strong> 与 <strong>NI</strong> 的相关性 <code>PRI(new)=PRI(old)+nice</code>，虽然可以调整 <strong>nice</strong> 的值，由于 <strong>PRI</strong> 是动态调整的，所以不包装调整完之后，最终的 <strong>PRI</strong> 就会变低，优先级变高的</p>
<p>此外，必须要注意，<strong>nice</strong> 值范围</p>
<ul>
<li><strong>nice</strong> 值范围是 <strong>-20~19</strong></li>
<li><strong>root</strong> 可随意调整自己或他人进程的 <strong>Nice</strong> 值，且范围为 <strong>-20~19</strong></li>
<li>一般使用者仅可调整自己进程的 <strong>Nice</strong> 值，且范围仅为 <strong>0~19</strong>（避免一般用户抢占系统资源）</li>
<li>一般使用者仅可将 <strong>nice</strong> 值越调越高；比如 <strong>nice</strong> 为 <strong>5</strong>，则未来仅能调整到大于 <strong>5</strong>；</li>
</ul>
<p>那么调整 <strong>nice</strong> 值有两种方式：</p>
<ul>
<li>一开始执行程序就立即给予一个特定的 <strong>nice</strong> 值：用 <strong>nice</strong> 指令</li>
<li>调整某个已经存在的 <strong>PID</strong> 的 <strong>nice</strong> 值：用 <strong>renice</strong> 指令</li>
</ul>
<h4 id="nice：新执行的指令给予新的-nice-值"><a href="#nice：新执行的指令给予新的-nice-值" class="headerlink" title="nice：新执行的指令给予新的 nice 值"></a>nice：新执行的指令给予新的 nice 值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nice [-n 数字] <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">-n：后面接一个数值，数值范围 -20~19</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1： 用 root 给一个 nice 值为 -5，用于执行 vim，并观察该进程</span></span><br><span class="line">[root@study ~]<span class="comment"># nice -n -5 vim &amp;</span></span><br><span class="line">[2] 30185</span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  8985  7780  0  80   0 - 57972 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0  9051  8985  0  90  10 - 29118 do_wai pts/0    00:00:00 bash</span><br><span class="line">4 T     0 30185  9051  0  85   5 - 10791 do_sig pts/0    00:00:00 vim</span><br><span class="line">0 R     0 30652  9051  0  90  10 - 12407 -      pts/0    00:00:00 ps</span><br><span class="line"><span class="comment"># 原本的 bash PRI 为 90，所以 vim 预设为 90，这里给予 nice -5，所以最终 PRI 变成了 85</span></span><br><span class="line"><span class="comment"># 要注意：不一定正好变成 85，因为会动态调整的</span></span><br></pre></td></tr></table></figure>

<p>那么通常什么时候需要将 <strong>nice</strong> 值调大呢？比如：系统的背景工作中，某些比较不重要的进程进行时，比如备份工作，由于备份工作相当耗系统资源，这个时候就可以将备份的指令 <strong>nice</strong> 值调大一些，可以使系统的资源分配更公平</p>
<h4 id="renice：已存在进程的-nice-重新调整"><a href="#renice：已存在进程的-nice-重新调整" class="headerlink" title="renice：已存在进程的 nice 重新调整"></a>renice：已存在进程的 nice 重新调整</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renice [number] PID</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：找出自己的 bash PID ,并将该 PID 的 nice 调整到 -5</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  3426  3372  0  80   0 - 58072 do_wai pts/1    00:00:00 su</span><br><span class="line">4 S     0  3443  3426  0  80   0 - 29059 do_wai pts/1    00:00:00 bash</span><br><span class="line">0 R     0  3487  3443  0  80   0 - 12407 -      pts/1    00:00:00 ps</span><br><span class="line">[root@study ~]<span class="comment"># renice -5 3443</span></span><br><span class="line">3443 (process ID) old priority 0, new priority -5</span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  3426  3372  0  80   0 - 58072 do_wai pts/1    00:00:00 su</span><br><span class="line">4 S     0  3443  3426  0  75  -5 - 29059 do_wai pts/1    00:00:00 bash</span><br><span class="line">0 R     0  3493  3443  0  75  -5 - 12407 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure>

<h3 id="系统资源的观察"><a href="#系统资源的观察" class="headerlink" title="系统资源的观察"></a>系统资源的观察</h3><p><strong>top</strong> 可以看到很多系统的资源使用情况，还有其他工具</p>
<h3 id="free：观察内存使用情况"><a href="#free：观察内存使用情况" class="headerlink" title="free：观察内存使用情况"></a>free：观察内存使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-b：单位参数；默认是用 k，其他单位对应 bytes、Mbytes、Kbytes、Gbytes</span><br><span class="line">	-t: 输出的最终结果，显示物理内存与 swap 的总量</span><br><span class="line">	-s：可以让系统每几秒输出一次，不间断输出；</span><br><span class="line">	-c：与 -s 同时处理，让 free 列出几次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：显示目前系统的内存容量</span></span><br><span class="line">[root@study ~]<span class="comment"># free -m</span></span><br><span class="line"><span class="comment">#			  总内存		已使用		   剩余							  可用</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7631         713        6374          15         542        6671</span><br><span class="line">Swap:          4095           0        4095</span><br></pre></td></tr></table></figure>

<p><code>shared buff/cache</code> 是缓冲区等使用量，<code>available</code> 是可用容量，当系统忙碌时，可以被释放掉，给系统使用</p>
<p>由于系统会把空闲内存拿来做缓冲区之用，所以你系统没有那么繁忙的时候，也会显示内存被用的多的原因，这个是正常的，需要注意的是 <strong>swap</strong>，<strong>swap</strong> 最好不要被使用，而且不要使用超过 <strong>20%</strong> 以上，因为 <strong>swap</strong> 被使用，那么很有可能是物理内存不够用了</p>
<h3 id="uname：查询系统与核心相关信息"><a href="#uname：查询系统与核心相关信息" class="headerlink" title="uname：查询系统与核心相关信息"></a>uname：查询系统与核心相关信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uname [-asrmpi]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：所有系统相关的，都列出来</span><br><span class="line">	-s：系统核心名称</span><br><span class="line">	-r：核心的版本</span><br><span class="line">	-m：本系统的硬件名称，例如 i686 或 x86_64</span><br><span class="line">	-p：CPU 的类型，与 -m 类似</span><br><span class="line">	-i：硬件的平台（ix86）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：输出系统的基本信息</span></span><br><span class="line">[root@study ~]<span class="comment"># uname -a </span></span><br><span class="line"><span class="comment"># 核心名称   主机名			核心版本			  核心建立日期 与 硬件平台</span></span><br><span class="line">Linux study.centos.mrcode 3.10.0-1062.el7.x86_64 <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="uptime：观察系统启动时间与工作负载"><a href="#uptime：观察系统启动时间与工作负载" class="headerlink" title="uptime：观察系统启动时间与工作负载"></a>uptime：观察系统启动时间与工作负载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># uptime </span></span><br><span class="line"> 17:31:46 up 43 min,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line"> <span class="comment"># 当前时间	 已开机多久  几个用户登录	平均负载：1、5、15 分钟的平均负载</span></span><br></pre></td></tr></table></figure>

<h3 id="netstat：追踪网络或插槽文件"><a href="#netstat：追踪网络或插槽文件" class="headerlink" title="netstat：追踪网络或插槽文件"></a>netstat：追踪网络或插槽文件</h3><p>该指令常被用在网络的监控方面；<strong>netstat</strong> 基本上的输出分为两大部分：网络与系统自己的进程相关性部分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -[atunlp]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：将目前系统上所有的联机、监听、Socket 数据都列出来</span><br><span class="line">	-t：列出 tcp 网络封包的数据</span><br><span class="line">	-u：列出 udp 网络封包的数据</span><br><span class="line">	-n：不以进程的服务名称，以端口号来显示</span><br><span class="line">	-l：列出目前正在网络监听的（listen）的服务</span><br><span class="line">	-p：列出该网络服务的进程 PID</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上已经建立的网络连接与 unix socket 状态</span></span><br><span class="line">[root@study ~]<span class="comment"># netstat </span></span><br><span class="line">Active Internet connections (w/o servers)		<span class="comment"># 与网络相关部分</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0     36 study.centos.mrcode:ssh 192.168.4.170:50821     ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)	<span class="comment"># 与本机的进程自己的相关性（非网络）</span></span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    12644    /run/systemd/shutdownd</span><br><span class="line">unix  3      [ ]         DGRAM                    7618     /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    7620     /run/systemd/cgroups-agent</span><br><span class="line">unix  5      [ ]         DGRAM                    7634     /run/systemd/journal/socket</span><br></pre></td></tr></table></figure>

<p>网络联机部分：</p>
<ul>
<li><strong>Proto</strong>：网络封包协议，主要分为 <strong>TCP</strong> 与 <strong>UDP</strong>。</li>
<li><strong>Recv-Q</strong>：非由用户程序连接到此 <strong>socket</strong> 的复制和总 <strong>Bytes</strong> 数</li>
<li><strong>Send-Q</strong>：非由远程主机传送过来的 <strong>acknowledged</strong> 总 <strong>Bytes</strong> 数</li>
<li><strong>Local Address</strong>：本地端的 <strong>Ip:port</strong></li>
<li><strong>Foreign Address</strong>：远程主机的 <strong>IP:port</strong></li>
<li><strong>State</strong>：联机状态，主要有建立（<strong>ESTABLISED</strong>）、监听（<strong>LISTEN</strong>）</li>
</ul>
<p>上面有一条数据，含义是：<strong>192.168.4.170:50821</strong> 通过 <strong>TCP</strong> 封包联机到本机端的 <strong>study.centos.mrcode:ssh</strong>，状态是 <strong>ESTABLISHED</strong>；至于更多的知识点这里不深入，在服务器篇讲解</p>
<p>除了网络上的联机之外，<strong>Linux</strong> 系统上的进程是可以接收不同进程所发来的信息，通过 <strong>socket file</strong> 可以在两个进程之间通信。比如 <strong>X Window</strong> 这种需要通过网络连接的软件，新版 <strong>distribution</strong> 以 <strong>socket</strong> 来进行窗口接口的联机沟通。上表中 <strong>socket file</strong> 的输出字段含义为：</p>
<ul>
<li><strong>Proto</strong>：一般是 <strong>unix</strong></li>
<li><strong>RefCnt</strong>：连接到此 <strong>socket</strong> 的进程数量</li>
<li><strong>Flags</strong>：联机旗标</li>
<li><strong>Type</strong>：<strong>socket</strong> 存取的类型。主要有 <strong>STREAM</strong>：确认联机、<strong>DGRAM</strong>：不需确认 两种</li>
<li><strong>State</strong>：若为 <strong>CONNECTED</strong> 表示多个进程之间已经联机建立</li>
<li><strong>PATH</strong>：连接到此 <strong>socket</strong> 的相关程序路径，或则是相关数据输出的路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：找出目前系统上已在监听的网络联机与 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># netstat -tulnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1380/cupsd          </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1579/master         </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      3765/sshd: mrcode@p </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1973/dnsmasq        </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1379/sshd           </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      1380/cupsd          </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1579/master         </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN      3765/sshd: mrcode@p </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1379/sshd           </span><br><span class="line">udp        0      0 192.168.122.1:53        0.0.0.0:*                           1973/dnsmasq        </span><br><span class="line">udp        0      0 0.0.0.0:67              0.0.0.0:*                           1973/dnsmasq        </span><br><span class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                           1/systemd           </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                           938/chronyd         </span><br><span class="line">udp        0      0 0.0.0.0:41378           0.0.0.0:*                           953/avahi-daemon: r </span><br><span class="line">udp        0      0 0.0.0.0:672             0.0.0.0:*                           927/rpcbind         </span><br><span class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                           953/avahi-daemon: r </span><br><span class="line">udp6       0      0 :::111                  :::*                                1/systemd           </span><br><span class="line">udp6       0      0 ::1:323                 :::*                                938/chronyd         </span><br><span class="line">udp6       0      0 :::672                  :::*                                927/rpcbind</span><br><span class="line"><span class="comment"># 最后一个字段是 PID 与进程的指令名称</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：将上述的 0 0.0.0.0:41378 网络服务关闭</span></span><br><span class="line">[root@study ~]<span class="comment"># kill -9 953</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -9 avahi-daemon</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>对于非正常的关闭服务方法就用暴力的 kill -9，正常的关闭方式，下个章节讲解</p>
<h3 id="dmesg：分析核心产生的信息"><a href="#dmesg：分析核心产生的信息" class="headerlink" title="dmesg：分析核心产生的信息"></a>dmesg：分析核心产生的信息</h3><p>系统在开机的时候，核心会去侦测系统的硬件，那么硬件的检测信息由于开机过程中要么一闪而过，要么没有显示在屏幕上，可以使用 <strong>dmesg</strong> 来查看</p>
<p>从系统开机起，核心产生的信息都会记录到内存中，通过 <strong>dmesg</strong> 可以查询到，信息过多时可以通过 <strong>more</strong> 指令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：输出所有的核心开机时的信息</span></span><br><span class="line">[root@study ~]<span class="comment"># dmesg | more</span></span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuset</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpu</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuacct</span><br><span class="line">[    0.000000] Linux version 3.10.0-1062.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat </span><br><span class="line">4.8.5-36) (GCC) ) <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019</span></span><br><span class="line">[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spect</span><br><span class="line">re_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=zh_CN.UTF-8</span><br><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved</span><br><span class="line">--More--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：找到硬盘相关信息</span></span><br><span class="line">[root@study ~]<span class="comment"># dmesg | grep -i &#x27;sda&#x27;</span></span><br><span class="line">[    2.632630] sd 2:0:0:0: [sda] 85491712 512-byte logical blocks: (43.7 GB/40.7 GiB)</span><br><span class="line">[    2.632651] sd 2:0:0:0: [sda] Write Protect is off</span><br><span class="line">[    2.632653] sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00</span><br><span class="line">[    2.632662] sd 2:0:0:0: [sda] Write cache: enabled, <span class="built_in">read</span> cache: enabled, doesn<span class="string">&#x27;t support DPO or FUA</span></span><br><span class="line"><span class="string">[    2.643988]  sda: sda1 sda2 sda3 sda4 sda5 sda6 sda7 sda8</span></span><br><span class="line"><span class="string">[    2.644394] sd 2:0:0:0: [sda] Attached SCSI disk</span></span><br><span class="line"><span class="string">[    4.616881] XFS (sda2): Mounting V5 Filesystem</span></span><br><span class="line"><span class="string">[    4.636376] XFS (sda2): Ending clean mount</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="vmstat：侦测系统资源变化"><a href="#vmstat：侦测系统资源变化" class="headerlink" title="vmstat：侦测系统资源变化"></a>vmstat：侦测系统资源变化</h3><p><strong>vmstat</strong> 可以侦测 <strong>CPU</strong>、内存、磁盘输入输出状态等信息。比如可以了解一台繁忙的系统到底是哪个环节最耗时间，可以使用 <strong>vmstat</strong> 分析看看，常见选项与参数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vmstat [-a] [延迟 [总计侦测次数]]		<span class="comment"># CPU/内存等信息</span></span><br><span class="line">vmstat [-fs]										 <span class="comment"># 内存相关</span></span><br><span class="line">vmstat [-S 单位]									<span class="comment"># 设置显示数据的单位</span></span><br><span class="line">vmstat [-d]											 <span class="comment"># 与磁盘有关</span></span><br><span class="line">vmstat [-p 分区槽]								 <span class="comment"># 与磁盘有关</span></span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：使用 inactive/active（是否活跃）取代 buffer/cache 的内存输出信息</span><br><span class="line">	-f：开机到目前为止，系统复制（fork）的进程数</span><br><span class="line">	-s：将一些事件（开机到目前为止）导致的内存变化情况列表说明</span><br><span class="line">	-S：后面可以接单位，例如 k、M 等</span><br><span class="line">	-d：列出磁盘的读写总量统计表</span><br><span class="line">	-p：后面列出分区槽，可显示该分区槽的读写总量统计表</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：统计目前主机 CPU 状态，每秒一次，总共 3 次</span></span><br><span class="line">[root@study ~]<span class="comment"># vmstat 1 3</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 2  0      0 450296   2116 346828    0    0   501    36  181  320  2  3 95  0  0</span><br><span class="line"> 0  0      0 450156   2116 346860    0    0     0     0  163  223  2  3 95  0  0</span><br><span class="line"> 0  0      0 450156   2116 346860    0    0     0     0  273  388  3  5 91  0  0</span><br></pre></td></tr></table></figure>

<p>还可以不限制次数，就一直统计字段说明如下：</p>
<ul>
<li><p><strong>procs</strong>：进程</p>
<ul>
<li><strong>r</strong>：等待运行中的进程数量</li>
<li><strong>b</strong>：不可被唤醒的进程数量</li>
</ul>
<p><strong>rb</strong> 越多表示系统越繁忙。因为系统太忙，导致很多进程无法被执行或一直在等待而无法被唤醒</p>
</li>
<li><p><strong>memory</strong>：内存</p>
<ul>
<li><strong>swpd</strong>：虚拟内存被使用的容量</li>
<li><strong>free</strong>：未被使用的内容容量</li>
<li><strong>buff</strong>：用于缓冲存储器</li>
<li><strong>cache</strong>：用于高速缓存</li>
</ul>
<p>这里的含义与 <strong>free</strong> 指令一致</p>
</li>
<li><p><strong>swap</strong>：内存交换空间</p>
<ul>
<li><strong>si</strong>：由磁盘中将进程取出的量</li>
<li><strong>so</strong>：由于内存不足而将没用到的进程写入到磁盘的 swap 的容量</li>
</ul>
<p>如果 <strong>si</strong>、<strong>so</strong> 的数值太大，表示内存的数据常常得在磁盘与主存储器之间传来传去，效率很低</p>
</li>
<li><p><strong>io</strong>：磁盘读写</p>
<ul>
<li><strong>bi</strong>：由磁盘读入的区块数量</li>
<li><strong>bo</strong>：写入到磁盘去的区块数量</li>
</ul>
<p>如果这部分数值越高，代表系统的 <strong>I/O</strong> 非常忙碌</p>
</li>
<li><p><strong>system</strong>：系统</p>
<ul>
<li><strong>in</strong>：每秒被中断的进程次数</li>
<li><strong>cs</strong>：每秒钟进行的事件切换次数</li>
</ul>
<p>这两个值越大，代表系统与接口设备的沟通非常频繁，接口设备包括磁盘、网卡、时钟等</p>
</li>
<li><p><strong>CPU</strong>：</p>
<ul>
<li><strong>us</strong>：非核心层的 <strong>CPU</strong> 使用状态</li>
<li><strong>sy</strong>：核心层所使用的 <strong>CPU</strong> 状态</li>
<li><strong>id</strong>：闲置的状态</li>
<li><strong>wa</strong>：等待 <strong>I/O</strong> 所耗费的 <strong>CPU</strong> 状态</li>
<li><strong>st</strong>：被虚拟机（<strong>virtual machine</strong>）所盗用的 <strong>CPU</strong> 使用状态（<strong>2.6.11</strong>）</li>
</ul>
</li>
</ul>
<p>练习机上看不到忙碌的数据，如果有一天，你的系统非常忙碌，可以使用该指令来分析是哪里出现了问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：系统上面所有的磁盘读写状态</span></span><br><span class="line">[root@study ~]<span class="comment"># vmstat -d</span></span><br><span class="line">disk- ------------reads------------ ------------writes----------- -----IO------</span><br><span class="line">       total merged sectors      ms  total merged sectors      ms    cur    sec</span><br><span class="line">sda     7640      1  709893    6377   2486    351   54323    8478      0      5</span><br><span class="line">sdb      116      0    5384      27      0      0       0       0      0      0</span><br><span class="line">sr0        0      0       0       0      0      0       0       0      0      0</span><br><span class="line">dm-0    7072      0  661717    6054   2611      0   45902   10871      0      5</span><br><span class="line">dm-1      88      0    4408      21      0      0       0       0      0      0</span><br><span class="line">dm-2     103      0   10834      58     23      0    4325      56      0      0</span><br></pre></td></tr></table></figure>

<p>至于上面的字段含义，可以通过 <strong>man vmstat</strong> 查阅</p>
<h2 id="特殊文件与进程"><a href="#特殊文件与进程" class="headerlink" title="特殊文件与进程"></a>特殊文件与进程</h2><p>在第 6 章中讲到特殊权限 <strong>SUID</strong>、<strong>SGID</strong>、<strong>SBIT</strong>，那么这些权限对于你的 <strong>进程</strong> 是如何影响的？进程用到的系统资源，比如硬盘资源，使用 <strong>umount</strong> 硬盘时，出现提示 「<strong>device is busy</strong>」的提示是怎么回事？</p>
<h3 id="具有-SUID、SGID-权限的指令执行状态"><a href="#具有-SUID、SGID-权限的指令执行状态" class="headerlink" title="具有 SUID、SGID 权限的指令执行状态"></a>具有 SUID、SGID 权限的指令执行状态</h3><p><strong>SUID</strong> 的权限与进程的相关性非常大，<strong>SUID</strong> 的程序是如何被一般用户执行，具有什么特色？</p>
<ul>
<li><strong>SUID</strong> 权限仅对二进制程序（<strong>binary program</strong>）有效</li>
<li>执行者对于该进程需要具有 <strong>x</strong> 的可执行权限</li>
<li>本权限仅在执行程序的过程中有效（<strong>run-time</strong>）</li>
<li>执行者将具有该程序拥有者（<strong>owner</strong>）的权限</li>
</ul>
<p>所以，整个 <strong>SUID</strong> 的权限会生效是由于<strong>具有该权限的程序被触发</strong>，一个进程表示一个程序的运行，所以执行者可以具有程序拥有者的权限就是在该程序变成进程的时候</p>
<p>比如执行了 <strong>passwd</strong> 后你就具有 <strong>root</strong> 的权限？是因为你再触发 <strong>passwd</strong> 后，会取得一个新的进程与 <strong>PID</strong>，该 <strong>PID</strong> 产生时通过 <strong>SUID</strong> 来给予该 <strong>PID</strong> 特殊的权限设置</p>
<p>下面使用 <strong>mrcode</strong> 登录系统并执行 <strong>passwd</strong> 后，通过工作控制来理解</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">export</span> LANG=C</span><br><span class="line">[mrcode@study ~]$ passwd</span><br><span class="line">Changing password <span class="keyword">for</span> user mrcode.</span><br><span class="line">Changing password <span class="keyword">for</span> mrcode.</span><br><span class="line">(current) UNIX password: 		<span class="comment"># 这里按下 ctrl + z，并按下 enter 键</span></span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 passwd</span><br><span class="line">[mrcode@study ~]$ pstree -uA</span><br><span class="line">systemd-+-ModemManager---2*[&#123;ModemManager&#125;]</span><br><span class="line">        |-sshd-+-sshd---sshd(mrcode)-+-bash---su(root)---bash</span><br><span class="line">        |      |                     |-bash---top</span><br><span class="line">        |      |                     |-bash---sleep</span><br><span class="line">        |      |                     `-sftp-server</span><br><span class="line">        |      `-sshd---sshd(mrcode)-+-bash-+-passwd(root)</span><br><span class="line">        |                            |      `-pstree</span><br><span class="line">        |                            |-bash---top</span><br><span class="line">        |                            |-bash---sleep</span><br><span class="line">        |                            `-sftp-server</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的进程来看，在执行 <strong>passwd</strong> 前是 <strong>mrcode</strong> 的权限，<strong>passwd</strong> 则是 <strong>root</strong> 权限，<strong>passwd</strong> 是由 <strong>bash</strong> 衍生出来的，但是权限不一样，这样一来就能理解为什么不同程序所产生的权限不同了，是由于 <strong>SUID</strong> 程序运行过程中产生的进程的关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">type</span> passwd</span><br><span class="line">passwd is hashed (/usr/bin/passwd)</span><br><span class="line">[mrcode@study ~]$ ll /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27856 Aug  9  2019 /usr/bin/passwd</span><br><span class="line"><span class="comment">#可以看到，的确该指令也有 s 权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以通过以下指令查找 SUID/SGID 的文件</span></span><br><span class="line">find / -perm /6000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="proc-代表的意义"><a href="#proc-代表的意义" class="headerlink" title="/proc/* 代表的意义"></a><code>/proc/*</code> 代表的意义</h3><p>进程在内存中，内存中的数据都是写入到 <code>/proc/*</code> 目录下的，可以直接查看该目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ ll /proc/</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x.  9 root           root                         0 Mar 15 20:13 1</span><br><span class="line">dr-xr-xr-x.  9 root           root                         0 Mar 15 20:13 10</span><br><span class="line">dr-xr-xr-x.  9 root           root                         0 Mar 15 20:13 11</span><br><span class="line">...</span><br><span class="line">dr-xr-xr-x.  2 root           root                         0 Mar 15 20:54 sysvipc</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 timer_list</span><br><span class="line">-rw-r--r--.  1 root           root                         0 Mar 15 20:54 timer_stats</span><br><span class="line">dr-xr-xr-x.  4 root           root                         0 Mar 15 20:54 tty</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:16 uptime</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 version</span><br><span class="line">-r--------.  1 root           root                         0 Mar 15 20:54 vmallocinfo</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 vmstat</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 zoneinfo</span><br></pre></td></tr></table></figure>

<p>基本上，目前主机上面的各个进程的 PID 都是以目录的形态存在该目录中。如第 <strong>1</strong> 行的 <strong>PID</strong> 为 <strong>1</strong>，它是开机执行的第一个程序 <strong>systemd</strong>，该 <strong>PID</strong> 的所有相关信息都写入在 <code>/proc/1/*</code> 下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ll /proc/1</span></span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x. 2 root root 0 Mar 15 20:48 attr</span><br><span class="line">-rw-r--r--. 1 root root 0 Mar 15 20:53 autogroup</span><br><span class="line">-r--------. 1 root root 0 Mar 15 20:53 auxv</span><br><span class="line">-r--r--r--. 1 root root 0 Mar 15 20:13 cgroup</span><br><span class="line">-r--r--r--. 1 root root 0 Mar 15 20:13 cmdline			<span class="comment"># 指令串</span></span><br><span class="line">-r--------. 1 root root 0 Mar 15 20:13 environ			<span class="comment"># 一些环节变量</span></span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 15 20:13 exe -&gt; /usr/lib/systemd/systemd</span><br></pre></td></tr></table></figure>

<p>里面数据很多，可以查询下 <strong>cmdline</strong> 的内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># cat /proc/1/cmdline</span></span><br><span class="line">/usr/lib/systemd/systemd--switched-root--system--deserialize22</span><br></pre></td></tr></table></figure>

<p>上面指令显示了是以什么参数启动的 <strong>systemd</strong> 指令，这个是针对 <strong>PID</strong> 有关的内容，下面是针对整个 <strong>Linux</strong> 系统相关的参数，对应与 <strong>/proc</strong> 目录下的文件如下</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>/proc/cmdline</code></td>
<td>加载 kernel 时所下达的相关指令与参数，查询此文件，可了解指令是如何启动的</td>
</tr>
<tr>
<td><code>/proc/cpuinfo</code></td>
<td>本机的 CPU 相关信息，包含频率、类型与计算功能等</td>
</tr>
<tr>
<td><code>/proc/devices</code></td>
<td>系统各个主要装置的主要装置代号，与 mknod 有关</td>
</tr>
<tr>
<td><code>/proc/filesystems</code></td>
<td>目前系统已经加载的文件系统</td>
</tr>
<tr>
<td><code>/proc/interrupts</code></td>
<td>目前系统上 IRQ 分配状态</td>
</tr>
<tr>
<td><code>/proc/ioports</code></td>
<td>目前系统上各个装置所配置的 I/O 地址</td>
</tr>
<tr>
<td><code>/proc/kcore</code></td>
<td>内存大小，很大？不要读取该文件</td>
</tr>
<tr>
<td><code>/proc/loadavg</code></td>
<td>top 以及 uptime 的三个平均数值就是记录在这里的</td>
</tr>
<tr>
<td><code>/proc/meminfo</code></td>
<td>使用 free 列出的内存信息，在这里也可以查询到</td>
</tr>
<tr>
<td><code>/proc/modules</code></td>
<td>目前我们 LInux 已经加载的模块列表，可以看成是驱动程序</td>
</tr>
<tr>
<td><code>/proc/mounts</code></td>
<td>系统已经挂载的数据，就是用 mount 指令查询出来的数据</td>
</tr>
<tr>
<td><code>/proc/swaps</code></td>
<td>系统挂载的内存在哪里？使用掉的 partition 记录在这里</td>
</tr>
<tr>
<td><code>/proc/partitions</code></td>
<td>使用 fsidk -l 会出现目前所有的 partition，在该文件中也有记录</td>
</tr>
<tr>
<td><code>/proc/uptime</code></td>
<td>使用 uptime 出现的信息</td>
</tr>
<tr>
<td><code>/proc/version</code></td>
<td>核心的版本，使用 uname -a 显示的信息</td>
</tr>
<tr>
<td><code>/proc/bus/*</code></td>
<td>一些总线的装置，还有 USB 的装置也记录在这里</td>
</tr>
</tbody></table>
<p>这些文件内容建议使用 <strong>cat</strong> 去查阅看看，不必深入了解，如果未来你要写某些工具软件，那么这个目录下相关文件可能会对你有点帮助</p>
<h3 id="查询已开启文件或已执行进程开启之文件"><a href="#查询已开启文件或已执行进程开启之文件" class="headerlink" title="查询已开启文件或已执行进程开启之文件"></a>查询已开启文件或已执行进程开启之文件</h3><p>还有一些与进程相关的指令可以参考与应用</p>
<h4 id="fuser：由文件（或文件系统）找出正在使用该文件的进程"><a href="#fuser：由文件（或文件系统）找出正在使用该文件的进程" class="headerlink" title="fuser：由文件（或文件系统）找出正在使用该文件的进程"></a>fuser：由文件（或文件系统）找出正在使用该文件的进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fuser [-umv] [-k [i] [signal]] file/dir</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-u：除了进程的 PID 之外，同时列出该进程的拥有者</span><br><span class="line">	-m：后面接的文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效</span><br><span class="line">	-v：可以列出每个文件与进程还有指令的完整相关性</span><br><span class="line">	-k：找出使用该文件/目录的 PID，并试图以 SIGKILL 这个信号给予该 PID</span><br><span class="line">	-i：必须与 -k 配合使用，在删除 PID 之前会先询问使用者</span><br><span class="line">	-signal：例如 -1 -15 等，若不加的话，预设是 -9：SIGKILL</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：找出目前所在目录的使用 PID、所属账户、权限</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -uv .</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/root:               root       2604 ..c.. (root)bash</span><br></pre></td></tr></table></figure>

<p>有一个进程属于 <strong>root</strong>，而 <strong>ACCESS</strong> 项则略为复杂一点：</p>
<ul>
<li><strong>c</strong>：此进程在当前的目录下（非次目录）</li>
<li><strong>e</strong>：可被触发为执行状态</li>
<li><strong>f</strong>：是一个被开启的文件</li>
<li><strong>r</strong>：代表顶层目录（<strong>root directory</strong>）</li>
<li><strong>F</strong>：该文件被开启了，不过在等待回应中</li>
<li><strong>m</strong>：可能为分享的动态函数库</li>
</ul>
<p>如果想知道某个文件系统下又多少进程正在占用该文件系统时，可以使用 <code>-m</code> 选项</p>
<p>下面做几个简单测试，包括实体文件系统挂载与 /proc 虚拟文件系统的内容，看看有多少的进程对这些挂载点或其他目录的使用状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：找到所有使用到 /proc 这个文件系统的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -uv /proc/</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/proc:               root     kernel mount (root)/proc</span><br><span class="line">                     rtkit       834 .rc.. (rtkit)rtkit-daemon</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># fuser -muv /proc/</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/proc:               root     kernel mount (root)/proc</span><br><span class="line">                     root          1 f.... (root)systemd</span><br><span class="line">                     root        589 f.... (root)systemd-journal</span><br><span class="line">                     rtkit       834 .rc.. (rtkit)rtkit-daemon</span><br><span class="line">                     root        844 f.... (root)udisksd</span><br><span class="line">                     root        929 f.... (root)NetworkManager</span><br><span class="line">                     root       1277 F.... (root)libvirtd</span><br><span class="line">                     root       1638 F.... (root)X</span><br><span class="line">                     gdm        1693 f.... (gdm)gnome-shell</span><br><span class="line">                     root       1759 f.... (root)packagekitd</span><br><span class="line">                     mrcode     2280 f.... (mrcode)top</span><br><span class="line">                     mrcode     7722 f.... (mrcode)top</span><br><span class="line"><span class="comment"># 这就能看到有几个程序在对该目录进行存取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：找到所有使用到 /home 这个文件系统的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># echo $$</span></span><br><span class="line">2604				<span class="comment"># 先确定下自己的 bash 的进程 PID</span></span><br><span class="line">[root@study ~]<span class="comment">#  cd /home/</span></span><br><span class="line">[root@study home]<span class="comment"># fuser -muv .</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/home:               root     kernel mount (root)/home</span><br><span class="line">                     mrcode     1346 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     1371 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     1378 ..c.. (mrcode)sleep</span><br><span class="line">                     mrcode     1399 ..c.. (mrcode)sleep</span><br><span class="line">                     mrcode     1958 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     1991 ..c.. (mrcode)sftp-server</span><br><span class="line">                     mrcode     1992 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     2280 ..c.. (mrcode)top</span><br><span class="line">                     root       2604 ..c.. (root)bash			<span class="comment"># 看这里，自己的 bash 存在列表中</span></span><br><span class="line">                     mrcode     7294 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     7358 ..c.. (mrcode)sftp-server</span><br><span class="line">                     mrcode     7362 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     7722 ..c.. (mrcode)top</span><br><span class="line">                     root       8884 ..c.. (root)passwd</span><br><span class="line"></span><br><span class="line">[root@study home]<span class="comment"># cd ~</span></span><br><span class="line">[root@study ~]<span class="comment"># umount /home/</span></span><br><span class="line">umount: /home: target is busy.</span><br><span class="line">        (In some cases useful info about processes that use</span><br><span class="line">         the device is found by lsof(8) or fuser(1))</span><br><span class="line"><span class="comment"># 通过 fuser 知道有好几个进程在该目录下运行，可以通过如下的方式一个一个删除</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -mki /home/</span></span><br><span class="line">/home:                7294c  7358c  7362c  7722c  8884c 19238c 19289c 19291c 19601c 25650c 25674c 25685c 25746c</span><br><span class="line">Kill process 7294 ? (y/N)</span><br><span class="line"><span class="comment"># 以上指令有一个问题，颇为棘手，就是很容易杀到自己 bash 的进程，那么久直接把直接踢掉了</span></span><br><span class="line"><span class="comment"># 不知道这个这么排除掉是出方便的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面可以针对整个文件系统，其实也可以针对单一文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 4：找到 /run 下属于 FIFO 类型的文件，并找出存取该文件的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># find /run -type p</span></span><br><span class="line">/run/dmeventd-client</span><br><span class="line">/run/dmeventd-server</span><br><span class="line">/run/systemd/inhibit/7.ref</span><br><span class="line">/run/systemd/inhibit/6.ref</span><br><span class="line">/run/systemd/inhibit/5.ref</span><br><span class="line">/run/systemd/inhibit/4.ref</span><br><span class="line">/run/systemd/inhibit/2.ref</span><br><span class="line">/run/systemd/inhibit/1.ref</span><br><span class="line">/run/systemd/sessions/13.ref</span><br><span class="line">/run/systemd/sessions/5.ref</span><br><span class="line">/run/systemd/sessions/c1.ref</span><br><span class="line">/run/systemd/initctl/fifo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随便找到文件测试</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -uv /run/systemd/sessions/c1.ref</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/run/systemd/sessions/c1.ref:</span><br><span class="line">                     root        842 f.... (root)systemd-logind</span><br><span class="line">                     root       1649 F.... (root)gdm-session-wor</span><br><span class="line"><span class="comment"># 通常系统的 FIFO 文件都会放置到 /run 下，通过该方式来追踪该文件存取的 process</span></span><br><span class="line"><span class="comment"># 同样也能够看到系统有多忙碌（进程多当然就忙碌）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>fuser</strong> 的重点是可以让我们了解到某个文件系统或文件目前正在被哪些进程所使用</p>
<h4 id="lsof：列出被进程所开启的文件名"><a href="#lsof：列出被进程所开启的文件名" class="headerlink" title="lsof：列出被进程所开启的文件名"></a>lsof：列出被进程所开启的文件名</h4><p>fuser 是通过文件或则装置名去找使用它的进程，而 lsof 则是通过某个进程去找它开启或使用的文件与装置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lsof [-aUu] [+d]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：多想数据需要同时成立才显示出结果时</span><br><span class="line">	-U：仅列出 Unix like 系统的 socket 文件类型</span><br><span class="line">	-u：后面接 username，列出该使用者相关进程所开启的文件</span><br><span class="line">	+d：后面接目录，找出某个目录下已经被开启的文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上所有已经被开启的文件与装置</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof</span></span><br><span class="line">libvirtd   1277 1318           root  mem       REG              253,0     53848    9645351 /usr/lib64/libavahi-common.so.3.5.3</span><br><span class="line">libvirtd   1277 1318           root  mem       REG              253,0    155784    8569818 /usr/lib64/libselinux.so.1</span><br><span class="line">libvirtd   1277 1318           root  mem       REG              253,0     37056    8655202 /usr/lib64/libacl.so.1.1.0</span><br><span class="line"><span class="comment"># 文件很多很多，直接刷屏了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：仅列出关于 root 的所有进程开启的 socket 文件</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof -u root -a -U</span></span><br><span class="line">COMMAND     PID USER   FD   TYPE             DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">systemd       1 root   12u  unix 0xffff8922437ed800      0t0  12513 /run/systemd/private</span><br><span class="line">systemd       1 root   13u  unix 0xffff892243dc2c00      0t0  25917 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   15u  unix 0xffff892243e71800      0t0  25941 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   16u  unix 0xffff892243e8fc00      0t0  25942 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   17u  unix 0xffff892243e6ec00      0t0  26002 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   18u  unix 0xffff892243e6dc00      0t0  26009 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   23u  unix 0xffff89224359a800      0t0   7620 /run/systemd/notify</span><br><span class="line"><span class="comment"># 注意 -a 参数，分别执行 lsof -u root 及 lsof -U 信息都不同</span></span><br><span class="line"><span class="comment"># -a 取他们的交集结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：列出目前系统上所有被启动的周边装置</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof +d /dev/</span></span><br><span class="line">COMMAND     PID           USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">systemd       1           root    0u   CHR                1,3      0t0 5342 /dev/null</span><br><span class="line">systemd       1           root    1u   CHR                1,3      0t0 5342 /dev/null</span><br><span class="line">systemd       1           root    2u   CHR                1,3      0t0 5342 /dev/null</span><br><span class="line">systemd       1           root   27r   CHR             10,235      0t0 7250 /dev/autofs</span><br><span class="line">systemd       1           root   30u  unix 0xffff8922436ce000      0t0 7645 /dev/<span class="built_in">log</span></span><br><span class="line">kdevtmpfs    13           root  cwd    DIR                0,5     3340    3 /dev</span><br><span class="line"><span class="comment"># 因为都在目录中，所以搜索目录即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 4：列出 root 的 bash 程序开启的文件</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof -u root | grep bash</span></span><br><span class="line">ksmtuned    921 root  txt       REG              253,0    964600     309027 /usr/bin/bash</span><br><span class="line">bash      20030 root  cwd       DIR              253,0      4096   25165889 /root</span><br><span class="line">bash      20030 root  rtd       DIR              253,0       251         64 /</span><br><span class="line">bash      20030 root  txt       REG              253,0    964600     309027 /usr/bin/bash</span><br><span class="line">bash      20030 root  mem       REG              253,0 106075056     309022 /usr/lib/locale/locale-archive</span><br><span class="line">bash      20030 root  mem       REG              253,0     61624    8548289 /usr/lib64/libnss_files-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0   2156160    8532847 /usr/lib64/libc-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0     19288    8532853 /usr/lib64/libdl-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0    174576    8548350 /usr/lib64/libtinfo.so.5.9</span><br><span class="line">bash      20030 root  mem       REG              253,0    163400    8532840 /usr/lib64/ld-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0     26254   16946906 /usr/lib64/gconv/gconv-modules.cache</span><br><span class="line">bash      20030 root    0u      CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash      20030 root    1u      CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash      20030 root    2u      CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash      20030 root  255u      CHR              136,0       0t0          3 /dev/pts/0</span><br></pre></td></tr></table></figure>

<p>可以通过范例 4 找出某个进程是否有启用哪些信息</p>
<h3 id="pidof：找出某个正在运行的程序的-PID"><a href="#pidof：找出某个正在运行的程序的-PID" class="headerlink" title="pidof：找出某个正在运行的程序的 PID"></a>pidof：找出某个正在运行的程序的 PID</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pidof [-sx] program_name</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-s：仅列出一个 PID 而不列出所有的 PID</span><br><span class="line">	-x：同时列出该程序可能的 PPID 那个进程的 PID</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上 systemd 以及 rsyslogd 这两个程序的 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># pidof systemd rsyslogd</span></span><br><span class="line">1 1265</span><br><span class="line"><span class="comment"># 结果显示的是两个 PID</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>pidof</strong> 指令较简单，可配合 <strong>pas aux</strong> 与正则表示法，就可以很轻易的找到你想要的进程内容了。如果要找的是 <strong>bash</strong>，那就 <strong>pidof bash</strong> ，就列出一堆 <strong>PID</strong> 号码了</p>
<h2 id="SELinux-初探"><a href="#SELinux-初探" class="headerlink" title="SELinux 初探"></a>SELinux 初探</h2><p><strong>CentOS 5.x</strong> 之后，<strong>SELinux</strong> 已经是个非常完备的核心模块了，尤其是 <strong>CentOS</strong> 提供了很多管理 <strong>SELinux</strong> 的指令与机制，因此在整理架构上面是单纯且容易操作管理的，所以在没有自行开发网络服务软件以及使用其他第三方协力软件的情况下，也就是全部使用 <strong>CentOS</strong> 官方提供的软件来使用我们服务器的情况下，建议不要关闭 <strong>SELinux</strong></p>
<h3 id="什么是-SELinux"><a href="#什么是-SELinux" class="headerlink" title="什么是 SELinux"></a>什么是 SELinux</h3><p><strong>Security Enhanced Linux</strong> 的缩写 <strong>SELinux</strong>，字面意思是安全强化的 <strong>LInux</strong>。至于强化的是哪个部分？下面来了解下</p>
<h3 id="当初设计的目标：避免资源的误用"><a href="#当初设计的目标：避免资源的误用" class="headerlink" title="当初设计的目标：避免资源的误用"></a>当初设计的目标：避免资源的误用</h3><p><strong>SELinux</strong> 是由美国国家安全局（<strong>NSA</strong>）开发的，需求来源于内部员工资源误用导致系统出现问题；</p>
<p>资源误用：将一个 <code>/var/www/html/</code> 目录权限设置成 <strong>777</strong>，那么当启动 <strong>www</strong> 服务器软件，就意味着这个软件触发的进程拥有对该目录写入的权限，只要通过该进程服务器对目录大量写入，就会导致系统硬盘资源被爆破</p>
<p><strong>SELinux</strong> 是在进行进程、文件等西部权限设置依据的一个核心模块，由于启动网络服务的也是进程，因此刚好也能够控制网络服务是否能存取系统资源的一道关卡</p>
<p>在讲解 <strong>SELinux</strong> 之前，先回顾一下之前讲到的：系统文件权限与用户之间的关系</p>
<h3 id="传统的文件权限与账户关系：自主式访问控制-DAC"><a href="#传统的文件权限与账户关系：自主式访问控制-DAC" class="headerlink" title="传统的文件权限与账户关系：自主式访问控制 DAC"></a>传统的文件权限与账户关系：自主式访问控制 DAC</h3><p>第 <strong>13</strong> 章中讲到：系统账户主要分为系统管理员（<strong>root</strong>）与一般用户，他们能否使用系统上的文件资源与 <strong>rwx</strong> 权限设置有关。（各种权限设置对 <strong>root</strong> 无效）。当某个进程想要对文件进行存取时，系统会根据该进程的拥有者、群组，并比对文件的权限，若通过权限检查，就可以存取该文件</p>
<p>这种存取文件的方式被称为 <strong>自主式访问控制 Discretionary Access Controller 简称 DAC</strong>，基本上就是依据进程的拥有者与文件资源的 <strong>rwx</strong> 权限来决定有无存取的能力。<strong>DAC</strong> 有如下困扰：</p>
<ul>
<li><strong>root</strong> 具有最高的权限：只要取得属于 <strong>root</strong> 的进程，那么就很危险</li>
<li>使用者可以取得进程来变更文件资源的访问权限：如果将某个目录权限不小心设置为 <strong>777</strong>，由于对任何人的权限会变成 <strong>rwx</strong>，因此该目录就会被任何人所任意存取</li>
</ul>
<h3 id="以政策规则规定特定进程读取特定文件：委任式访问控制-MAC"><a href="#以政策规则规定特定进程读取特定文件：委任式访问控制-MAC" class="headerlink" title="以政策规则规定特定进程读取特定文件：委任式访问控制 MAC"></a>以政策规则规定特定进程读取特定文件：委任式访问控制 MAC</h3><p>为了避免 <strong>DAC</strong> 的困扰，<strong>SELinux</strong> 导入了委任式访问控制 <strong>Mandatory Access Control</strong> 简称 <strong>MAC</strong></p>
<p><strong>MAC</strong> 可以针对特定的进程与特定的文件资源来进行权限的控制。即使你是 <strong>root</strong>，那么在使用不同的进程时，你所能取得的权限并不一定是 <strong>root</strong>，而需要看当时该进程的设置。如此一来针对控制的「主体」变成了「进程」而不是使用者，但是真个系统进程很多、文件也很多，一项一项控制太麻烦，所以 <strong>SELinux</strong> 也提供一些预设的政策 <strong>Policy</strong> ，并在该政策内提供多个规则 <strong>rule</strong>，让你可以选择是否启用该控制规则</p>
<p>在该种模式下，进程能够活动的空变小了。比如：<strong>www</strong> 服务器软件达成进程为 <strong>httpd</strong> 这个程序，默认情况下， <strong>httpd</strong> 仅能在 <code>/var/www</code> 目录下存取文件，如果 httpd 进程要去其他目录存储数据时，除了规则设置要开放外，目标目录也要设置成 <strong>httpd</strong> 可读取的模式 <strong>type</strong> 才行，限制非常多，所以，即使 <strong>httpd</strong> 这个进程被黑客取得了控制权限，它也无权限浏览其他的目录文件</p>
<p>简单说，针对 <strong>Apache</strong> 这个 <strong>www</strong> 网络服务使用 <strong>DAC</strong> 或 <strong>MAC</strong> 的结果来说，两者的关系可用下图来说明</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/selinux.png"></p>
<p>传统的进程与文件的 <strong>rwx</strong> 方式，在这中间增加了 <strong>SELinux</strong>  安全性本文 <em>规则</em> ，通过了这些规则之后，才和传统的进程与文件的 <strong>rwx</strong> 方式一致。</p>
<p>笔者理解为是通过拦截器的方式，出台了 <strong>SELinux</strong> ，前面通过 <strong>SElinux</strong> 拦截细化权限，符合要求的再去到传统的方式，这样一来就对传统的加强了。</p>
<h3 id="安全性本文-Security-Context"><a href="#安全性本文-Security-Context" class="headerlink" title="安全性本文 Security Context"></a>安全性本文 Security Context</h3><p><strong>CentOS 7.x</strong> 的 <strong>target</strong> 政策提供了非常多的规则，只需要如何开启关闭某项规则即可。</p>
<p>安全性本文则非常麻烦，可能需要自行配置它，比如你常常设置文件的 <strong>rwx</strong> 权限，那么这个安全性本文就类似，可以看成是 <strong>SELinux</strong> 中的 <strong>rwx</strong></p>
<p>安全性本文存在于主体进程中与目标文件资源中，物理位置是放在文件的 <strong>inode</strong> 中，因此主体进程想要读取目标文件资源时，同样需要读取 <strong>inode</strong>，这就可以对比安全性本文一级 <strong>rwx</strong> 等权限是否正确了。</p>
<p>观察安全性本文可使用 <code>ls -Z</code> ，但是前提是需要启动 <strong>SELinux</strong> 才行，下个小节会介绍如何启动 <strong>SELinux</strong>，这里先介绍知识点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ls -Z</span></span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 accountadd.sh</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 accountadd.txt</span><br><span class="line">-rwxr--r--+ root root unconfined_u:object_r:admin_home_t:s0 acl_test1</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 addaccount2.sh</span><br><span class="line">-rw-------. root root system_u:object_r:admin_home_t:s0 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--. root root system_u:object_r:admin_home_t:s0 initial-setup-ks.cfg</span><br><span class="line"><span class="comment"># 上述字段很长的那一栏就是安全性本文了</span></span><br></pre></td></tr></table></figure>

<p>安全性本文主要用冒号分割为三个字段，含义如下：</p>
<ul>
<li><p><strong>identify</strong>：身份</p>
<p>相当于账户方面的身份识别，常见有几下几种类型</p>
<ul>
<li><p><strong>unconfined_u</strong>：不受限的用户</p>
<p>该文件来自不受限的进程所产生的，一般来说，可以使用可登录账号来取得 <strong>bash</strong>，预设的 <strong>bash</strong> 环境是不受 <strong>SELinux</strong> 管制的，因为 <strong>bash</strong> 并不是什么特别的网络服务，因此在该 <strong>bash</strong> 进程所产生的文件，其身份识别大多就是该类型了</p>
</li>
<li><p><strong>system_u</strong>：系统用户</p>
<p>基本上，如果是系统会软件本身所提供的文件，大多就是该类型，如果是用户通过 <strong>bash</strong> 自己建立的文件，大多则是不受限的 <strong>unconfined_u</strong> 身份，如果是网络服务所产生的文件，或则是系统服务运行过程中所产生的文件，则大部分是 <strong>system_u</strong></p>
</li>
</ul>
</li>
<li><p><strong>role</strong>：角色</p>
<p>通过该字段，可以知道这个资料是属于进程、文件资源还是代表使用者，一般的角色有：</p>
<ul>
<li><strong>object_r</strong>：代表的是文件或目录等文件资源</li>
<li><strong>system_r</strong>：代表的是进程，不过一般使用者也会被指定为 system_r</li>
</ul>
</li>
<li><p><strong>type</strong>：类型，最重要</p>
<p>在预设的 <strong>targeted</strong> 政策中， <strong>identify</strong> 与 <strong>role</strong> 字段基本上是不重要的，而 <strong>type</strong> 是最重要的，基本上，一个主体进程能不能读取到这个文件资源，与类型字段有关，而类型字段在文件与进程的定义不相同：</p>
<ul>
<li><strong>type</strong>：在文件资源（<strong>object</strong>）上面称为类型（<strong>type</strong>）</li>
<li><strong>domain</strong>：在主体进程（<strong>subject</strong>）则称为领域（<strong>domain</strong>）</li>
</ul>
<p><strong>domain</strong> 需要与 <strong>type</strong> 搭配，则该进程才能够顺利的读取文件资源</p>
</li>
</ul>
<h3 id="进程与文件-SELinux-type-字段的相关性"><a href="#进程与文件-SELinux-type-字段的相关性" class="headerlink" title="进程与文件 SELinux type 字段的相关性"></a>进程与文件 SELinux type 字段的相关性</h3><p>通过身份识别与角色字段的定义，我们可以大概某个进程所代表的意义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察下系统 进程的 SELinux 相关信息</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -eZ</span></span><br><span class="line">LABEL                             PID TTY          TIME CMD</span><br><span class="line">system_u:system_r:init_t:s0         1 ?        00:00:01 systemd</span><br><span class="line">system_u:system_r:kernel_t:s0       2 ?        00:00:00 kthreadd</span><br><span class="line">system_u:system_r:kernel_t:s0       4 ?        00:00:00 kworker/0:0H</span><br><span class="line">system_u:system_r:kernel_t:s0       5 ?        00:00:00 kworker/u2:0</span><br><span class="line">...</span><br><span class="line">system_u:system_r:sshd_t:s0-s0:c0.c1023 2344 ? 00:00:00 sshd</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2350 ? 00:00:00 sshd</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2353 pts/0 00:00:00 bash</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2415 pts/0 00:00:00 su</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2424 pts/0 00:00:00 bash</span><br><span class="line">system_u:system_r:kernel_t:s0    2726 ?        00:00:00 kworker/u2:2</span><br><span class="line">system_u:system_r:kernel_t:s0    2778 ?        00:00:00 kworker/0:1</span><br><span class="line">system_u:system_r:kernel_t:s0    2836 ?        00:00:00 kworker/0:3</span><br><span class="line">system_u:system_r:kernel_t:s0    2877 ?        00:00:00 kworker/0:0</span><br><span class="line">system_u:system_r:ksmtuned_t:s0  2885 ?        00:00:00 sleep</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2886 pts/0 00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本上进程主要分为两大类，</span></span><br><span class="line"><span class="comment"># 一种是系统有受限的 system_u:system_r，</span></span><br><span class="line"><span class="comment"># 另一种可能是用户自己的，比较不受限的进程（通常是本机用户自己执行的程序 ） unconfined_u:unconfined_r</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2424 pts/0 00:00:00 bash</span></span><br><span class="line"><span class="comment"># 比如上面这个进程，就是我们自己执行命令所在的 bash</span></span><br></pre></td></tr></table></figure>

<p>基本上，这些对于资料在 <strong>targeted</strong> 政策下的对应对下</p>
<table>
<thead>
<tr>
<th>身份识别</th>
<th>角色</th>
<th>对应在 targeted 的意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>unconfined_u</strong></td>
<td><strong>unconfined_r</strong></td>
<td>一般可登陆使用者的进程，比较没有受限的进程。大多数都是用户已经顺利登陆系统（不论是网络还是本机登陆来取得可用的 <strong>shell</strong>）后，所用来操作系统的进程，如 <strong>bash x window</strong> 相关富安居等</td>
</tr>
<tr>
<td><strong>system_u</strong></td>
<td><strong>system_r</strong></td>
<td>由于为系统账户，因此是非交谈式的系统运行进程，大多数的系统进程均是这种类型</td>
</tr>
</tbody></table>
<p>如上所述，在预设的 <strong>target</strong> 政策下，最重要的是 <strong>type</strong> 字段，主体与目标之间是否具有可读写的权限，与进程的 <strong>domain</strong> 与文件的 <strong>type</strong> 有关。这两者的关系可以使用 <strong>crond</strong> 以及他的配置文件来说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先看看 crond 这个进程的安全本文内容</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -eZ | grep cron</span></span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 1398 ? 00:00:00 atd</span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 1400 ? 00:00:00 crond</span><br><span class="line"><span class="comment"># 这个安全本文的类型名称为 crond_t 格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 看看 /usr/ssbin/crond 、 /etc/cron.d、/etc/cron.d 文件的安全本文内容</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Zd /usr/sbin/crond /etc/crontab /etc/cron.d</span></span><br><span class="line">drwxr-xr-x. root root system_u:object_r:system_cron_spool_t:s0 /etc/cron.d</span><br><span class="line">-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 /etc/crontab</span><br><span class="line">-rwxr-xr-x. root root system_u:object_r:crond_exec_t:s0 /usr/sbin/crond</span><br></pre></td></tr></table></figure>

<p>执行 <code>/usr/ssbin/crond</code> 后，该程序编程的进程 <strong>domain</strong> 类似是 <strong>crond_t</strong>，它能够读取的配置文件是 <code>system_cron_spool_t</code> 类型。因此无论 <code>/etc/crontab</code>与 <code>/etc/cron.d</code> 以及 <code>/var/spool/cron</code> 都会是相关的 SELinux 类型（<code>/var/spool/cron</code> 为 <code>user_cron_spool_t</code> 类型）。下面图示说明</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/crond-domain.png" style="zoom:67%;" />

<ol>
<li><strong>crond</strong> 执行后，具有 <strong>crond_exec_t</strong> 类型</li>
<li>该文件类型会造成主体进程 <strong>Subject</strong> 具有 <strong>crond</strong> 这个领域 <strong>domain</strong>，政策针对这个领域有许多规则，其中就包括可以读取的目标资源类型</li>
<li>由于 <strong>crond domain</strong> 被设置为可以读取 <strong>system_cron_spool_t</strong> 类型的目标文件 <strong>object</strong>，因此你的配置文件放到 <code>/etc/cron.d/</code> 目录下，就能够被 <strong>crond</strong> 进程读取了</li>
<li>但是最终能不能读到正确的资料，还需要看传统的 <strong>rwx</strong> 是否符合 <strong>Linux</strong> 的权限规范</li>
</ol>
<p>下面来测试上述说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 假设你因为不熟悉的缘故，因此是在 root 家目录建立一个如下的 cron 设置</span></span><br><span class="line">[root@study ~]<span class="comment"># vim checktime</span></span><br><span class="line">10 * * * * root sleep 60s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 发现文件放错目录了，又不想要保留副本，因此使用 mv 移动到正确的目录</span></span><br><span class="line">[root@study ~]<span class="comment"># mv checktime /etc/cron.d/</span></span><br><span class="line">[root@study ~]<span class="comment"># ll /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. 1 root root 26 Mar 17 13:12 /etc/cron.d/checktime</span><br><span class="line"><span class="comment"># 权限是 644，任何进程都可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 强制重新启动 crond，然后查看登录日志</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart crond          </span></span><br><span class="line">[root@study ~]<span class="comment"># tail /var/log/cron</span></span><br><span class="line">Mar 17 13:01:01 study run-parts(/etc/cron.hourly)[3889]: finished mcelog.cron</span><br><span class="line">Mar 17 13:10:01 study CROND[3972]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">Mar 17 13:14:01 study crond[1400]: ((null)) Unauthorized SELinux context=system_u:system_r:system_cronjob_t:s0-s0:c0.c1023 file_context=unconfined_u:object_r:admin_home_t:s0 (/etc/cron.d/checktime)</span><br><span class="line">Mar 17 13:14:01 study crond[1400]: (root) FAILED (loading cron table)</span><br><span class="line">Mar 17 13:15:08 study crond[1400]: (CRON) INFO (Shutting down)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 13% <span class="keyword">if</span> used.)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: ((null)) Unauthorized SELinux context=system_u:system_r:system_cronjob_t:s0-s0:c0.c1023 file_context=unconfined_u:object_r:admin_home_t:s0 (/etc/cron.d/checktime)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (root) FAILED (loading cron table)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (CRON) INFO (running with inotify support)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (CRON) INFO (@reboot <span class="built_in">jobs</span> will be run at computer<span class="string">&#x27;s startup.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 上述日志中有 Unauthorized 的信息，表示有错误，因为原本的安全本文与文件的实际安全本文无法搭配的缘故，</span></span><br><span class="line"><span class="string"># 信息还列出了 SELinux context 与 file_context 的信息，表示的确不匹配</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="SELinux-三种模式的启动、关闭与观察"><a href="#SELinux-三种模式的启动、关闭与观察" class="headerlink" title="SELinux 三种模式的启动、关闭与观察"></a>SELinux 三种模式的启动、关闭与观察</h3><p>并非所有的 <strong>Linux distribution</strong> 都支持 <strong>SELinux</strong>，<strong>CentOS 7.x</strong> 本身就有支持 <strong>SELinux</strong>，所以你不需要自行编译 <strong>SELinux</strong> 到你的 <strong>Linux</strong> 核心中。目前 <strong>SELinux</strong> 是否启动有三种模式：</p>
<ul>
<li><strong>enforcing</strong>：强制模式，表示 <strong>SELinux</strong> 运行中，且已经正确的开始限制 <strong>domain/type</strong> 了</li>
<li><strong>permissive</strong>：宽容模式，表示 <strong>SELinux</strong> 运行中，不过仅有警告进行并不会实际限制 <strong>domain/type</strong> 的存取。这种模式可以用来 <strong>debug SELinux</strong> 的配置</li>
<li><strong>disabled：SELinux</strong> 关闭中</li>
</ul>
<p>三种模式的示意图如下：</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/selinux-three-pattern.png" style="zoom:50%;" />

<p>注意：并非有所的进程都受 <strong>SELinux</strong> 的管控，注意是有 <strong>受限的进程主体</strong>，可以通过 <code>ps -eZ</code> 来观察该进程是否有受限（<strong>confined</strong>）。下面来观察 <strong>crond</strong> 与 <strong>bash</strong> 程序是否有被限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ps -eZ | grep -E &#x27;cron|bash&#x27;</span></span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 1398 ? 00:00:00 atd</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2353 pts/0 00:00:00 bash</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2424 pts/0 00:00:00 bash</span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 4073 ? 00:00:00 crond</span><br></pre></td></tr></table></figure>

<p>因为目前 <strong>target</strong> 这个政策下，只有第 <strong>3</strong> 个字段 <strong>type</strong> 会有影响，因此可以看到 <strong>crond</strong> 有 <code>crond_t</code> 类型，是受限的，而 <strong>bash</strong> 是 <code>unconfined_t</code> 类型，是不受限的，也就是说 <strong>bash</strong> 不会经过上图的流程，而直接去判定 <strong>rwx</strong></p>
<p>可以通过以下方式获取当前的 <strong>SELinux</strong> 模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># getenforce </span></span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>

<p>查询当前 <strong>SELinux</strong> 的政策（<strong>Policy</strong>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sestatus [-vb]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-v：检查 /etc/sestatus.conf 内的文件与进程的安全性本文内容</span><br><span class="line">	-b：将目前政策的规则布尔值列出，即某些规则 rule 是否要启动（0/1）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前 SELinux 使用的哪个政策 Policy</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sestatus   		</span></span><br><span class="line">SELinux status:                 enabled				<span class="comment"># SELinux 是否启动</span></span><br><span class="line">SELinuxfs mount:                /sys/fs/selinux		<span class="comment"># SELinux 的相关文件数据挂载点</span></span><br><span class="line">SELinux root directory:         /etc/selinux		<span class="comment"># SELinux 的根目录所在</span></span><br><span class="line">Loaded policy name:             targeted			<span class="comment"># 当前的政策</span></span><br><span class="line">Current mode:                   enforcing			<span class="comment"># 当前模式</span></span><br><span class="line">Mode from config file:          enforcing			<span class="comment"># 目前配置文件内规范的 SELinux 模式</span></span><br><span class="line">Policy MLS status:              enabled				<span class="comment"># 是否含有 MLS 的模式机制</span></span><br><span class="line">Policy deny_unknown status:     allowed				<span class="comment"># 是否预设抵挡未知的主体进程</span></span><br><span class="line">Max kernel policy version:      31</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述信息科知道，<strong>SELinux</strong> 目前的政策是 <strong>targeted</strong> ，可通过如下方式修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># vim /etc/selinux/config </span></span><br><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=enforcing		 	<span class="comment"># 可选择为上述 3 个</span></span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of three values:</span></span><br><span class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected. </span></span><br><span class="line"><span class="comment">#     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted		<span class="comment"># 可选值为上述 3 个</span></span><br></pre></td></tr></table></figure>

<h3 id="SElinux-的启动与关闭"><a href="#SElinux-的启动与关闭" class="headerlink" title="SElinux 的启动与关闭"></a>SElinux 的启动与关闭</h3><p>由于 <strong>SElinux</strong> 是整合到核心中去的，因此修改上述配置文件之后，需要重新启动。</p>
<p>注意：如果从 <strong>disable</strong> 转到启动 <strong>SELinux</strong> 的模式时，由于系统必须要针对文件写入安全性本文信息，因此开机过程需要耗费不少时间等待重新写入 <strong>SELinux</strong> 安全性本文（有时也称为<strong>SELinux Label</strong>），而且在写完之后还需要重新启动一次，启动成功之后，再使用 <code>getenforce 和 sestatus</code> 来观察是否有成功启动到 <strong>Enforcing</strong> 模式</p>
<p>如果当前已经是 <strong>Enforcing</strong> 模式，可能由于一些设置问题大道至 <strong>SELinux</strong> 让某些服务无法正常的运行，此时可将模式修改为宽容模式（<strong>permissive</strong>），让 <strong>SELinux</strong> 只发出警告信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenforce [0|1]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	0：转成 permissive 宽容模式</span><br><span class="line">	1：转成 Enforcing 强制模式</span><br><span class="line">注意：无法在 Disabled 模式下进程模式的切换	</span><br></pre></td></tr></table></figure>

<p>某些时候从 <strong>Disabled</strong> 换成 <strong>Enforcing</strong> 之后，有部分服务可能无法顺利启动，可能会报错 <code>/lib/xxx</code> 数据没有权限读取的错误信息。这大多数是由于重新写入 <strong>Selinux type</strong>（<strong>Relabel</strong>）出错的原因，使用 <strong>Permissive</strong> 模式就没有该错误。最简单的办法是在 <strong>Permissive</strong> 模式下使用指令 <code>restorecon -Rv /</code> 重新还原所有 <strong>SELinux</strong> 的类型。</p>
<h3 id="SELinux-政策内的规则管理"><a href="#SELinux-政策内的规则管理" class="headerlink" title="SELinux 政策内的规则管理"></a>SELinux 政策内的规则管理</h3><h4 id="SELinux-各个规则的布尔值查询：getsebool"><a href="#SELinux-各个规则的布尔值查询：getsebool" class="headerlink" title="SELinux 各个规则的布尔值查询：getsebool"></a>SELinux 各个规则的布尔值查询：getsebool</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getsebool [-a] [规则名称]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：列出目前系统上所有 SELinux 规则的布尔值为开启或关闭（on/off）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询所有的布尔值设置</span></span><br><span class="line">[root@study ~]<span class="comment"># getsebool -a</span></span><br><span class="line">abrt_anon_write --&gt; off</span><br><span class="line">abrt_handle_event --&gt; off</span><br><span class="line">abrt_upload_watch_anon_write --&gt; on</span><br><span class="line">...</span><br><span class="line">cron_can_relabel --&gt; off		<span class="comment"># 这个与 cron 有关</span></span><br><span class="line">cron_system_cronjob_use_shares --&gt; off</span><br><span class="line">cron_userdomain_transition --&gt; on</span><br><span class="line">...</span><br><span class="line">httpd_anon_write --&gt; off		<span class="comment"># 与网页 http 有关</span></span><br><span class="line">httpd_builtin_scripting --&gt; on</span><br><span class="line">httpd_can_check_spam --&gt; off</span><br><span class="line"><span class="comment"># 每一行都是一个规则</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SELinux-各个规则规范的主体进程能够读取的文件-SELinux-type-查询-seinfo、sesearch"><a href="#SELinux-各个规则规范的主体进程能够读取的文件-SELinux-type-查询-seinfo、sesearch" class="headerlink" title="SELinux 各个规则规范的主体进程能够读取的文件 SELinux type 查询 seinfo、sesearch"></a>SELinux 各个规则规范的主体进程能够读取的文件 SELinux type 查询 seinfo、sesearch</h4><p>上述指令知道了所有的规则开启情况，可以通过 <strong>seinfo</strong>、<strong>sesearch</strong> 等工具来查看每个规则具体在限制什么。</p>
<p>上述工具并未预装，<a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/07/03.html#%E6%8C%82%E8%BD%BD-cd-%E6%88%96-dvd-%E5%85%89%E7%9B%98">请拿出安装光盘挂载到 /mnt 目录下</a>，安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># blkid </span></span><br><span class="line">/dev/sr0: UUID=<span class="string">&quot;2019-09-11-18-50-31-00&quot;</span> LABEL=<span class="string">&quot;CentOS 7 x86_64&quot;</span> TYPE=<span class="string">&quot;iso9660&quot;</span> PTTYPE=<span class="string">&quot;dos&quot;</span> </span><br><span class="line">/dev/sda1: UUID=<span class="string">&quot;e9d54afb-2afe-42de-87fe-9f55d747fcd9&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> </span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;CNUXwS-J3Lh-0nDA-TssW-l1vT-90us-MHYnT1&quot;</span> TYPE=<span class="string">&quot;LVM2_member&quot;</span> </span><br><span class="line">/dev/mapper/centos_study-root: UUID=<span class="string">&quot;d7e09bb4-2f04-4ed4-b377-91a22fe85ce7&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> </span><br><span class="line">/dev/mapper/centos_study-swap: UUID=<span class="string">&quot;684eebc0-3f70-4fc1-9a5d-d683f6a07cd0&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span> </span><br><span class="line">[root@study ~]<span class="comment"># mount /dev/sr0 /mnt/</span></span><br><span class="line">mount: /dev/sr0 is write-protected, mounting read-only</span><br><span class="line">[root@study ~]<span class="comment"># yum install /mnt/Packages/setools-console-*                               </span></span><br><span class="line">...</span><br><span class="line">Complete!</span><br><span class="line">[root@study ~]<span class="comment"># umount /mnt/  # 卸载光盘</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seinfo [-Atrub]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：列出 SELinux 的状态、规则布尔值、身份识别、角色、类型等所有信息</span><br><span class="line">	-u：列出 SELinux 的所有身份识别 user 种类</span><br><span class="line">	-r：列出 SELinux 的所有角色 role 种类</span><br><span class="line">	-t：列出 SELinux 的所有类型 <span class="built_in">type</span> 种类</span><br><span class="line">	-b：列出所有规则的种类（布尔值）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出 SELinux 在此政策下的统计状态</span></span><br><span class="line">[root@study ~]<span class="comment"># seinfo </span></span><br><span class="line"></span><br><span class="line">Statistics <span class="keyword">for</span> policy file: /sys/fs/selinux/policy</span><br><span class="line">Policy Version &amp; Type: v.31 (binary, mls)</span><br><span class="line"></span><br><span class="line">   Classes:           130    Permissions:       272</span><br><span class="line">   Sensitivities:       1    Categories:       1024</span><br><span class="line">   Types:            4792    Attributes:        253</span><br><span class="line">   Users:               8    Roles:              14</span><br><span class="line">   Booleans:          316    Cond. Expr.:       362</span><br><span class="line">   Allow:          107360    Neverallow:          0</span><br><span class="line">   Auditallow:        157    Dontaudit:       10020</span><br><span class="line">   Type_trans:      18129    Type_change:        74</span><br><span class="line">   Type_member:        35    Role allow:         39</span><br><span class="line">   Role_trans:        416    Range_trans:      5899</span><br><span class="line">   Constraints:       143    Validatetrans:       0</span><br><span class="line">   Initial SIDs:       27    Fs_use:             32</span><br><span class="line">   Genfscon:          103    Portcon:           614</span><br><span class="line">   Netifcon:            0    Nodecon:             0</span><br><span class="line">   Permissives:         0    Polcap:              5</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 当前政策是 targeted ？ （哪里显示的？），此政策下的 Types 类型有 4792 个</span></span><br><span class="line"><span class="comment"># SELinux 的规则（Booleans）有 316 条</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在前面讲到过几个身份识别 <strong>user</strong> 与 角色 <strong>role</strong>，<strong>seinfo</strong> 可以查询到所有的种类，可自行查询</p>
<p>在前面讲到 <code>/etc/cron.d/checktime</code> 的 <strong>SElinux type</strong> 类型不太对，我们知道 <strong>crond</strong> 进程的 <strong>type</strong> 是 <code>crond_t</code>，那么查找下 <code>crond_t</code> 能够读取的文件 <strong>SELinux type</strong> 有哪些</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sesearch [-A] [-s 主体类别] [-t 目标类别] [-b 布尔值]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：列出后面数据中，允许「读取或放行」的相关数据</span><br><span class="line">	-t：后面还要接 <span class="built_in">type</span>、例如 -t httpd_t</span><br><span class="line">	-b：后面接 SELinux 的规则，例如 -b httpd_enable_ftp_server</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：找出 crond_t 主体进程能够读取的文件 SELinux type</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sesearch -A -s crond_t | grep spool</span></span><br><span class="line">   allow crond_t var_spool_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow crond_t system_cron_spool_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow crond_t system_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow crond_t var_spool_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow crond_t cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow daemon user_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write getattr lock append &#125; ; </span><br><span class="line">   allow crond_t cron_spool_t : dir &#123; ioctl <span class="built_in">read</span> write getattr lock add_name remove_name search open &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : dir &#123; ioctl <span class="built_in">read</span> write getattr lock add_name remove_name search open &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow crond_t system_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ;</span><br><span class="line">   </span><br><span class="line"><span class="comment"># allow 后面是主体进程以及文件的 SELinux type，上面数据是截取出来的</span></span><br><span class="line"><span class="comment"># crond_t 可以读取 system_cron_spool_t 的文件/目录类型等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：找出 crond_t 是否能读取 /etc/cron.d/checktime 这个我们自定义的配置文件？</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 /etc/cron.d/checktime</span><br><span class="line"><span class="comment"># 两个重点：SELinux type 为 admin_home_t，一个是文件（file）</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sesearch -A -s crond_t | grep admin_home_t</span></span><br><span class="line">   allow domain admin_home_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow crond_t admin_home_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow userdom_filetrans_type admin_home_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow userdom_filetrans_type admin_home_t : dir &#123; ioctl <span class="built_in">read</span> write getattr lock add_name remove_name search open &#125; ; </span><br><span class="line">   allow domain admin_home_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow crond_t admin_home_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ;</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 发现有 crond_t admin_home_t 存在，不过这个是总体的信息</span></span><br><span class="line"><span class="comment"># 没有针对某些规则的查询，所以不能确定 checktime 能否被读取，但是基本上就是 SELinux type 出现问题，才无法读取的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在知道了 <code>/etc/cron.d/checktime</code> 是 <strong>SELinux type</strong> 错误导致无法读取的。看来在 <code>getsebool -a</code> 中看到的 <code>httpd_enable_homedirs</code> 是什么？又是规范了哪些主体进程能够读取的 <strong>SELinux type</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># semanage boolean -l | grep httpd_enable_homedirs</span></span><br><span class="line">httpd_enable_homedirs          (off  ,  off)  Allow httpd to <span class="built_in">enable</span> homedirs</span><br><span class="line"><span class="comment"># httpd_enable_homedirs 的功能是允许 httpd 进程读取用户家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：列出该规则中，主体进程能够读取的文件  SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># sesearch -A -b httpd_enable_homedirs</span></span><br><span class="line">Found 77 semantic av rules:</span><br><span class="line">   allow httpd_t user_home_type : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_suexec_t user_home_type : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_suexec_t user_home_dir_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_t nfs_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t cifs_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_user_script_t user_home_type : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_user_script_t user_home_type : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_t cifs_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow httpd_t user_home_dir_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t cifs_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t user_home_dir_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t user_home_dir_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ;</span><br><span class="line">   xxx</span><br><span class="line"> <span class="comment"># 从上面的数据才可以理解，主要是放行 httpd_t 能否读取用户家目录的文件 （笔者这里是懵逼的没有看出来）</span></span><br><span class="line"> <span class="comment"># 所以，如果该规则没有启动，基本上 httpd_t 这种进程就无法读取用户家目录下的文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="修改-SELinux-规则的布尔值-setsebool"><a href="#修改-SELinux-规则的布尔值-setsebool" class="headerlink" title="修改 SELinux 规则的布尔值 setsebool"></a>修改 SELinux 规则的布尔值 setsebool</h4><p>查询到某个 <strong>SELinux rule</strong> ，并且以 <strong>seaserch</strong> 知道该规则的用途后，可以通过下面的方式来管理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setsebool [-p] [规则名称][0|1]</span><br><span class="line"></span><br><span class="line">-P：直接将设置值写入配置文件，该设置数据未来会生效</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询 httpd_enable_homedirs 这个规则的状态，并且修改这个规则为不同的布尔值</span></span><br><span class="line">[root@study ~]<span class="comment"># getsebool httpd_enable_homedirs</span></span><br><span class="line">httpd_enable_homedirs --&gt; off			<span class="comment"># 关闭状态</span></span><br><span class="line">[root@study ~]<span class="comment"># setsebool -P httpd_enable_homedirs 1		# 开启它</span></span><br><span class="line">[root@study ~]<span class="comment"># getsebool httpd_enable_homedirs</span></span><br><span class="line">httpd_enable_homedirs --&gt; on</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SELinux-安全本文的修改"><a href="#SELinux-安全本文的修改" class="headerlink" title="SELinux 安全本文的修改"></a>SELinux 安全本文的修改</h3><p><strong>SELinux</strong> 对受限的主体进程没有影响：</p>
<ol>
<li>考虑 <strong>SELinux</strong> 的三种类型</li>
<li>考虑 <strong>SELinux</strong>的政策规则是否放行</li>
<li>比对 <strong>SELinux type</strong> 关系</li>
</ol>
<p>上面讲解过可以通过 <strong>sesearch</strong> 来找到主体进程与文件的 <strong>SELinux type</strong> 关系，那么怎么修改文件的 <strong>SELinux type</strong>，能让主体进程读到呢？</p>
<h4 id="使用-chcon-手动修改文件的-SELinux-type"><a href="#使用-chcon-手动修改文件的-SELinux-type" class="headerlink" title="使用 chcon 手动修改文件的 SELinux type"></a><strong>使用 chcon 手动修改文件的 SELinux type</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chcon [-R] [-t <span class="built_in">type</span>] [-u user] [-r role] 文件</span><br><span class="line">chcon [-R] --reference=范例文件 文件</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-R：连同该目录下的次目录也同时修改</span><br><span class="line">	-t：后面接安全性本文的类型字段，例如 httpd_sys_content_t</span><br><span class="line">	-u：后面接身份识别，例如 system_u (不重要)</span><br><span class="line">	-r：后面接角色，例如 system_r （不重要）</span><br><span class="line">	-v：若有变化成功，将变动的结果列出来</span><br><span class="line">	--reference=文件：拿某个文件档范例来修改后续接的文件的类型</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询 /etc/hosts 的 SELinux type，并将该类型套用到 /etc/cron.d/checktime 上</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/hosts</span></span><br><span class="line">-rw-r--r--. root root system_u:object_r:net_conf_t:s0  /etc/hosts</span><br><span class="line"><span class="comment"># net_conf_t 是上面文件中的类型</span></span><br><span class="line">[root@study ~]<span class="comment"># chcon -v -t net_conf_t /etc/cron.d/checktime </span></span><br><span class="line">changing security context of <span class="string">&#x27;/etc/cron.d/checktime&#x27;</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:net_conf_t:s0 /etc/cron.d/checktime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：直接以 /etc/shadow 的 type 套用</span></span><br><span class="line">[root@study ~]<span class="comment"># chcon -v --reference=/etc/shadow /etc/cron.d/checktime</span></span><br><span class="line">changing security context of <span class="string">&#x27;/etc/cron.d/checktime&#x27;</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/shadow /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. root root system_u:object_r:shadow_t:s0    /etc/cron.d/checktime</span><br><span class="line">----------. root root system_u:object_r:shadow_t:s0    /etc/shadow</span><br></pre></td></tr></table></figure>

<p>上面的示例并不能解决 <strong>crond</strong> 不能读取 <code>/etc/cron.d/checktime</code> 的问题，因为需要改成 <code>/etc/cron.d</code> 下的标准 <strong>type</strong> 才行。可以使用 <strong>restorecon</strong> 来让 <strong>SELinux</strong> 自己默认解决目录下的 <strong>type</strong> 问题</p>
<h4 id="使用-restorecon-让文件恢复正确的-SELinux-type"><a href="#使用-restorecon-让文件恢复正确的-SELinux-type" class="headerlink" title="使用 restorecon 让文件恢复正确的 SELinux type"></a>使用 restorecon 让文件恢复正确的 SELinux type</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">restorecon [-Rv] 文件或目录</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-R：连同次目录一起修改</span><br><span class="line">	-v：将过程显示到屏幕上</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：将 /etc/cron.d/ 下的文件都恢复成预设的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /etc/cron.d/</span></span><br><span class="line">restorecon reset /etc/cron.d/checktime context system_u:object_r:shadow_t:s0-&gt;system_u:object_r:system_cron_spool_t:s0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面将  shadow_t 改成了 system_cron_spool_t 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 4：重新启动 crond 看看有没有正确启动 checktime</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart crond          </span></span><br><span class="line">[root@study ~]<span class="comment"># tail /var/log/cron</span></span><br><span class="line">Mar 17 16:01:01 study CROND[5886]: (root) CMD (run-parts /etc/cron.hourly)</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5886]: starting 0anacron</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5898]: finished 0anacron</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5886]: starting mcelog.cron</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5904]: finished mcelog.cron</span><br><span class="line">Mar 17 16:10:01 study CROND[5989]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">Mar 17 16:12:48 study crond[4073]: (CRON) INFO (Shutting down)</span><br><span class="line">Mar 17 16:12:48 study crond[6068]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 62% <span class="keyword">if</span> used.)</span><br><span class="line">Mar 17 16:12:49 study crond[6068]: (CRON) INFO (running with inotify support)</span><br><span class="line">Mar 17 16:12:49 study crond[6068]: (CRON) INFO (@reboot <span class="built_in">jobs</span> will be run at computer<span class="string">&#x27;s startup.)</span></span><br><span class="line"><span class="string"># 没有报错信息</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>从这里看来 <strong>restorecon</strong> 很方便，<strong>chcon</strong> 还是比较麻烦的</p>
<h4 id="semanage-默认目录的安全性本文查询与修改"><a href="#semanage-默认目录的安全性本文查询与修改" class="headerlink" title="semanage 默认目录的安全性本文查询与修改"></a>semanage 默认目录的安全性本文查询与修改</h4><p>为什么 <strong>restorecon</strong> 可以恢复原本的 <strong>SELinux type</strong> 呢？那一定是有个地方在记录每个文件/目录的 <strong>SELinux</strong> 默认类型</p>
<ol>
<li>如何查询预设的 <strong>SELinux type</strong></li>
<li>如何增加、修改、删除 预设的 <strong>SELinux type</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semanage &#123;login|user|port|interface|fcontext|translation&#125; -l</span><br><span class="line">semanage fcontext -&#123;a|d|m&#125; [-frst] file_spec</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	fcontext：主要用在安全性本文方面的用途， -l 为查询</span><br><span class="line">	-a：增加；可以增加一些目录的默认安全性本文类型设置</span><br><span class="line">	-m：修改</span><br><span class="line">	-d：删除</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询 /etc/   /etc/cron.d/ 的预设 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -l | grep -E &#x27;^/etc |^/etc/cron&#x27;</span></span><br><span class="line">/etc/cron.daily(/.*)?                              all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.weekly(/.*)?                             all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.hourly(/.*)?                             all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.monthly(/.*)?                            all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.minutely/openshift-facts                 regular file       system_u:object_r:openshift_cron_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|monthly)/acct                    regular file       system_u:object_r:acct_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/sysklogd                 regular file       system_u:object_r:logrotate_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|monthly)/mailman                 regular file       system_u:object_r:mailman_queue_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/man-db.*                 regular file       system_u:object_r:mandb_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|monthly)/radiusd                 regular file       system_u:object_r:radiusd_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/ntp-simple               regular file       system_u:object_r:ntpd_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/ntp-server               regular file       system_u:object_r:ntpd_exec_t:s0 </span><br><span class="line">/etc/cron\.((daily)|(weekly)|(monthly))/freeradius regular file       system_u:object_r:radiusd_exec_t:s0 </span><br><span class="line">/etc/cron\.d(/.*)?                                 all files          system_u:object_r:system_cron_spool_t:s0 </span><br><span class="line">/etc/cron\.daily/[sm]locate                        regular file       system_u:object_r:locate_exec_t:s0 </span><br><span class="line">/etc/cron\.weekly/(c)?fingerd                      regular file       system_u:object_r:fingerd_exec_t:s0 </span><br><span class="line">/etc                                               all files          system_u:object_r:etc_t:s0 </span><br><span class="line">/etc/crontab                                       regular file       system_u:object_r:system_cron_spool_t:s0 </span><br><span class="line">/etc/cron\.daily/prelink                           regular file       system_u:object_r:prelink_cron_system_exec_t:s0 </span><br><span class="line">/etc/cron\.daily/calamaris                         regular file       system_u:object_r:calamaris_exec_t:s0 </span><br><span class="line">/etc/cron\.daily/certwatch                         regular file       system_u:object_r:certwatch_exec_t:s0 </span><br><span class="line">/etc/cron\.monthly/proftpd                         regular file       system_u:object_r:ftpd_exec_t:s0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看 <code>/etc/cron\.d(/.*)? all files system_u:object_r:system_cron_spool_t:s0</code> 这一行，这也是为什么直接使用 vim 在 <code>/etc/cron.d</code> 下新建文件时，预设 SELinux type 是正确的。</p>
<p>练习：下面要建立一个 <code>/srv/mycron</code> 目录，默认也是需要变成 <code>system_cron_spool_t</code> 时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先建立 mycron 目录，再放入配置文件，观察 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># mkdir /srv/mycron</span></span><br><span class="line">[root@study ~]<span class="comment"># cp /etc/cron.d/checktime /srv/mycron/</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -dZ /srv/mycron/ /srv/mycron/checktime </span></span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:var_t:s0   /srv/mycron/</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:var_t:s0   /srv/mycron/checktime</span><br><span class="line"><span class="comment"># 发现变成了 var_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 观察上层 /srv 的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -l | grep &#x27;^/srv&#x27;</span></span><br><span class="line">/srv/.*                                            all files          system_u:object_r:var_t:s0 </span><br><span class="line">/srv/([^/]*/)?www(/.*)?                            all files          system_u:object_r:httpd_sys_content_t:s0 </span><br><span class="line">/srv/([^/]*/)?ftp(/.*)?                            all files          system_u:object_r:public_content_t:s0 </span><br><span class="line">/srv/([^/]*/)?rsync(/.*)?                          all files          system_u:object_r:public_content_t:s0 </span><br><span class="line">/srv/([^/]*/)?www/logs(/.*)?                       all files          system_u:object_r:httpd_log_t:s0 </span><br><span class="line">/srv/node(/.*)?                                    all files          system_u:object_r:swift_data_t:s0 </span><br><span class="line">/srv/gallery2(/.*)?                                all files          system_u:object_r:httpd_sys_content_t:s0 </span><br><span class="line">/srv/lib/gitosis(/.*)?                             all files          system_u:object_r:gitosis_var_lib_t:s0 </span><br><span class="line">/srv/gallery2/smarty(/.*)?                         all files          system_u:object_r:httpd_sys_rw_content_t:s0 </span><br><span class="line">/srv/loopback-device(/.*)?                         all files          system_u:object_r:swift_data_t:s0 </span><br><span class="line">/srv                                               all files          system_u:object_r:var_t:s0</span><br><span class="line"><span class="comment"># 可以看到这里默认就是  var_t 类型的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将 mycron 默认值改为 system_cron_spool_t</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -a -t system_cron_spool_t &quot;/srv/mycron(/.*)?&quot;</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -l | grep &#x27;^/srv/mycron&#x27;</span></span><br><span class="line">/srv/mycron(/.*)?                                  all files          system_u:object_r:system_cron_spool_t:s0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 回复 /srv/mycron 以及子目录相关的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /srv/mycron/</span></span><br><span class="line">restorecon reset /srv/mycron context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:system_cron_spool_t:s0</span><br><span class="line">restorecon reset /srv/mycron/checktime context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:system_cron_spool_t:s0</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>通过这个例子来看，<strong>restorecon</strong> 的确是很方便 ，学会这些基础的工具，对于 <strong>SELinux</strong> 来说基本上也够用了</p>
<hr>
<h2 id="一个网络服务案例及登录文件协助"><a href="#一个网络服务案例及登录文件协助" class="headerlink" title="一个网络服务案例及登录文件协助"></a>一个网络服务案例及登录文件协助</h2><p>本章在 <strong>SELinux</strong> 小节中介绍到的各个指令，尤其是 <strong>setsebool</strong>、<strong>chcon</strong>、<strong>restorecon</strong> 等都是为了当你的某些网络服务无法正常提供相关功能时，才需要进行修改的一些指令动作。</p>
<p>可以通过主动检查的方式来检查是否有 <strong>SELinux</strong> 产生的错误。而不是等客户端联机失败来反馈</p>
<h3 id="setroubleshoot：错误信息写入-var-log-messages"><a href="#setroubleshoot：错误信息写入-var-log-messages" class="headerlink" title="setroubleshoot：错误信息写入 /var/log/messages"></a>setroubleshoot：错误信息写入 <code>/var/log/messages</code></h3><p>几乎所有 <strong>SELinux</strong> 相关的程序都是以 <strong>se</strong> 开头，该服务时错误克服，启动后，会将关于 <strong>SELinux</strong> 的错误信息与克服方法记录到 <code>/var/log/messages</code> 与 <code>/var/log/setroubleshoot/*</code> 中</p>
<p>需要安装：<strong>setroubleshoot</strong> 与 <strong>setroubleshoot-server</strong>。原本 <strong>SELinux</strong> 信息是两个服务来记录的，分别是 <strong>auditd</strong> 与 <strong>setroubleshoot</strong>。在 <strong>CentOS 6.x</strong> 起整合成 <strong>auditd</strong> 了。所以安装好 <strong>setroubleshoot-server</strong> 后，需要重新启动 <strong>auditd</strong> 服务，否则 <strong>setroubleshoot</strong> 功能不会被启动</p>
<p>实际上。CentOS 7.x 对 <strong>setroubleshoot</strong> 的运行方式是：先由 <strong>auditd</strong> 去呼叫 <strong>audispd</strong> 服务，然后 <strong>audispd</strong> 服务启动 <strong>sedispatch</strong> 程序， <strong>sedispatch</strong> 再将原本的 <strong>auditd</strong> 信息转成 <strong>setroubleshoot</strong> 的信息，存储下来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># rpm -qa | grep setroubleshoot</span></span><br><span class="line">setroubleshoot-3.2.30-7.el7.x86_64</span><br><span class="line">setroubleshoot-plugins-3.0.67-4.el7.noarch</span><br><span class="line">setroubleshoot-server-3.2.30-7.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>在预设的情况下 <strong>setroubleshoot</strong> 被安装了，记得刚安装 <strong>setroubleshoot</strong> 的话，需要重新启动 <strong>auditd</strong> 服务的、</p>
<p>目前我们没有任何受限的网络服务主体进程在运行，下面使用一个简单的 <strong>FTP</strong> 服务器软件示例，来了解上面讲到的许多重点应用</p>
<h3 id="实例说明：通过-vsftpd-这个-FTP-服务器来存取系统上的文件"><a href="#实例说明：通过-vsftpd-这个-FTP-服务器来存取系统上的文件" class="headerlink" title="实例说明：通过 vsftpd 这个 FTP 服务器来存取系统上的文件"></a>实例说明：通过 vsftpd 这个 FTP 服务器来存取系统上的文件</h3><p>在 <strong>CentOS 7.x</strong> 环境下， <strong>FTP</strong> 的默认服务器软件主要是 <strong>vsftpd</strong></p>
<p>详细的 FTP 协议在服务器篇讲解，这里简单利用 <strong>vsftpd</strong> 与 <strong>FTP</strong> 的协议来讲解 <strong>SELinux</strong> 的问题与错误克服。</p>
<p>下面只接受一些简单的 <strong>FTP</strong> 知识：客户端需要使用 <strong>FTP</strong> 账户登录 <strong>FTP</strong> 服务器，有一个称为「匿名 （<strong>anonymous</strong>）」的账户可以登录系统，但是这个匿名的账户登录后，只能存取一个特定的目录，而无法脱离该目录</p>
<p>在 <strong>vsftpd</strong> 中，一般用户与匿名者的家目录说明如下：</p>
<ul>
<li>匿名者：如果使用浏览器来联机到 <strong>FTP</strong> 服务器，那预设就是使用匿名者登录系统。匿名者的家目录默认是在 <code>/var/ftp</code> 中，同时，匿名者在家目录下只能下载数据，不能上传数据到 <strong>FTP</strong> 服务器，同时匿名者无法离开 FTP 服务器的 <code>/var/ftp</code> 目录</li>
<li>一般 <strong>FTP</strong> 账户：在预设情况下，所有 <strong>UID</strong> 大于 <strong>1000</strong> 的账户，都可以使用 <strong>FTP</strong> 来登录系统，登录系统后，所有的账户都能够取得自己家目录下的文件数据，预设也可以上传、下载文件的</li>
</ul>
<p>为了避免与之前章节的用户产生误解情况，创建一个名为 <strong>ftptest</strong> 的账户，且账户密码为 <strong>myftp123</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># useradd -s /sbin/nologin ftptest</span></span><br><span class="line">[root@study ~]<span class="comment"># echo &quot;myftp123&quot; | passwd --stdin ftptest</span></span><br><span class="line">Changing password <span class="keyword">for</span> user ftptest.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>

<p>下面来安装 <strong>vsftp</strong> 服务器软件（还是在光盘中安装，前面挂载那样）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># yum install /mnt/Packages/vsftpd-3*                    </span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># systemctl start vsftpd		# 启动 vsftpd 服务</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl enable vsftpd		# 设置为开机启动</span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.</span><br><span class="line">[root@study ~]<span class="comment"># netstat -tlnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1374/cupsd          </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1578/master         </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1975/dnsmasq        </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      1374/cupsd          </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1578/master         </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           </span><br><span class="line">tcp6       0      0 :::21                   :::*                    LISTEN      6656/vsftpd         </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到   6656/vsftpd 这行数据，代表已经启动了</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名者无法下载的问题"><a href="#匿名者无法下载的问题" class="headerlink" title="匿名者无法下载的问题"></a>匿名者无法下载的问题</h3><p>模拟一些 <strong>FTP</strong> 的常用状态，假设将 <code>/etc/securetty</code> 以及主要的 <code>/etc/sysctl.conf</code> 放置给所有人下载，那么可以能会这样做</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># cp -a /etc/securetty /etc/sysctl.conf /var/ftp/pub</span></span><br><span class="line">[root@study ~]<span class="comment"># ll /var/ftp/pub/</span></span><br><span class="line">total 8</span><br><span class="line">-rw-------. 1 root root 221 Oct 31  2018 securetty</span><br><span class="line">-rw-r--r--. 1 root root 449 Aug  9  2019 sysctl.conf</span><br></pre></td></tr></table></figure>

<p>一般来说，默认要给用户下载的 <strong>FTP</strong> 文件会放在 <code>/var/ftp/pub</code> 目录中。下面使用简单的终端机浏览器 <strong>curl</strong> 来观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看 FTP 根目录下有哪些内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost</span></span><br><span class="line">drwxr-xr-x    2 0        0              42 Mar 17 09:03 pub</span><br><span class="line"><span class="comment"># 确实看到了 pub 目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看 pub 目录内的内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub</span></span><br><span class="line">curl: (78) RETR response: 550</span><br><span class="line"><span class="comment"># 无法访问，是因为 pub 是一个目录需要后缀 / 结尾</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/</span></span><br><span class="line">-rw-------    1 0        0             221 Oct 30  2018 securetty</span><br><span class="line">-rw-r--r--    1 0        0             449 Aug 08  2019 sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看里面的文件内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/sysctl.conf</span></span><br><span class="line"><span class="comment"># sysctl settings are defined through files in</span></span><br><span class="line"><span class="comment"># /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Vendors settings live in /usr/lib/sysctl.d/.</span></span><br><span class="line"><span class="comment"># To override a whole file, create a new file with the same in</span></span><br><span class="line"><span class="comment"># /etc/sysctl.d/ and put new settings there. To override</span></span><br><span class="line"><span class="comment"># only specific settings, add a file with a lexically later</span></span><br><span class="line"><span class="comment"># name in /etc/sysctl.d/ and put new settings there.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, see sysctl.conf(5) and sysctl.d(5).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面不是错误信息，是哪个文件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 继续查看下一个文件内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/securetty  </span></span><br><span class="line">curl: (78) RETR response: 550</span><br><span class="line"><span class="comment"># 这里看不到了，但是 securetty 的确是一个文件而不是一个目录，基本原因应该是权限问题</span></span><br><span class="line"><span class="comment"># 因为 vsftpd 默认放在 /var/ftp/pub 内的资料，无论什么 SELinux type 几乎都可以被读取才对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 修正权限后，再观察一次 securetty 文件</span></span><br><span class="line">[root@study ~]<span class="comment"># ll /var/ftp/pub/</span></span><br><span class="line">total 8</span><br><span class="line">-rw-------. 1 root root 221 Oct 31  2018 securetty</span><br><span class="line">-rw-r--r--. 1 root root 449 Aug  9  2019 sysctl.conf</span><br><span class="line"><span class="comment"># 可以看到 securetty 的其他人权限没有。改变成其他人也可以读取</span></span><br><span class="line">[root@study ~]<span class="comment"># chmod a+r /var/ftp/pub/securetty </span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/securetty</span></span><br><span class="line">console</span><br><span class="line">vc/1</span><br><span class="line">vc/2</span><br><span class="line">vc/3</span><br><span class="line"><span class="comment"># 此时已经能看到文件内容了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 修正 SELinux type 的内容（非必须）</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /var/ftp/</span></span><br><span class="line">restorecon reset /var/ftp/pub/securetty context system_u:object_r:etc_runtime_t:s0-&gt;system_u:object_r:public_content_t:s0</span><br><span class="line">restorecon reset /var/ftp/pub/sysctl.conf context system_u:object_r:system_conf_t:s0-&gt;system_u:object_r:public_content_t:s0</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>上述列子告诉我们，要先从权限角度来检查，如果无法被读取 ，可能是因为没有 <strong>r</strong> 或则没有 <strong>rx</strong> 权限，并不一定是 <strong>SELinux</strong> 引起的。下面看看用一般账户登录</p>
<h3 id="无法从家目录下载文件的问题分析与解决"><a href="#无法从家目录下载文件的问题分析与解决" class="headerlink" title="无法从家目录下载文件的问题分析与解决"></a>无法从家目录下载文件的问题分析与解决</h3><p>由于通过一般账户，前面建立的 <strong>ftptest</strong> 账户登录的话，文字型的 FTP 客户端软件，默认会将用户引导在根目录，而不是家目录，因此，访问的 <strong>URL</strong> 需要更改一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0. 在 ftptest 家目录下创建一些数据</span></span><br><span class="line">[root@study ~]<span class="comment"># echo  ~ftptest/</span></span><br><span class="line">/home/ftptest/</span><br><span class="line">[root@study ~]<span class="comment"># echo &quot;testing&quot; &gt;  ~ftptest/test.txt</span></span><br><span class="line">[root@study ~]<span class="comment"># cp -a /etc/hosts /etc/sysctl.conf ~ftptest/</span></span><br><span class="line">[root@study ~]<span class="comment"># ll ~ftptest/</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r--r--. 1 root root 158 Jun  7  2013 hosts</span><br><span class="line">-rw-r--r--. 1 root root 449 Aug  9  2019 sysctl.conf</span><br><span class="line">-rw-r--r--. 1 root root   8 Mar 17 17:23 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 一般账户直接登录 FTP 服务器，同时变换目录到家目录</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/</span></span><br><span class="line">curl: (67) Access denied: 530			<span class="comment"># 这里报错了</span></span><br><span class="line"><span class="comment"># 注意：书上在增加 ftptest 用户的时候，使用的是 /sbin/nologin，就无法访问 ftp，这里修改下，就可以了</span></span><br><span class="line">[root@study ~]<span class="comment"># usermod -s  /bin/bash ftptest</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/</span></span><br><span class="line">-rw-r--r--    1 0        0             158 Jun 07  2013 hosts</span><br><span class="line">-rw-r--r--    1 0        0             449 Aug 08  2019 sysctl.conf</span><br><span class="line">-rw-r--r--    1 0        0               8 Mar 17 09:23 test.txt</span><br><span class="line"><span class="comment"># 看左边的权限也是没有问题的</span></span><br><span class="line"><span class="comment"># 从这里开始，笔者的实验和书上的结果对不上了，下面只记录书上的操作指令</span></span><br><span class="line"><span class="comment"># 就是因为上面修改用户的 bash 后，虽然可以访问了，但是下面的却可以下载文件，无法达到和书上的效果一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 下载上面可以阅读的权限文件</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/test.txt</span></span><br><span class="line">curl:(78) RETR response:550</span><br><span class="line"><span class="comment"># 无法访下载，是否是 SELinux 造成的？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将 SELinux 从 Enforce 转成 Permissive </span></span><br><span class="line">[root@study ~]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/test.txt</span></span><br><span class="line">testing</span><br><span class="line">[root@study ~]<span class="comment"># setenforce 1	# 确定是 SELinux 权限问题后，改回来</span></span><br><span class="line"><span class="comment"># 需要该规则还是该 type？现在不知道</span></span><br><span class="line"><span class="comment"># 所以先查询下登录日志有没有相关的信息提供给我们处理</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># vim /var/log/messages</span></span><br><span class="line">Aug 9 02:55:58 station3-39 setroubleshoot:SELinux is preventing /usr/sbin/vsftpd</span><br><span class="line">	from lock access on the file /home/ftptest/test.txt. For complete SELinux messages.</span><br><span class="line">	run sealert -l 3axxxxxxxx</span><br><span class="line"><span class="comment"># 之类的字样，关键词就是 sealert ，执行这条命令</span></span><br><span class="line">[root@study ~]<span class="comment"># sealert -l 3axxxxxxxx</span></span><br><span class="line">SELinux is preventing /usr/sbin/vsftpd from lock access on the file /home/ftptest/<span class="built_in">test</span>/txt.</span><br><span class="line"><span class="comment"># 下面说有 47.5% 的几率是由于这个原因所发生，并且可以使用 setsebool 去解决的意思</span></span><br><span class="line">******* Plugin catchall_boolean(47.5 confidence) suggests ********</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> you want to allow ftp to home dir</span><br><span class="line">...</span><br><span class="line">Do</span><br><span class="line">setsebool -P ftp_home_dir 1</span><br><span class="line"></span><br><span class="line">******* Plugin catchall(6.38confidence) suggests ********</span><br><span class="line">DO</span><br><span class="line"><span class="comment"># grep vsftpd /var/log/audit/audit.log | audit2allow -M mypol</span></span><br><span class="line"><span class="comment"># semodule -i mypol.pp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面就重要了，是整个问题发生的主要原因</span></span><br><span class="line">Additional Information:</span><br><span class="line">Source Context	system_u:system_r:ftpd_t:s0-s0:c0.c1023</span><br><span class="line">Target Context	unconfined_u:object_r:user_home_t:s0</span><br><span class="line">Target Objects	/home/ftptest/<span class="built_in">test</span>/txt [ file ]</span><br></pre></td></tr></table></figure>

<p>通过上面的测试，知道主要的问题发生在 <strong>SElinux</strong> 的 <strong>type</strong> 不是 <strong>vsftpd_t</strong> 所能读取的原因，上面 <strong>47.5</strong> 的概率问题，<strong>ftp_home_dir</strong> 是 <strong>SELinux rules</strong> 的配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 确认下 SELinux 的模式，并且无法访问</span></span><br><span class="line">[root@study ~]<span class="comment"># getenforce </span></span><br><span class="line">Enforcing</span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/test.txt</span></span><br><span class="line">curl:(78) RETR response:550</span><br><span class="line">[root@study ~]<span class="comment"># setsebool -P ftp_home_dir 1</span></span><br><span class="line">Boolean ftp_home_dir is not defined</span><br><span class="line"><span class="comment"># 可惜笔者这里提示没有被定义，与书上对不上啊</span></span><br></pre></td></tr></table></figure>

<h3 id="一般账户用户从非正规目录上传-下载文件"><a href="#一般账户用户从非正规目录上传-下载文件" class="headerlink" title="一般账户用户从非正规目录上传/下载文件"></a>一般账户用户从非正规目录上传/下载文件</h3><p>提供 <code>/srv/gogogo</code> 目录给 <strong>ftptest</strong> 用户使用，该如何处理？假设不考虑 <strong>SELiunx</strong> 的话，就是如下方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 处理好所需要的目录数据</span></span><br><span class="line">[root@study ~]<span class="comment"># mkdir /srv/gogogo</span></span><br><span class="line">[root@study ~]<span class="comment"># chgrp ftptest /srv/gogogo/</span></span><br><span class="line"><span class="comment"># 把用户组改成 ftptest 这个组</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -d /srv/gogogo/</span></span><br><span class="line">drwxr-xr-x. 2 root ftptest 22 3月  17 22:43 /srv/gogogo/</span><br><span class="line">[root@study ~]<span class="comment"># echo &quot;test&quot; &gt; /srv/gogogo/test.txt</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost//srv/gogogo/test.txt</span></span><br><span class="line">curl: (78) RETR response: 550</span><br><span class="line"><span class="comment"># 访问不了，查看日志</span></span><br><span class="line">[root@study ~]<span class="comment"># grep sealert /var/log/messages | tail</span></span><br><span class="line">Mar 17 22:46:35 study setroubleshoot: SELinux is preventing /usr/sbin/vsftpd from <span class="built_in">read</span> access on the file test.txt. For complete SELinux messages run: sealert -l 88f08c09-c510-4518-bbcc-58bcee06ffb0</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sealert -l 88f08c09-c510-4518-bbcc-58bcee06ffb0</span></span><br><span class="line">SELinux is preventing /usr/sbin/vsftpd from <span class="built_in">read</span> access on the file test.txt.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然这个可信度很高，不过，因为会全部方向 FTP，所以不考虑</span></span><br><span class="line">*****  Plugin catchall_boolean (57.6 confidence) suggests   ******************</span><br><span class="line"></span><br><span class="line">If you want to allow ftpd to full access</span><br><span class="line">Then you must tell SELinux about this by enabling the <span class="string">&#x27;ftpd_full_access&#x27;</span> boolean.</span><br><span class="line"></span><br><span class="line">Do</span><br><span class="line">setsebool -P ftpd_full_access 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为是非正规目录的使用，所以这边加上预设 SELinux type 恐怕能解决</span></span><br><span class="line">*****  Plugin catchall_labels (36.2 confidence) suggests   *******************</span><br><span class="line"></span><br><span class="line">If you want to allow vsftpd to have <span class="built_in">read</span> access on the test.txt file</span><br><span class="line">Then you need to change the label on test.txt</span><br><span class="line">Do</span><br><span class="line"><span class="comment"># 下面这一条数据</span></span><br><span class="line"><span class="comment"># semanage fcontext -a -t FILE_TYPE &#x27;test.txt&#x27;</span></span><br><span class="line">.... 很多数据</span><br><span class="line">Then execute:</span><br><span class="line">restorecon -v <span class="string">&#x27;test.txt&#x27;</span>		<span class="comment"># 还有这一条数据，都是要参考的解决方案</span></span><br><span class="line"></span><br><span class="line">*****  Plugin catchall (7.64 confidence) suggests   **************************</span><br><span class="line"></span><br><span class="line">If you believe that vsftpd should be allowed <span class="built_in">read</span> access on the test.txt file by default.</span><br><span class="line">Then you should report this as a bug.</span><br><span class="line">You can generate a <span class="built_in">local</span> policy module to allow this access.</span><br><span class="line">Do</span><br><span class="line">allow this access <span class="keyword">for</span> now by executing:</span><br><span class="line"><span class="comment"># ausearch -c &#x27;vsftpd&#x27; --raw | audit2allow -M my-vsftpd</span></span><br><span class="line"><span class="comment"># semodule -i my-vsftpd.pp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Additional Information:</span><br><span class="line">Source Context                system_u:system_r:ftpd_t:s0-s0:c0.c1023</span><br><span class="line">Target Context                unconfined_u:object_r:var_t:s0</span><br><span class="line">Target Objects                test.txt [ file ]</span><br><span class="line">Source                        vsftpd</span><br><span class="line">Source Path                   /usr/sbin/vsftpd</span><br><span class="line">Port                          &lt;Unknown&gt;</span><br><span class="line">Host                          study.centos.mrcode</span><br><span class="line">Source RPM Packages           </span><br><span class="line">Target RPM Packages           </span><br><span class="line">Policy RPM                    selinux-policy-3.13.1-252.el7.noarch</span><br><span class="line">Selinux Enabled               True</span><br><span class="line">Policy Type                   targeted</span><br><span class="line">Enforcing Mode                Enforcing</span><br><span class="line">Host Name                     study.centos.mrcode</span><br><span class="line">Platform                      Linux study.centos.mrcode 3.10.0-1062.el7.x86_64</span><br><span class="line">                              <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64</span></span><br><span class="line">Alert Count                   2</span><br><span class="line">First Seen                    2020-03-17 22:46:17 CST</span><br><span class="line">Last Seen                     2020-03-17 22:46:32 CST</span><br><span class="line">Local ID                      88f08c09-c510-4518-bbcc-58bcee06ffb0</span><br><span class="line"></span><br><span class="line">Raw Audit Messages</span><br><span class="line"><span class="built_in">type</span>=AVC msg=audit(1584456392.386:979): avc:  denied  &#123; <span class="built_in">read</span> &#125; <span class="keyword">for</span>  pid=10979 comm=<span class="string">&quot;vsftpd&quot;</span> name=<span class="string">&quot;test.txt&quot;</span> dev=<span class="string">&quot;dm-0&quot;</span> ino=35108539 scontext=system_u:system_r:ftpd_t:s0-s0:c0.c1023 tcontext=unconfined_u:object_r:var_t:s0 tclass=file permissive=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hash: vsftpd,ftpd_t,var_t,file,<span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看 /var/ftp 的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment">#  ll -Zd /var/ftp/</span></span><br><span class="line">drwxr-xr-x. root root system_u:object_r:public_content_t:s0 /var/ftp/</span><br><span class="line">[root@study ~]<span class="comment">#  ll -Zd /srv/gogogo/</span></span><br><span class="line">drwxr-xr-x. root ftptest unconfined_u:object_r:var_t:s0   /srv/gogogo/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 以 sealert 建议的方法来处理好 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -a -t public_content_t &#x27;/srv/gogogo(/.*)?&#x27;</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /srv/gogogo</span></span><br><span class="line">restorecon reset /srv/gogogo context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:public_content_t:s0</span><br><span class="line">restorecon reset /srv/gogogo/test.txt context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:public_content_t:s0</span><br><span class="line"><span class="comment"># 再次访问就可以了</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost//srv/gogogo/test.txt</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>在这个范例中，修改的是 <strong>type</strong>，前一个范例中修改的是 <strong>rule</strong>，不太一样的</p>
<h3 id="无法变更-FTP-联机端口问题分析解决"><a href="#无法变更-FTP-联机端口问题分析解决" class="headerlink" title="无法变更 FTP 联机端口问题分析解决"></a>无法变更 FTP 联机端口问题分析解决</h3><p>比如你想要改变 FTP 默认的启动端口 21 改成 555，基本上，既然 SELinux 的主体进程大多是被受限的网络服务，很有可能连端口也限制了，下面尝试修改端口，来查看是怎么解决问题的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先处理 vsftpd 的配置文件，加入 port 的端口参数</span></span><br><span class="line">[root@study ~]<span class="comment"># vim /etc/vsftpd/vsftpd.conf </span></span><br><span class="line">listen_port=555</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重启服务，并查看日志</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart vsftpd</span></span><br><span class="line">Job <span class="keyword">for</span> vsftpd.service failed because the control process exited with error code. See <span class="string">&quot;systemctl status vsftpd.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">[root@study ~]<span class="comment"># grep sealert /var/log/messages</span></span><br><span class="line">Mar 17 23:03:23 study setroubleshoot: SELinux is preventing /usr/sbin/vsftpd from name_bind access on the tcp_socket port 555. For complete SELinux messages run: sealert -l e3e3dee0-83eb-4cb8-b894-8be590fee082</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sealert -l e3e3dee0-83eb-4cb8-b894-8be590fee082</span></span><br><span class="line">SELinux is preventing /usr/sbin/vsftpd from name_bind access on the tcp_socket port 555.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个 92.2 的概率，基本上就是这个了</span></span><br><span class="line">*****  Plugin bind_ports (92.2 confidence) suggests   ************************</span><br><span class="line"></span><br><span class="line">If you want to allow /usr/sbin/vsftpd to <span class="built_in">bind</span> to network port 555</span><br><span class="line">Then you need to modify the port <span class="built_in">type</span>.</span><br><span class="line">Do</span><br><span class="line"><span class="comment"># semanage port -a -t PORT_TYPE -p tcp 555</span></span><br><span class="line">    <span class="built_in">where</span> PORT_TYPE is one of the following: certmaster_port_t, cluster_port_t, ephemeral_port_t, ftp_data_port_t, ftp_port_t, hadoop_datanode_port_t, hplip_port_t, isns_port_t, port_t, postgrey_port_t, unreserved_port_t.</span><br><span class="line"></span><br><span class="line">*****  Plugin catchall_boolean (7.83 confidence) suggests   ******************</span><br><span class="line"></span><br><span class="line">If you want to allow nis to enabled</span><br><span class="line">Then you must tell SELinux about this by enabling the <span class="string">&#x27;nis_enabled&#x27;</span> boolean.</span><br><span class="line"></span><br><span class="line">Do</span><br><span class="line">setsebool -P nis_enabled 1</span><br><span class="line"></span><br><span class="line">*****  Plugin catchall (1.41 confidence) suggests   **************************</span><br><span class="line"></span><br><span class="line">If you believe that vsftpd should be allowed name_bind access on the port 555 tcp_socket by default.</span><br><span class="line">Then you should report this as a bug.</span><br><span class="line">You can generate a <span class="built_in">local</span> policy module to allow this access.</span><br><span class="line">Do</span><br><span class="line">allow this access <span class="keyword">for</span> now by executing:</span><br><span class="line"><span class="comment"># ausearch -c &#x27;vsftpd&#x27; --raw | audit2allow -M my-vsftpd</span></span><br><span class="line"><span class="comment"># semodule -i my-vsftpd.pp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Additional Information:</span><br><span class="line">Source Context                system_u:system_r:ftpd_t:s0-s0:c0.c1023</span><br><span class="line">Target Context                system_u:object_r:hi_reserved_port_t:s0</span><br><span class="line">Target Objects                port 555 [ tcp_socket ]</span><br><span class="line">Source                        vsftpd</span><br><span class="line">Source Path                   /usr/sbin/vsftpd</span><br><span class="line">Port                          555</span><br><span class="line">Host                          study.centos.mrcode</span><br><span class="line">Source RPM Packages           vsftpd-3.0.2-25.el7.x86_64</span><br><span class="line">Target RPM Packages           </span><br><span class="line">Policy RPM                    selinux-policy-3.13.1-252.el7.noarch</span><br><span class="line">Selinux Enabled               True</span><br><span class="line">Policy Type                   targeted</span><br><span class="line">Enforcing Mode                Enforcing</span><br><span class="line">Host Name                     study.centos.mrcode</span><br><span class="line">Platform                      Linux study.centos.mrcode 3.10.0-1062.el7.x86_64</span><br><span class="line">                              <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64</span></span><br><span class="line">Alert Count                   1</span><br><span class="line">First Seen                    2020-03-17 23:03:20 CST</span><br><span class="line">Last Seen                     2020-03-17 23:03:20 CST</span><br><span class="line">Local ID                      e3e3dee0-83eb-4cb8-b894-8be590fee082</span><br><span class="line"></span><br><span class="line">Raw Audit Messages</span><br><span class="line"><span class="built_in">type</span>=AVC msg=audit(1584457400.225:1008): avc:  denied  &#123; name_bind &#125; <span class="keyword">for</span>  pid=11443 comm=<span class="string">&quot;vsftpd&quot;</span> src=555 scontext=system_u:system_r:ftpd_t:s0-s0:c0.c1023 tcontext=system_u:object_r:hi_reserved_port_t:s0 tclass=tcp_socket permissive=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>=SYSCALL msg=audit(1584457400.225:1008): arch=x86_64 syscall=<span class="built_in">bind</span> success=no <span class="built_in">exit</span>=EACCES a0=4 a1=55e9e4d4e800 a2=1c a3=3 items=0 ppid=11440 pid=11443 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm=vsftpd exe=/usr/sbin/vsftpd subj=system_u:system_r:ftpd_t:s0-s0:c0.c1023 key=(null)</span><br><span class="line"></span><br><span class="line">Hash: vsftpd,ftpd_t,hi_reserved_port_t,tcp_socket,name_bind</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 根据建议解决执行指令, 92% 哪个指令下面 PORT_TYPE 下面又可选的 ftp_port_t</span></span><br><span class="line"><span class="comment"># 但是笔者还是懵逼的，不知道为什么那么多里面就选这个了</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage port -a -t ftp_port_t -p tcp 555</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart vsftpd</span></span><br><span class="line">[root@study ~]<span class="comment"># netstat -tlnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1374/cupsd          </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1578/master         </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN      10579/sshd: root@pt </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1975/dnsmasq        </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      1374/cupsd          </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1578/master         </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp6       0      0 ::1:6011                :::*                    LISTEN      10579/sshd: root@pt </span><br><span class="line">tcp6       0      0 :::555                  :::*                    LISTEN      11573/vsftpd        </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd     </span><br><span class="line"><span class="comment"># 可以看到 vsftpd 的端口变成了 555 了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 实验看看该 port 是否可用</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost:555</span></span><br><span class="line">drwxr-xr-x    2 0        0              42 Mar 17 09:03 pub</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/05/13/Linux%E6%95%99%E7%A8%8B/" rel="prev" title="Linux教程(一)">
                  <i class="fa fa-angle-left"></i> Linux教程(一)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/12/JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="next" title="Java 监控和诊断工具：jps、jstat、jcmd、jmap和jstack">
                  Java 监控和诊断工具：jps、jstat、jcmd、jmap和jstack <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wotzc</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/wotzc" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
