<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="真正的大师永远都怀着一颗学徒的心">
<meta property="og:type" content="website">
<meta property="og:title" content="Cai">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Cai">
<meta property="og:description" content="真正的大师永远都怀着一颗学徒的心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wotzc">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Cai</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cai</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wotzc"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">wotzc</p>
  <div class="site-description" itemprop="description">真正的大师永远都怀着一颗学徒的心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/05/Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/05/Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">Netty核心模块组件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-05 20:13:54" itemprop="dateCreated datePublished" datetime="2025-08-05T20:13:54+08:00">2025-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 15:29:56" itemprop="dateModified" datetime="2025-08-12T15:29:56+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Netty-核心模块组件"><a href="#Netty-核心模块组件" class="headerlink" title="Netty 核心模块组件"></a>Netty 核心模块组件</h1><h2 id="Bytebuf（字节容器）"><a href="#Bytebuf（字节容器）" class="headerlink" title="Bytebuf（字节容器）"></a>Bytebuf（字节容器）</h2><p><strong>网络通信最终都是通过字节流进行传输的。 <code>ByteBuf</code> 就是 Netty 提供的一个字节容器，其内部是一个字节数组。</strong> 当我们通过 Netty 传输数据的时候，就是通过 <code>ByteBuf</code> 进行的。</p>
<p>我们可以将 <code>ByteBuf</code> 看作是 Netty 对 Java NIO 提供了 <code>ByteBuffer</code> 字节容器的封装和抽象。</p>
<p>有很多小伙伴可能就要问了 ： <strong>为什么不直接使用 Java NIO 提供的 <code>ByteBuffer</code> 呢？</strong></p>
<p>因为 <code>ByteBuffer</code> 这个类使用起来过于复杂和繁琐。</p>
<h2 id="Bootstrap-和-ServerBootstrap（启动引导类）"><a href="#Bootstrap-和-ServerBootstrap（启动引导类）" class="headerlink" title="Bootstrap 和 ServerBootstrap（启动引导类）"></a>Bootstrap 和 ServerBootstrap（启动引导类）</h2><p><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件。</p>
<p><code>Bootstrap</code> 类是客户端程序的启动引导类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">//指定线程模型</span></span><br><span class="line">        b.group(group).</span><br><span class="line">                ......</span><br><span class="line">        <span class="comment">// 尝试建立连接</span></span><br><span class="line">        ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerBootstrap</code> 是服务端启动引导类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">    b.group(bossGroup, workerGroup).</span><br><span class="line">           ......</span><br><span class="line">    <span class="comment">// 6.绑定端口</span></span><br><span class="line">    ChannelFuture f = b.bind(port).sync();</span><br><span class="line">    <span class="comment">// 等待连接关闭</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的示例中，我们可以看出：</p>
<ol>
<li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li>
<li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li>
<li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的 IO 处理。</li>
</ol>
<p>常见的方法有</p>
<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>
<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>
</ul>
<hr>
<h2 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Netty</code> 是异步非阻塞的，所有的 I/O 操作都为异步的。</p>
<p>因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sync();</span><br></pre></td></tr></table></figure>

<p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取连接相关联的<code>Channel</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel &#x3D; f.channel();</span><br></pre></td></tr></table></figure>

<p>另外，我们还可以通过 <code>ChannelFuture</code> 接口的 <code>sync()</code>方法让异步的操作编程同步的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;bind()是异步的，但是，你可以通过 &#96;sync()&#96;方法将其变为同步。</span><br><span class="line">ChannelFuture f &#x3D; b.bind(port).sync();</span><br></pre></td></tr></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>Channel</code> 接口是 Netty 对网络操作抽象类。</p>
<ol>
<li>通过 <code>Channel</code> 我们可以进行 I/O 操作</li>
<li>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</li>
<li>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</li>
<li><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</li>
<li>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</li>
<li>支持关联 <code>I/O</code> 操作与对应的处理程序</li>
</ol>
<p>比较常用的<code>Channel</code>接口实现类是 ：</p>
<ul>
<li><code>NioServerSocketChannel</code>（服务端）</li>
<li><code>NioSocketChannel</code>（客户端）</li>
</ul>
<p>这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><ol>
<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>
<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>
</ol>
<h2 id="ChannelHandler-及其实现类"><a href="#ChannelHandler-及其实现类" class="headerlink" title="ChannelHandler 及其实现类"></a>ChannelHandler 及其实现类</h2><p><strong><code>ChannelHandler</code> 是消息的具体处理器，主要负责处理客户端/服务端接收和发送的数据。</strong>    <img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/ChannelHandler.jpg"></p>
<p><code>ChannelHandler</code>本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<ul>
<li><code>ChannelInboundHandler</code>用于处理入站I / O事件</li>
<li><code>ChannelOutboundHandler</code>用于处理出站I / O操作</li>
</ul>
<p>或者使用以下适配器类：</p>
<ul>
<li><code>ChannelInboundHandlerAdapter</code>用于处理入站I / O事件</li>
<li><code>ChannelOutboundHandlerAdapter</code>用于处理出站I / O操作</li>
<li><code>ChannelDuplexHandler</code>用于处理入站和出站事件</li>
</ul>
<p>当 <code>Channel</code> 被创建时，它会被自动地分配到它专属的 <code>ChannelPipeline</code>。 一个<code>Channel</code>包含一个 <code>ChannelPipeline</code>。 <code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，一个 pipeline 上可以有多个 <code>ChannelHandler</code>。</p>
<p>我们可以在 <code>ChannelPipeline</code> 上通过 <code>addLast()</code> 方法添加一个或者多个<code>ChannelHandler</code> （<em>一个数据或者事件可能会被多个 Handler 处理</em>） 。当一个 <code>ChannelHandler</code> 处理完之后就将数据交给下一个 <code>ChannelHandler</code> 。</p>
<p>当 <code>ChannelHandler</code> 被添加到的 <code>ChannelPipeline</code> 它得到一个 <code>ChannelHandlerContext</code>，它代表一个 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的“绑定”。 <code>ChannelPipeline</code> 通过 <code>ChannelHandlerContext</code>来间接管理 <code>ChannelHandler</code> 。</p>
<h2 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h2><p><code>ChannelPipeline</code> 是一个重点：</p>
<ol>
<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>
<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>
<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>
</ol>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/channelpipline.jpg"></p>
<p>一个 <code>Channel</code> 包含了一个 <code>ChannelPipeline</code>, 而 <code>ChannelPipeline</code> 中又维护了一个由 <code>ChannelHandlerContext</code> 组成的双向链表, 并且每个 <code>ChannelHandlerContext</code> 中又关联着一个 <code>ChannelHandler</code>。入站事件和出站事件在一个双向链表中，入站事件会从链表<code>head</code>往后传递到最后一个入站的<code>handler</code>，出站事件会从链表<code>tail</code>往前传递到最前一个出站的<code>handler</code>，两种类型的<code>handler</code>互不干扰。</p>
<h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><ol>
<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>
<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用</li>
</ol>
<h2 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h2><ol>
<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>
<li><code>ChannelOption</code> 参数如下：</li>
</ol>
<ul>
<li><p><strong>ChannelOption.SO_BACKLOG</strong></p>
<p>对应TCP/IP协议listen函数中的backlog参数，用来初始化服务器可连接队列大小。服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小</p>
</li>
<li><p><strong>ChannelOption.SO_KEEPALIVE</strong></p>
<p>Socket参数，连接保活，默认值为False。启用该功能时，将一直保持连接活动状态</p>
</li>
</ul>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>这么说吧！<code>EventLoop</code>（事件循环）接口可以说是 Netty 中最核心的概念了！</p>
<p>《Netty 实战》这本书是这样介绍它的：</p>
<blockquote>
<p><code>EventLoop</code> 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。</p>
</blockquote>
<p>是不是很难理解？说实话，我学习 Netty 的时候看到这句话是没太能理解的。</p>
<p>说白了，**<code>EventLoop</code> 的主要作用实际就是责监听网络事件并调用事件处理器进行相关 I/O 操作（读写）的处理。**</p>
<h3 id="Channel-和-EventLoop-的关系"><a href="#Channel-和-EventLoop-的关系" class="headerlink" title="Channel 和 EventLoop 的关系"></a>Channel 和 EventLoop 的关系</h3><p>那 <code>Channel</code> 和 <code>EventLoop</code> 直接有啥联系呢？</p>
<p><strong><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 的 I/O 操作，两者配合进行 I/O 操作。</strong></p>
<h2 id="EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="EventLoopGroup 和其实现类 NioEventLoopGroup"></a>EventLoopGroup 和其实现类 NioEventLoopGroup</h2><p>在基于 Netty 的 TCP Server 代码中，包含了两个 EventLoopGroup——bossGroup 和 workerGroup，EventLoopGroup 是一组 EventLoop 的抽象。</p>
<p>追踪 Netty 的 EventLoop 的继承链，可以发现 EventLoop 最终继承于 JUC Executor，因此 EventLoop 本质就是一个 JUC Executor，即线程，JUC Executor 的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 为了更好地利用多核 CPU 的性能，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例，Selector 实例监听注册其上的 Channel 的 IO 事件。</p>
<p>EventLoopGroup 含有一个 next 方法，它的作用是按照一定规则从 Group 中选取一个 EventLoop 处理 IO 事件。</p>
<p>在服务端，通常 Boss EventLoopGroup 只包含一个 Boss EventLoop（单线程），该 EventLoop 维护者一个注册了 ServerSocketChannel 的 Selector 实例。该 EventLoop 不断轮询 Selector 得到 OP_ACCEPT 事件（客户端连接事件），然后将接收到的 SocketChannel 交给 Worker EventLoopGroup，Worker EventLoopGroup 会通过 next()方法选取一个 Worker EventLoop 并将这个 SocketChannel 注册到其中的 Selector 上，由这个 Worker EventLoop 负责该 SocketChannel 上后续的 IO 事件处理。整个过程如下图所示：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/eventLoopGroup.png"></p>
<h2 id="Unpooled-类"><a href="#Unpooled-类" class="headerlink" title="Unpooled 类"></a>Unpooled 类</h2><ol>
<li><code>Netty</code> 提供一个专门用来操作缓冲区(即 <code>Netty</code> 的数据容器)的工具类</li>
<li>常用方法如下所示</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过给定的数据和字符编码返回一个ByteBuf对象（类似于NIO中的ByteBuffer但有区别）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">copiedBuffer</span>(<span class="params">CharSequence <span class="built_in">string</span>, Charset charset</span>)</span></span><br></pre></td></tr></table></figure>

<p><code>ByteBuf</code>和 <code>ByteBuffer</code>的区别？</p>
<ul>
<li><code>ByteBuffer</code>是NIO的对象，<strong>ByteBuf</strong>是<strong>Netty</strong>的对象</li>
<li><code>ByteBuffer</code> 维护着<strong>postion</strong>,<strong>limit</strong>,<strong>capacity</strong>字段，每次读写时，需要进行转换，即让<strong>position=0</strong></li>
<li><code>ByteBuf</code> 维护着<strong>ReadIndex</strong>,<strong>WriteIndex</strong>,<strong>Capacity</strong>,将<strong>ByteBuf</strong>分成三个区域<ul>
<li>已读区域 0-readIndex</li>
<li>可读区域 readIndex-writeIndex</li>
<li>可写区域 writeIndex-capacity</li>
</ul>
</li>
</ul>
<p>举例说明 <strong>Unpooled</strong> 获取 <strong>Netty</strong> 的数据容器 <strong>ByteBuf</strong> 的基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf01</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个ByteBuf</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">//1. 创建一个对象，该对象包含一个数组arr，是一个byte[10]</span></span><br><span class="line">		<span class="comment">//2. 在netty的buffer中，不需要使用flip进行反转</span></span><br><span class="line">		<span class="comment">//   是因为底层维护了readerIndex属性和writerIndex属性</span></span><br><span class="line">		<span class="comment">//3. 通过 readerIndex 和 writerIndex 和 capacity，将buffer分成了三段</span></span><br><span class="line">		<span class="comment">//   0 --&gt; readerIndex：已经读取的区域</span></span><br><span class="line">		<span class="comment">//   readerIndex --&gt; writerIndex：可读的区域</span></span><br><span class="line">		<span class="comment">//   writerIndex --&gt; capacity：可写的区域</span></span><br><span class="line">		ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			buffer.writeByte(i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;capacity=&quot;</span> + buffer.capacity()); <span class="comment">//10</span></span><br><span class="line">		<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">			System.out.println(buffer.readByte());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当写入结束后，<code>writerIndex=10</code>,array数组被赋值</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/nettyByteBuf02.png" style="zoom:67%;" />

<p>读取时，<code>readerIndex</code>会递增</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/nettyByteBuf03.png" style="zoom:67%;" />

<h1 id="Netty-应用实例-群聊系统"><a href="#Netty-应用实例-群聊系统" class="headerlink" title="Netty 应用实例-群聊系统"></a>Netty 应用实例-群聊系统</h1><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
</ol>
<p><strong>GroupChatServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();  <span class="comment">// 默认8个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置两个 `EventLoopGroup`</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// 设置一个服务器端的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置队列大小128</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">// 添加用来接受的通道配置，一直保持连接</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">8000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GroupChatServerHandler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为服务端，这个Handler能够监听各种事件，这些事件对应着不同的重载方法</span></span><br><span class="line"><span class="comment"> * 1. 上线</span></span><br><span class="line"><span class="comment"> * 2. 离线</span></span><br><span class="line"><span class="comment"> * 3. 给其他人发消息等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的泛参数设置为 String，因为现在通信使用的是String字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个channelGroup，管理所有的channel</span></span><br><span class="line">    <span class="comment">// GlobalEventExecutor.INSTANCE-单例-全局的事件执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handlerAdded 表示连接建立，一旦连接，第一个被执行，此时通道尚未被激活</span></span><br><span class="line"><span class="comment">     * 将当前channel加入到channelGroup</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其它在线的客户端</span></span><br><span class="line">        <span class="comment">// 遍历channelGroup中所有的channel，并发送消息</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="keyword">new</span> java.util.Date()));</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接，把相关信息发送给其他客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离开了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelGroup size&quot;</span> + channelGroup.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道连接被激活了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 上线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道依旧存在，只是状态变为离线了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 离线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext handlerContext, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取到当前channel</span></span><br><span class="line">        Channel currentChannel = handlerContext.channel();</span><br><span class="line">        <span class="comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(channel -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentChannel != channel) &#123;</span><br><span class="line">                <span class="comment">// 不是当前的channel,转发消息</span></span><br><span class="line">                channel.writeAndFlush(channel.remoteAddress() + <span class="string">&quot; 发送了消息: &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//回显自己发送的消息给自己</span></span><br><span class="line">                channel.writeAndFlush(<span class="string">&quot;[自己]发送了消息: &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GroupChatClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//得到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入相关handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自定义的handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">//得到channel</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;-------&quot;</span> + channel.localAddress() + <span class="string">&quot;--------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GroupChatClientHandler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Netty-心跳检测机制案例"><a href="#Netty-心跳检测机制案例" class="headerlink" title="Netty 心跳检测机制案例"></a>Netty 心跳检测机制案例</h1><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li>
<li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li>
</ol>
<p><strong>MyServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty.heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO)) <span class="comment">// 给自己的通道添加Log日志处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">                            <span class="comment">// 1. IdleStateHandler 是 netty 提供的处理空闲状态的处理器</span></span><br><span class="line">                            <span class="comment">// 2. long readerIdleTime 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">// 3. long writerIdleTime 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">// 4. long allIdleTime 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line">                            <span class="comment">// 5. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个 handler 去处理</span></span><br><span class="line">                            <span class="comment">//    通过调用(触发)下一个 handler 的 userEventTiggered ,</span></span><br><span class="line">                            <span class="comment">//    在该方法中去处理 IdleStateEvent(读 空闲，写空闲，读写空闲)</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">7000</span>, <span class="number">7000</span>, <span class="number">10</span>, TimeUnit.SECONDS));</span><br><span class="line">                            <span class="comment">//加入一个对空闲检测进一步处理的handler(自定义)</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>Netty 通过 WebSocket 编程实现服务器和客户端长连接</h1><ol>
<li>Http 协议是无状态的, 浏览器和服务器间的请求响应一次，下一次会重新创建连接.</li>
<li>要求：实现基于 webSocket 的长连接的全双工的交互</li>
<li>改变 Http 协议多次请求的约束，实现长连接了， 服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
</ol>
<p>​        <img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/netty-websocket1.png" style="zoom:67%;" /></p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/netty-websocket2.png" style="zoom:67%;" />

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p><strong>WebSocketServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 因为基于http协议，所以我们使用http的编码和解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                            <span class="comment">// 是以块方式写的，添加ChunkedWriteHandler处理器</span></span><br><span class="line">                            <span class="comment">// chunkedWriteHandler是处理大数据传输的，不会占用大内存或导致内存溢出问题</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 说明：</span></span><br><span class="line"><span class="comment">                             * 1. http数据在传输过程中是分段的，HttpObjectAggregator就是可以将多个段聚合起来</span></span><br><span class="line"><span class="comment">                             * 2. 这就是为什么，当浏览器发送大量数据时，就会发送多次http请求</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 说明：</span></span><br><span class="line"><span class="comment">                             * 1. 对应WebSocket，它的数据是以帧（frame）形式传递</span></span><br><span class="line"><span class="comment">                             * 2. 可以看到WebSocketFrame下面有六个子类</span></span><br><span class="line"><span class="comment">                             * 3. 浏览器请求时：ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                             * 4. WebSocketServerProtocolHandler核心功能是将http协议升级为ws协议，保持长连接</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyTextWebSocketFrameHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyTextWebSocketFrameHandler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ChannelGroup channelGroup=<span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;服务器时间 &quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当 web 客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        channelGroup.add(ctx.channel());</span><br><span class="line">        <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println (<span class="string">&quot; handlerAdded called &quot;</span>+ctx.channel(). id(). asLongText()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><strong>hello.html</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空内容&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//也可使用SockJS库</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//判断当前浏览器是否支持WebSocket</span></span></span><br><span class="line"><span class="javascript">	<span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">window</span>.WebSocket</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="comment">//go on</span></span></span><br><span class="line"><span class="javascript">		socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8000/hello&quot;</span>);</span></span><br><span class="line">		</span><br><span class="line"><span class="javascript">		<span class="comment">//相当于channelRead0，event收到服务器端回送的消息</span></span></span><br><span class="line"><span class="javascript">		socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;responseText&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + event.data;</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="javascript">		<span class="comment">//相当于连接开启(感知到连接开启)</span></span></span><br><span class="line"><span class="javascript">		socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;responseText&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			rt.value = <span class="string">&quot;连接开启了...&quot;</span>;</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="javascript">		<span class="comment">//连接关闭(感知到连接关闭)</span></span></span><br><span class="line"><span class="javascript">		socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;responseText&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭了...&quot;</span>;</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">	&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">		alert(<span class="string">&quot;当前浏览器不支持WebSocket编程&quot;</span>);</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="javascript">	<span class="comment">//发送消息到服务器</span></span></span><br><span class="line"><span class="javascript">	<span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">message</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="title">if</span>(<span class="params">!<span class="built_in">window</span>.socket</span>)</span>&#123; <span class="comment">//判断socket是否创建好</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">return</span>;</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="javascript">		<span class="function"><span class="title">if</span>(<span class="params">socket.readyState == WebSocket.OPEN</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">			<span class="comment">//通过socket发送消息</span></span></span><br><span class="line">			socket.send(message);</span><br><span class="line"><span class="javascript">		&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">			alert(<span class="string">&quot;连接未开启...&quot;</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/20/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/20/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">Netty高性能架构设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-20 15:05:49" itemprop="dateCreated datePublished" datetime="2025-02-20T15:05:49+08:00">2025-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-02 17:07:16" itemprop="dateModified" datetime="2025-04-02T17:07:16+08:00">2025-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Netty-高性能架构设计"><a href="#Netty-高性能架构设计" class="headerlink" title="Netty 高性能架构设计"></a>Netty 高性能架构设计</h1><h2 id="线程模型基本介绍"><a href="#线程模型基本介绍" class="headerlink" title="线程模型基本介绍"></a>线程模型基本介绍</h2><ol>
<li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li>
<li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li>
<li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li>
<li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li>
</ol>
<h2 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h2><h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><ol>
<li>黄色的框表示对象，蓝色的框表示线程</li>
<li>白色的框表示方法（<code>API</code>）</li>
</ol>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_01.png" style="zoom:67%;" />

<h3 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h3><ol>
<li>采用阻塞 <code>IO</code> 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ol>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li>
</ol>
<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p><strong>针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</strong></p>
<ol>
<li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。<code>Reactor</code> 对应的叫法：<ol>
<li>反应器模式</li>
<li>分发者模式（<code>Dispatcher</code>）</li>
<li>通知者模式（<code>notifier</code>）</li>
</ol>
</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ol>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_02.png" style="zoom:67%;" />

<h3 id="I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h3><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_03.png" style="zoom:67%;" />

<p>对上图说明：</p>
<ol>
<li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li>
<li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li>
</ol>
<h3 id="Reactor-模式中核心组成"><a href="#Reactor-模式中核心组成" class="headerlink" title="Reactor 模式中核心组成"></a>Reactor 模式中核心组成</h3><ol>
<li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li>
</ol>
<h3 id="Reactor-模式分类"><a href="#Reactor-模式分类" class="headerlink" title="Reactor 模式分类"></a>Reactor 模式分类</h3><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p>
<ol>
<li>单 <code>Reactor</code> 单线程</li>
<li>单 <code>Reactor</code> 多线程</li>
<li>主从 <code>Reactor</code> 多线程</li>
</ol>
<h2 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h2><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_04.png" style="zoom:67%;" />

<h3 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h3><ol>
<li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li>
<li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p>
<h3 id="方案优缺点分析"><a href="#方案优缺点分析" class="headerlink" title="方案优缺点分析"></a>方案优缺点分析</h3><ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li>
</ol>
<h2 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h2><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_05.png" style="zoom:67%;" />

<h3 id="方案说明-1"><a href="#方案说明-1" class="headerlink" title="方案说明"></a>方案说明</h3><ol>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li>
<li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li>
<li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li>
<li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li>
<li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li>
</ol>
<h3 id="方案优缺点分析-1"><a href="#方案优缺点分析-1" class="headerlink" title="方案优缺点分析"></a>方案优缺点分析</h3><ol>
<li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li>
</ol>
<h2 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h2><h3 id="工作原理图-1"><a href="#工作原理图-1" class="headerlink" title="工作原理图"></a>工作原理图</h3><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_06.png" style="zoom:67%;" />

<h3 id="上图的方案说明"><a href="#上图的方案说明" class="headerlink" title="上图的方案说明"></a>上图的方案说明</h3><ol>
<li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li>
<li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li>
<li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li>
<li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li>
<li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li>
<li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li>
<li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li>
<li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li>
</ol>
<p>这里引用<code>Doug Lee</code>大神的<strong>Reactor</strong>介绍：<code>Scalable IO in Java</code>里面关于主从<strong>Reactor</strong>多线程模型的图</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/netty6.png" style="zoom: 33%;" />

<h3 id="方案优缺点说明"><a href="#方案优缺点说明" class="headerlink" title="方案优缺点说明"></a><a target="_blank" rel="noopener" href="https://dongzl.github.io/netty-handbook/#/_content/chapter05?id=_564-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E8%AF%B4%E6%98%8E">方案优缺点说明</a></h3><ol>
<li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
<li>缺点：编程复杂度较高</li>
<li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li>
</ol>
<h2 id="Reactor-模式小结"><a href="#Reactor-模式小结" class="headerlink" title="Reactor 模式小结"></a>Reactor 模式小结</h2><h3 id="3-种模式用生活案例来理解"><a href="#3-种模式用生活案例来理解" class="headerlink" title="3 种模式用生活案例来理解"></a>3 种模式用生活案例来理解</h3><ol>
<li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li>
<li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li>
</ol>
<h3 id="Reactor-模式具有如下的优点"><a href="#Reactor-模式具有如下的优点" class="headerlink" title="Reactor 模式具有如下的优点"></a>Reactor 模式具有如下的优点</h3><ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li>
<li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<hr>
<h2 id="Netty-模型"><a href="#Netty-模型" class="headerlink" title="Netty 模型"></a>Netty 模型</h2><h3 id="工作原理示意图1-简单版"><a href="#工作原理示意图1-简单版" class="headerlink" title="工作原理示意图1 - 简单版"></a>工作原理示意图1 - 简单版</h3><p><code>Netty</code> 主要基于主从 <code>Reactors</code> 多线程模型（如图）做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code></p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_08.png" style="zoom:67%;" />

<ol>
<li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li>
<li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li>
<li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li>
</ol>
<h3 id="工作原理示意图2-进阶版"><a href="#工作原理示意图2-进阶版" class="headerlink" title="工作原理示意图2 - 进阶版"></a>工作原理示意图2 - 进阶版</h3><p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_09.png"></p>
<h3 id="工作原理示意图-详细版"><a href="#工作原理示意图-详细版" class="headerlink" title="工作原理示意图 - 详细版"></a>工作原理示意图 - 详细版</h3><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter05_10.png" style="zoom:88%;" />

<ol>
<li><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</li>
<li><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></li>
<li><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></li>
<li><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</li>
<li><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></li>
<li>每个 <code>BossNioEventLoop</code> 循环执行的步骤有 <code>3</code> 步<ul>
<li>轮询 <code>accept</code> 事件</li>
<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 循环执行的步骤<ul>
<li>轮询 <code>read</code>，<code>write</code> 事件</li>
<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</li>
</ol>
<h3 id="Netty-快速入门实例-TCP-服务"><a href="#Netty-快速入门实例-TCP-服务" class="headerlink" title="Netty 快速入门实例 - TCP 服务"></a>Netty 快速入门实例 - TCP 服务</h3><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p>
<ol>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”你好,服务器~”</li>
<li>服务器可以回复消息给客户端”你好,客户端~”</li>
<li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li>
<li>说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li>
<li>代码如下</li>
</ol>
<p><strong>NettyServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">        <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    <span class="comment">//          .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode()); <span class="comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;.....服务器 is ready...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 成功&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyServerHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; channle =&quot;</span> + ctx.channel());</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx =&quot;</span> + ctx);</span><br><span class="line">        System.out.println(<span class="string">&quot;看看channel 和 pipeline的关系&quot;</span>);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        ChannelPipeline pipeline = ctx.pipeline(); <span class="comment">//本质是一个双向链接, 出站入站</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 msg 转成一个 ByteBuf</span></span><br><span class="line">        <span class="comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClientHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client &quot;</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, server: &quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址： &quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务队列中的-Task-有-3-种典型使用场景"><a href="#任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="任务队列中的 Task 有 3 种典型使用场景"></a>任务队列中的 Task 有 3 种典型使用场景</h3><ol>
<li>用户程序自定义的普通任务【举例说明】</li>
<li>用户自定义定时任务</li>
<li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li>
</ol>
<p>代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span></span><br><span class="line">        <span class="comment">// NIOEventLoop 的 taskQueue中,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决方案1 用户程序自定义的普通任务</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;go on ...&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/20/Ursa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/20/Ursa/" class="post-title-link" itemprop="url">Ursa</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-20 09:28:56 / 修改时间：10:47:57" itemprop="dateCreated datePublished" datetime="2025-02-20T09:28:56+08:00">2025-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Life/" itemprop="url" rel="index"><span itemprop="name">Life</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Usra and Matteo</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/life/IMG_8154.png" style="zoom:67%;" />

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/13/Netty-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/13/Netty-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">Netty 概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-13 14:42:37" itemprop="dateCreated datePublished" datetime="2025-02-13T14:42:37+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 09:24:13" itemprop="dateModified" datetime="2025-02-20T09:24:13+08:00">2025-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Netty-官网说明"><a href="#Netty-官网说明" class="headerlink" title="Netty 官网说明"></a>Netty 官网说明</h1><p><strong>Netty</strong> 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>
<p><strong>Netty</strong> 是一个 <strong>NIO</strong> 客户端服务器框架，可以快速轻松地开发网络应用程序（例如协议服务器和客户端）。它极大地简化和精简了 <strong>TCP</strong> 和 <strong>UDP</strong> 套接字服务器等网络编程。</p>
<p>“快速简便”并不意味着生成的应用程序会存在可维护性或性能问题。<strong>Netty</strong> 的设计非常谨慎，它借鉴了从实施大量协议（例如 FTP、SMTP、HTTP 以及各种二进制和基于文本的旧协议）中获得的经验。因此，<strong>Netty</strong> 成功地找到了一种无需妥协即可实现易于开发、性能、稳定性和灵活性的方法。</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/netty-components.png" style="zoom: 67%;" />

<h1 id="The-Problem-问题"><a href="#The-Problem-问题" class="headerlink" title="The Problem 问题"></a>The Problem 问题</h1><p>今天，我们使用通用的应用程序或者类库来实现互相通讯，比如，我们经常使用一个 HTTP 客户端库来从 web 服务器上获取信息，或者通过 web 服务来执行一个远程的调用。</p>
<p>然而，有时候一个通用的协议或他的实现并没有很好的满足需求。比如我们无法使用一个通用的 HTTP 服务器来处理大文件、电子邮件以及近实时消息，比如金融信息和多人游戏数据。我们需要一个高度优化的协议来处理一些特殊的场景。例如你可能想实现一个优化了的 Ajax 的聊天应用、媒体流传输或者是大文件传输器，你甚至可以自己设计和实现一个全新的协议来准确地实现你的需求。</p>
<p>另一个不可避免的情况是当你不得不处理遗留的专有协议来确保与旧系统的互操作性。在这种情况下，重要的是我们如何才能快速实现协议而不牺牲应用的稳定性和性能。</p>
<h2 id="原生-NIO-存在的问题"><a href="#原生-NIO-存在的问题" class="headerlink" title="原生 NIO 存在的问题"></a>原生 NIO 存在的问题</h2><ol>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h1 id="The-Solution-解决"><a href="#The-Solution-解决" class="headerlink" title="The Solution 解决"></a>The Solution 解决</h1><p><a target="_blank" rel="noopener" href="http://netty.io/">Netty</a> 是一个提供 <code>asynchronous event-driven</code> （异步事件驱动）的网络应用框架，是一个用以快速开发高性能、可扩展协议的服务器和客户端。</p>
<p>换句话说，<strong>Netty</strong> 是一个 <strong>NIO</strong> 客户端服务器框架，使用它可以快速简单地开发网络应用程序，比如服务器和客户端的协议。<strong>Netty</strong> 大大简化了网络程序的开发过程比如 <strong>TCP</strong> 和 <strong>UDP</strong> 的 <strong>socket</strong> 服务的开发。</p>
<p>“快速和简单”并不意味着应用程序会有难维护和性能低的问题，<strong>Netty</strong> 是一个精心设计的框架，它从许多协议的实现中吸收了很多的经验比如 <strong>FTP</strong>、<strong>SMTP</strong>、<strong>HTTP</strong>、许多二进制和基于文本的传统协议.因此，<strong>Netty</strong> 已经成功地找到一个方式,在不失灵活性的前提下来实现开发的简易性，高性能，稳定性。</p>
<p>有一些用户可能已经发现其他的一些网络框架也声称自己有同样的优势，所以你可能会问是 <strong>Netty</strong> 和它们的不同之处。答案就是 <strong>Netty</strong> 的哲学设计理念。<strong>Netty</strong> 从开始就为用户提供了用户体验最好的 API 以及实现设计。正是因为 <strong>Netty</strong> 的哲学设计理念，才让您得以轻松地阅读本指南并使用 <strong>Netty</strong>。</p>
<h2 id="Netty-的优点"><a href="#Netty-的优点" class="headerlink" title="Netty 的优点"></a>Netty 的优点</h2><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>
</ol>
<h1 id="Netty-常见使用场景"><a href="#Netty-常见使用场景" class="headerlink" title="Netty 常见使用场景"></a>Netty 常见使用场景</h1><p><strong>Netty</strong> 常见的使用场景如下：</p>
<p>1）互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <strong>RPC</strong> 框架必不可少，<strong>Netty</strong> 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。典型的应用有：阿里分布式服务框架 <strong>Dubbo</strong> 的 <strong>RPC</strong> 框架，<strong>Dubbo</strong> 协议默认使用 <strong>Netty</strong> 作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p>2）游戏行业：无论是手游服务端还是大型的网络游戏，<strong>Java</strong> 语言得到了越来越广泛的应用。<strong>Netty</strong> 作为高性能的基础通信组件，它本身提供了 <strong>TCP/UDP</strong> 和 <strong>HTTP</strong> 协议栈。</p>
<p>非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过 <strong>Netty</strong> 进行高性能的通信。</p>
<p>3）大数据领域：经典的 <strong>Hadoop</strong> 的高性能通信和序列化组件 <strong>Avro</strong> 的 <strong>RPC</strong> 框架，默认采用 <strong>Netty</strong> 进行跨界点通信，它的 <strong>Netty Service</strong> 基于 <strong>Netty</strong> 框架二次封装实现。</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/Middleware-netty.jpg" style="zoom:67%;" />

<p>业界常⻅的涉及到网络通信的相关中间件大部分基于<strong>Netty</strong>实现网络层。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/14/Java-NIO%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/14/Java-NIO%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Java NIO编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-14 14:31:26" itemprop="dateCreated datePublished" datetime="2025-01-14T14:31:26+08:00">2025-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-12 10:37:57" itemprop="dateModified" datetime="2025-02-12T10:37:57+08:00">2025-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h2><ol>
<li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li>
<li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。</li>
<li><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li>
<li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li>
<li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li>
</ol>
<h2 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h2><ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h2 id="NIO-三大核心原理示意图"><a href="#NIO-三大核心原理示意图" class="headerlink" title="NIO 三大核心原理示意图"></a>NIO 三大核心原理示意图</h2><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter03_01.png" style="zoom:67%;" />

<p><strong>一个线程对应一个Selector</strong>，<strong>一个Selector对应多个channel</strong>（连接）。程序切换到哪个channel是由<strong>事件</strong>决定的，Selector会根据不同的事件，在各个通道上切换。每个channel都会对应一个Buffer，数据的读取写入是通过Buffer完成的。Buffer就是一个内存块，底层是一个数组。BIO中要么是输入流，要么是输出流，不能双向，但是 NIO 的<strong>Buffer是可以读也可以写的</strong>。</p>
<p><strong>Java NIO</strong>系统的核心在于：通道(<strong>Channel</strong>)和缓冲区(<strong>Buffer</strong>)。通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，<strong>Channel 负责传输，Buffer负责存取数据</strong>。</p>
<h2 id="NIO-三大核心"><a href="#NIO-三大核心" class="headerlink" title="NIO 三大核心"></a>NIO 三大核心</h2><h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><p><strong>基本介绍：</strong></p>
<p><strong>Buffer</strong>（缓冲区）是一个可以读取数据的内存块，可以理解成一个<strong>容器对象（含数组）</strong>，该对象提供了<strong>一组方法</strong>，可以轻松的使用内存块。缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<strong>channel</strong>提供从文件、网络读取数据的渠道，但是读取和写入数据必须都经由<strong>buffer</strong>。</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter03_02.png" style="zoom:67%;" />

<h4 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a>Buffer 类及其子类</h4><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter03_03.png" style="zoom:67%;" />

<p>Buffer 有 2 个核心方法和 4 个核心属性，下面我们一起来看看。</p>
<p>核心方法，内容如下：</p>
<ul>
<li>**put()**：存入数据到缓冲区中</li>
<li>**get()**：从缓冲区中的读取数据</li>
</ul>
<p><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</p>
<ul>
<li><strong>capacity</strong>：容量，即可以容纳的最大数据量。在缓冲区被创建时确定，并且不能更改。</li>
<li><strong>limit</strong>：表示缓冲区中可以操作数据的大小（limit后数据不能进行读写）。缓冲区的limit不能为负，并且不能大于其容量。写入模式，limit等于buffer的容量。读取模式下，limit等于写入的数据量。</li>
<li><strong>position</strong>：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其limit。</li>
<li><strong>mark</strong>：标记，是一个索引，通过 Buffer 中的mark()方法指定 Buffer 中一个特定的position，之后可以通过调用 reset() 方法恢复到这个position。</li>
</ul>
<p>以分配一个大小为 10 个字节容量的缓冲区，向里面写入<code>abcde</code>并读取数据为例，Buffer 处理过程如下图：</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/nio-buffer.png" style="zoom:67%;" />

<p>需要注意的是：</p>
<ul>
<li><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></li>
<li><code>limit</code>后的数据不能进行读写</li>
</ul>
<p><strong>基本方法：</strong></p>
<p><strong>JDK1.4</strong> 时引入的<strong>api</strong></p>
<ul>
<li><code>int capacity()</code>：返回 <strong>Buffer</strong> 的 <strong>capacity</strong> 大小；</li>
<li><code>int position()</code>：返回缓冲区的当前位置 <strong>position</strong>；</li>
<li><code>Buffer position(int n)</code>：将设置缓冲区的当前位置为 <code>n</code>，并返回修改后的 <strong>Buffer</strong> 对象；</li>
<li><code>int limit()</code>：返回 <strong>Buffer</strong> 的界限(<strong>limit</strong>)的位置；</li>
<li><code>Buffer limit(int n)</code>：将设置缓冲区界限为 <code>n</code>，并返回一个具有新的 <strong>limit</strong> 的缓冲区对象；</li>
<li><code>Buffer mark()</code>：对缓冲区设置标记；</li>
<li><code>Buffer reset()</code>：将位置 <strong>position</strong> 转到以前设置的 <strong>mark</strong> 所在的位置；</li>
<li><code>Buffer clear()</code>：清空缓冲区并返回对缓冲区的引用；</li>
<li><code>Buffer flip()</code>：为将缓冲区的界限设置为当前位置，并将当前位置充值为 <strong>0</strong>；</li>
<li><code>public final Buffer rewind()</code>：重绕此缓冲区</li>
<li><code>public final int remaining()</code>：返回当前位置与限制之间的元素数</li>
<li><code>boolean hasRemaining()</code>：判断当前位置和<strong>limit</strong>之间是否还有元素；</li>
<li><code>boolean isReadOnly()</code>：缓冲区是否为只读；</li>
</ul>
<p><strong>JDK1.6</strong> 时引入的<strong>api</strong></p>
<ul>
<li><code>boolean hasArray()</code>：缓冲区是否有可以访问的底层实现数组；</li>
<li><code>Object array()</code>：返回缓冲区的底层实现数组；</li>
<li><code>public abstract int arrayOffset()</code>：返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</li>
<li><code>public abstract boolean isDirect()</code>：告知此缓冲区是否为直接缓冲区</li>
</ul>
<p>缓冲区读写操作通过<code>get()</code>和<code>put()</code>方法来进行：</p>
<ul>
<li><code>get()</code>：读取单个字节；</li>
<li><code>get(byte[] dst)</code>：批量读取多个字节到<strong>dst</strong>中；</li>
<li><code>get(int index)</code>：读取指定索引位置的字节(不会移动 <strong>position</strong>)；</li>
<li><code>put(byte b)</code>：将给定单个字节写入缓冲区的当前位置；</li>
<li><code>put(byte[] src)</code>：将 <strong>src</strong> 中的字节写入缓冲区的当前位置；</li>
<li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 <strong>position</strong>)</li>
</ul>
<p><strong>使用案例：</strong> Buffer的子类中最常用的是<strong>ByteBuffer</strong>类，<strong>ByteBuffer</strong>常用方法使用案例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Buffers所有子类的管理方式几乎一致，通过 allocate() 获取缓冲区</span></span><br><span class="line"><span class="comment"> * 获取Buffer的方式有两种：</span></span><br><span class="line"><span class="comment"> *   非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中</span></span><br><span class="line"><span class="comment"> *   直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高读写效率，</span></span><br><span class="line"><span class="comment"> *   但是直接缓冲区的创建和销毁会有更大的开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        <span class="comment">//1. 分配一个指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 此时 position = 0； limit = capacity = 1024</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------allocate()----------------&quot;</span>);</span><br><span class="line">        System.out.println(buf.position());</span><br><span class="line">        System.out.println(buf.limit());</span><br><span class="line">        System.out.println(buf.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 利用 put() 存入数据到缓冲区中</span></span><br><span class="line">        buf.put(str.getBytes());</span><br><span class="line">        <span class="comment">// 此时 position = 5； limit = capacity = 1024</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------put()----------------&quot;</span>);</span><br><span class="line">        System.out.println(buf.position());</span><br><span class="line">        System.out.println(buf.limit());</span><br><span class="line">        System.out.println(buf.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 切换读取数据模式</span></span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="comment">// 此时 position = 0； limit = 5； capacity = 1024</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------flip()----------------&quot;</span>);</span><br><span class="line">        System.out.println(buf.position());</span><br><span class="line">        System.out.println(buf.limit());</span><br><span class="line">        System.out.println(buf.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 利用 get() 读取缓冲区中的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">        buf.get(dst);</span><br><span class="line">        <span class="comment">// 此时 position = 5； limit = 5； capacity = 1024</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------get()----------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br><span class="line">        System.out.println(buf.position());</span><br><span class="line">        System.out.println(buf.limit());</span><br><span class="line">        System.out.println(buf.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. rewind() : 可重复读</span></span><br><span class="line">        buf.rewind();</span><br><span class="line">        <span class="comment">// 此时 position = 0； limit = 5； capacity = 1024</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------rewind()----------------&quot;</span>);</span><br><span class="line">        System.out.println(buf.position());</span><br><span class="line">        System.out.println(buf.limit());</span><br><span class="line">        System.out.println(buf.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">        buf.clear();</span><br><span class="line">        <span class="comment">// 此时 position = 0； limit = capacity = 1024</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------clear()----------------&quot;</span>);</span><br><span class="line">        System.out.println(buf.position());</span><br><span class="line">        System.out.println(buf.limit());</span><br><span class="line">        System.out.println(buf.capacity());</span><br><span class="line">        <span class="comment">// 原有的数据仍然存在，可以读出</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h3><p><strong>Channel</strong>（通道）由java.nio.channels包定义。通道表示与某个实体（例如硬件设备、文件、网络套接字或程序组件）的开放连接，该实体能够执行一个或多个不同的 I/O 操作，例如读取或写入。<strong>Channel</strong>本身不能直接访问数据，<strong>Channel</strong>只能与 <strong>Buffer</strong> 进行交互。</p>
<p>1）<strong>Channel</strong>类似于传统的流，但有些区别：通道可以同时进行读写，而流只能读或者只能写；通道可以实现异步读写数据；通道可以从缓冲读数据，也可以写数据到缓冲。</p>
<p>2）<strong>BIO</strong> 中的 <strong>stream</strong> 是单向的，例如 <strong>FileInputStream</strong> 对象只能进行读取数据的操作，而 <strong>NIO</strong> 中的通道(<strong>Channel</strong>)是双向的，可以读操作，也可以写操作。</p>
<p>3）<strong>Channel</strong> 在<strong>NIO</strong>中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code>，常用的<strong>Channel</strong>实现类有：</p>
<ul>
<li><strong>FileChannel</strong>：用于读取、写入、映射和操作文件的通道。</li>
<li><strong>DatagramChannel</strong>：通过 <strong>UDP</strong> 读写网络中的数据。</li>
<li><strong>SocketChannel</strong>：通过 <strong>TCP</strong> 读写网络中的数据。</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的 <strong>TCP</strong> 连接，对每一个新进来的连接都会创建一个 <strong>SocketChannel</strong>。 </li>
</ul>
<blockquote>
<p>注意：ServerSocketChannel 类似 ServerSocket , SocketChannel 类似 Socket</p>
</blockquote>
<p><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</p>
<p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li>
<li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li>
</ul>
<p><strong>使用案例：</strong></p>
<p>案例一：使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello，world！” 写入到 <code>file01.txt</code> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Buffer和FileChannel，将 ”hello，world！“ 写入到file.txt中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello，world！&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个文件输出流</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 fileOutputStream 获得对应的 FileChannel</span></span><br><span class="line">        FileChannel channel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据写入缓冲区</span></span><br><span class="line">        buffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转化Buffer为读取模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Buffer中的数据写入到channel</span></span><br><span class="line">        channel.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件流，通道会随之关闭</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例二：使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝，拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel01 = fileInputStream.getChannel();</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel02 = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">                position = 0;</span></span><br><span class="line"><span class="comment">                limit = capacity;</span></span><br><span class="line"><span class="comment">                mark = -1;</span></span><br><span class="line"><span class="comment">                return this;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空 buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = fileChannel01.read(byteBuffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;read = &quot;</span> + read);</span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h3><p><strong>Java</strong> 的 <strong>NIO</strong>，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 **Selector(选择器)**。</p>
<p>**Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个Selector)**，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p>
<p>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。避免了多线程之间的上下文切换导致的开销。</p>
<p>Selector类是一个抽象类，有如下相关方法：</p>
<ul>
<li><code>Selector open()</code>：得到一个选择器对象；</li>
<li><code>int select(long timeout)</code>：监控所有注册的通道，当其中有IO操作可以进行时，将对应的<strong>SelectionKey</strong>加入内部集合并返回。参数用来设置超时时间（可以不设置）。</li>
<li><code>Set&lt;SeletionKey&gt; selectedKeys()</code>：从内部集合中得到所有的<strong>SeletionKey</strong>。</li>
</ul>
<p><strong>Selector</strong> 相关方法说明</p>
<ul>
<li><code>selector.select();</code> //  调用它会一直阻塞，直到获取注册到的<strong>Selector</strong>中的<strong>channel</strong>至少有一个<strong>channel</strong>发生它所关心的事件才返回，返回的是发生事件的<strong>channel</strong>的<strong>SelectionKey</strong>。</li>
<li><code>selector.select(1000);</code> // 阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> // 唤醒 selector</li>
<li><code>selector.selectNow();</code> // 不阻塞，立马返还</li>
</ul>
<h4 id="NIO-非阻塞网络编程原理分析图"><a href="#NIO-非阻塞网络编程原理分析图" class="headerlink" title="NIO 非阻塞网络编程原理分析图"></a>NIO 非阻塞网络编程原理分析图</h4><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter03_22.png" style="zoom:67%;" />

<p>NIO网络通信基本流程：</p>
<p>1）当客户端连接时，会通过 <strong>ServerSocketChannel</strong> （<strong>ServerSocketChannel</strong>也需要注册到<strong>selector</strong>上）得到 <strong>SocketChannel</strong>；</p>
<p>2）<strong>Selector</strong> 进行监听 ，通过 <code>select()</code> 方法, 返回有事件发生的通道的个数；</p>
<p>3）<strong>socketChannel</strong>调用 <code>register(Selector sel, int ops)</code>方法，注册到<strong>Selector</strong>上，一个<strong>selector</strong>上可以注册多个<strong>SocketChannel</strong>；</p>
<p>4）<strong>socketChannel</strong>注册成功后会返回一个 <strong>SelectionKey</strong>，用于和该<strong>Selector</strong> 关联，多个<strong>socketChannel</strong>注册成功后就会有一个 <strong>SelectionKey</strong> 集合；</p>
<p>5）<strong>Selector</strong>使用<code>select()</code>方法进行监听，会返回有事件发生的通道的个数，进一步可以得到对应的<strong>SeletionKey</strong>（有事件发生的）。</p>
<p>6）通过<strong>SeletionKey</strong>的<code>channel()</code>方法反向获得<strong>SocketChannel</strong>，通过<strong>channel</strong>通道完成对应的业务处理。</p>
<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p><strong>SelectionKey</strong>表示<strong>Selector</strong>和网络通道的注册关系，共四种：</p>
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
<p>源码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p><strong>SelectionKey</strong>相关方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKey</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">()</span></span>;<span class="comment">//得到与之关联的 Selector 对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">()</span></span>;<span class="comment">//得到与之关联的通道</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span></span>;<span class="comment">//得到与之关联的共享数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;<span class="comment">//设置或改变监听事件</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span></span>;<span class="comment">//是否可以 accept</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>;<span class="comment">//是否可以读</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>;<span class="comment">//是否可以写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServerSocketChanne"><a href="#ServerSocketChanne" class="headerlink" title="ServerSocketChanne"></a>ServerSocketChanne</h4><p><strong>ServerSocketChannel</strong>在服务端监听新的客户端<strong>Socket</strong>连接。相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">NetworkChannel</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 得到一个 ServerSocketChannel 通道</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="comment">// 设置服务器端端口号</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span></span></span><br><span class="line"><span class="function">	<span class="comment">// 设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span></span><br><span class="line"><span class="function">	<span class="comment">// 接受一个连接，返回代表这个连接的通道对象</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="comment">// 注册一个选择器并设置监听事件</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p><strong>SocketChannel</strong>，网络 <strong>IO</strong> 通道，具体负责进行读写操作。<strong>NIO</strong> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 得到一个 SocketChannel 通道</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;</span><br><span class="line">	<span class="comment">// 连接服务器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span></span>;</span><br><span class="line">	<span class="comment">// 如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 往通道里写数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>;</span><br><span class="line">	<span class="comment">// 从通道里读数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>;</span><br><span class="line">	<span class="comment">// 注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span>;</span><br><span class="line">	<span class="comment">// 关闭通道</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO-网络编程应用实例-群聊系统"><a href="#NIO-网络编程应用实例-群聊系统" class="headerlink" title="NIO 网络编程应用实例 - 群聊系统"></a>NIO 网络编程应用实例 - 群聊系统</h2><ol>
<li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
</ol>
<p><strong>思路</strong></p>
<ol>
<li><p>先编写服务器端</p>
<ul>
<li>服务器启动并监听6667</li>
<li>服务器接受客户端信息，并实现转发[处理上线和离线]</li>
</ul>
</li>
<li><p>编写客户端</p>
<ul>
<li>连接服务器</li>
<li>发送消息</li>
<li>接受服务器消息</li>
</ul>
</li>
</ol>
<p><strong>服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// ServerSocketChannel</span></span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将该 serverSocketChannel 注册到 selector</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NIOServer server = <span class="keyword">new</span> NIOServer();</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//有事件处理</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">if</span> (selectionKeys.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">// 取出selectionkey</span></span><br><span class="line">                        SelectionKey selectionKey = selectionKeys.next();</span><br><span class="line">                        <span class="comment">// 监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">// 将该socketChannel注册到selector</span></span><br><span class="line">                            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">// 提示有客户端上线</span></span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            readData(selectionKey);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 删除当前的key，防止重复处理</span></span><br><span class="line">                        selectionKeys.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出channel</span></span><br><span class="line">        SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 创建buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> conut = channel.read(byteBuffer);</span><br><span class="line">            <span class="comment">// count != -1 表示没有读完</span></span><br><span class="line">            <span class="keyword">if</span> (conut != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 把缓存区的数据转成字符串</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form客户端:&quot;</span> + message);</span><br><span class="line">                <span class="comment">// 向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(message, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;离线了...&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                selectionKey.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发消息给其它客户端(通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String message, SocketChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历所有注册到selector上的SocketChannel，并排除自身</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != channel) &#123;</span><br><span class="line">                <span class="comment">// 类型转换</span></span><br><span class="line">                SocketChannel socketChannel = (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">// 将message转存到buffer</span></span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line">                <span class="comment">// 将buffer的数据写入通道</span></span><br><span class="line">                socketChannel.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 得到选择器</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">        <span class="comment">// 设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将channel注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">// 得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString();</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        NIOClient nioClient = <span class="keyword">new</span> NIOClient();</span><br><span class="line">        <span class="comment">// 启动一个线程,每个3 秒，读取从服务器发送消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nioClient.readMessage();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String s = scanner.next();</span><br><span class="line">            nioClient.sendMessage(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = selector.select();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// 有可以用的通道</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 通过key得到channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 新建buffer</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// 读取数据到buffer中</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                    String message = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                    System.out.println(message);</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        message = username + <span class="string">&quot; 说：&quot;</span> + message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(message.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="NIO-与零拷贝"><a href="#NIO-与零拷贝" class="headerlink" title="NIO 与零拷贝"></a>NIO 与零拷贝</h2><h3 id="零拷贝基本介绍"><a href="#零拷贝基本介绍" class="headerlink" title="零拷贝基本介绍"></a>零拷贝基本介绍</h3><p>零拷⻉（Zero-copy）技术指在计算机执⾏操作时，CPU 不需要先将数据从⼀个内存区域复制到另⼀个内存区域，从⽽可以减少上下⽂切换以及 CPU 的拷⻉时间。它的作⽤是在数据从⽹络设备到⽤户程序空间传递的过程中，减少数据拷⻉次数，减少系统调⽤，实现 CPU 的零参与，彻底消除 CPU 在这⽅⾯的负载。</p>
<p>实现零拷⻉⽤到的最主要技术是 DMA 数据传输技术和内存区域映射技术。</p>
<p>零拷⻉机制可以减少数据在内核缓冲区和⽤户进程缓冲区之间反复的 I/O 拷⻉操作。零拷⻉机制可以减少⽤户进程地址空间和内核地址空间之间因为上下⽂切换⽽带来的 CPU 开销。在 Java 程序中，常⽤的零拷⻉有 mmap（内存映射）和 sendFile。</p>
<h3 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h3><ul>
<li><strong>用户态：</strong> 用户程序运行的环境，也是用户与操作系统交互的界面。在用户态中，用户程序可以访问系统资源，如文件、网络、内存等，但是不能直接访问硬件设备。用户态程序通过系统调用来请求内核提供服务，如文件读写、进程管理等。</li>
<li><strong>内核态：</strong> 操作系统的核心部分，负责管理系统的硬件资源和提供基本的系统服务。在内核态中，操作系统可以直接访问硬件设备，并控制它们的运行。内核态具有较高的执行权限和特权级别，可以执行一些操作系统的核心功能，如进程调度、内存管理、设备驱动等。</li>
<li><strong>上下文切换：</strong> 用户态和内核态之间通过系统调用来进行通信和交互。用户程序请求操作系统提供服务时，会通过系统调用进入内核态执行相应的操作，内核态执行完操作后再返回到用户态。这种分离的设计可以保护系统的稳定性和安全性，同时也方便了系统的管理和维护。</li>
<li><strong>管道</strong>：Linux的管道是一种将一个命令的输出作为另一个命令的输入的机制以实现数据流的传递和处理。</li>
<li><strong>DMA</strong>：（Direct Memory Access）又称直接内存存取，也就是通过硬件直接访问主内存，不需要通过 cpu，有点像协处理器，目前大多数的硬件都支持 DMA，例如网卡、显卡、声卡、磁盘等等。</li>
</ul>
<h3 id="⽤户空间和内核空间"><a href="#⽤户空间和内核空间" class="headerlink" title="⽤户空间和内核空间"></a>⽤户空间和内核空间</h3><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/kernel-space.png" style="zoom:67%;" />

<h3 id="传统IO方式"><a href="#传统IO方式" class="headerlink" title="传统IO方式"></a>传统IO方式</h3><p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/traditional-io-streams.png"></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<p>传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷⻉、2 次 DMA 拷⻉总共 4 次拷⻉，以及 4 次上下⽂切换。</p>
<h3 id="mmap-优化"><a href="#mmap-优化" class="headerlink" title="mmap 优化"></a>mmap 优化</h3><p><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/mmap-stream.png"></p>
<p> 　基于 <code>mmap</code> + <code>write</code> 系统调⽤的零拷⻉⽅式，整个拷⻉过程会发⽣ 4 次上下⽂切换，1 次 CPU 拷⻉和 2次 DMA 拷⻉，⽤户程序读写数据的流程如下：</p>
<ol>
<li>⽤户进程通过 <code>mmap()</code> 函数向内核（<strong>kernel</strong>）发起系统调⽤，上下⽂从⽤户态（<strong>user space</strong>）切换为内核态（<strong>kernel space</strong>）。</li>
<li>将⽤户进程的内核空间的读缓冲区（<strong>read buffer</strong>）与⽤户空间的缓存区（<strong>user buffer</strong>）进⾏内存地址映射。</li>
<li><strong>CPU</strong>利⽤<strong>DMA</strong>控制器将数据从主存或硬盘拷⻉到内核空间（<strong>kernel space</strong>）的读缓冲区（<strong>readbuffer</strong>）。</li>
<li>上下⽂从内核态（<strong>kernel space</strong>）切换回⽤户态（<strong>user space</strong>），<strong>mmap</strong> 系统调⽤执⾏返回。</li>
<li>⽤户进程通过 <code>write()</code> 函数向内核（<strong>kernel</strong>）发起系统调⽤，上下⽂从⽤户态（<strong>user space</strong>）切换为内核态（<strong>kernel space</strong>）。</li>
<li><code>CPU</code>将读缓冲区（<strong>read buffer</strong>）中的数据拷⻉到的⽹络缓冲区（<strong>socket buffer</strong>）。</li>
<li><strong>CPU</strong>利⽤<strong>DMA</strong>控制器将数据从⽹络缓冲区（<strong>socket buffer</strong>）拷⻉到⽹卡进⾏数据传输。</li>
<li>上下⽂从内核态（<strong>kernel space</strong>）切换回⽤户态（<strong>user space</strong>），<code>write</code> 系统调⽤执⾏返回。</li>
</ol>
<p>　　mmap 主要的⽤处是提⾼ I/O 性能，特别是针对⼤⽂件。对于⼩⽂件，内存映射⽂件反⽽会导致碎⽚空间的浪费，因为内存映射总是要对⻬⻚边界，最⼩单位是 4 KB，⼀个 5 KB 的⽂件将会映射占⽤ 8KB 内存，也就会浪费 3 KB 内存。</p>
<p>　　<em>mmap 的拷⻉虽然减少了 1 次拷⻉，提升了效率，但也存在⼀些隐藏的问题。当 mmap ⼀个⽂件<strong>时，如果这个⽂件被另⼀个进程所截获，那么 write 系统调⽤会因为访问⾮法地址被 SIGBUS 信号终</strong>⽌，SIGBUS 默认会杀死进程并产⽣⼀个 coredump，服务器可能因此被终⽌。</em></p>
<h3 id="sendFile-优化"><a href="#sendFile-优化" class="headerlink" title="sendFile 优化"></a>sendFile 优化</h3><p><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/sendfile-stream.png"></p>
<p>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</p>
<p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/sendfile-stream1.png"></p>
<p>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</p>
<h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><ol>
<li>零拷⻉是从操作系统⻆度来说的，因为内核缓冲区之前，没有数据的重复（只有 <strong>kernel buffer</strong> 有⼀份数据）。</li>
<li>零拷⻉不仅仅带来了更少的数据复制，还能带来其他的性能优势，例如：更少的上下⽂切换，更少的 <strong>CPU</strong> 缓存伪共享以及⽆ <strong>CPU</strong> 校验和计算。</li>
</ol>
<h3 id="mmap-和-sendFile-的区别"><a href="#mmap-和-sendFile-的区别" class="headerlink" title="mmap 和 sendFile 的区别"></a>mmap 和 sendFile 的区别</h3><ul>
<li><code>mmap</code> 适合⼩数据量读写，<code>sendFile</code> 适合⼤⽂件传输</li>
<li><code>mmap</code> 需要 4 次上下⽂切换、3 次数据拷⻉；<code>sendFile</code> 需要 3 次上下⽂切换、最少 2 次数据拷⻉。</li>
<li><code>sendFile</code> 可以利⽤ <strong>DMA</strong> ⽅式，减少 <strong>CPU</strong> 拷⻉，<code>mmap</code> 则不能（必须从内核拷⻉到 <code>socket</code> 缓冲区）。</li>
<li>在这个选择上：<strong>RocketMQ</strong> 在消费消息时，使⽤了 <code>mmap</code>。<strong>kafka</strong> 使⽤了 <code>sendFIle</code>。</li>
</ul>
<h3 id="NIO-零拷贝案例"><a href="#NIO-零拷贝案例" class="headerlink" title="NIO 零拷贝案例"></a>NIO 零拷贝案例</h3><p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<p><strong>服务器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readcount) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                byteBuffer.rewind(); <span class="comment">//倒带 position = 0 mark 作废</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>传统IO方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;/Users/mac7/IdeaProjects/NettyTutorial/src/main/resources/flame-piper.2016.1080p.bluray.x264[PRiME].mkv&quot;</span>;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">        RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">        raf.read(arr);</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        socketChannel.socket().getOutputStream().write(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 = &quot;</span> + arr.length + <span class="string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Out:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的总的字节数 &#x3D; 521072679 耗时: 542</span><br></pre></td></tr></table></figure>

<p><strong>NIO 零拷贝方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;/Users/mac7/IdeaProjects/NettyTutorial/src/main/resources/flame-piper.2016.1080p.bluray.x264[PRiME].mkv&quot;</span>;</span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在 linux 下一个 transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置=》课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Out:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的总的字节数 &#x3D; 521072679 耗时: 245</span><br></pre></td></tr></table></figure>

<h2 id="Java-AIO-基本介绍"><a href="#Java-AIO-基本介绍" class="headerlink" title="Java AIO 基本介绍"></a>Java AIO 基本介绍</h2><ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a target="_blank" rel="noopener" href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h2 id="BIO、NIO、AIO-对比表"><a href="#BIO、NIO、AIO-对比表" class="headerlink" title="BIO、NIO、AIO 对比表"></a>BIO、NIO、AIO 对比表</h2><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞（多路复用）</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/13/Java-BIO-%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/13/Java-BIO-%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Java BIO 编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-13 11:06:57" itemprop="dateCreated datePublished" datetime="2025-01-13T11:06:57+08:00">2025-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-14 15:59:46" itemprop="dateModified" datetime="2025-01-14T15:59:46+08:00">2025-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是IO模型？"><a href="#什么是IO模型？" class="headerlink" title="什么是IO模型？"></a>什么是IO模型？</h2><p>I/O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能。</p>
<p>在Java中，主要有三种IO模型，分别是同步阻塞IO (<strong>BIO-Blocking I/O</strong>)、同步非阻塞IO (<strong>NIO-non-blocking I/O</strong>)和异步非阻塞IO (<strong>AIO-Asynchronous I/O</strong>)。</p>
<p>先来理解这三者之间的区别：</p>
<ul>
<li><strong>同步阻塞</strong>：服务器在连接客户端时，如果当前没有客户端请求连接，服务器就需要一直等待，阻塞在这里。同理，服务器在接收客户端数据的时候，如果客户端一直没有发送过来，服务器也需要一直等待。</li>
<li><strong>同步非阻塞</strong>：服务器在连接客户端时，如果当前没有客户端请求连接，服务器可以先做其它事情，等一会再来看是否有连接请求。同理，服务器在接收客户端数据的时候，如果客户端一直没有发送过来，服务器可以先处理其它客户端的业务，但仍需要主动检查客户端有没有发送数据。</li>
<li><strong>异步非阻塞</strong>：服务器在连接客户端时，如果当前没有客户端请求连接，服务器可以先做其它事情，当客户端发送了IO请求，os先完成（或监听器）就会通知服务器去进行处理。同理，服务器在接收数据时，也无需等待，当有客户端发送了数据，os（或监听器）会通知服务器去接收数据。</li>
</ul>
<p><strong>BIO</strong> 为同步阻塞，一个连接一个线程，资源要求高，适用于连接少且固定的架构。</p>
<p><strong>NIO</strong> 是同步非阻塞，有 <strong>Channel</strong>、<strong>Buffer</strong>、<strong>Selector</strong> 三大核心，通过多路复用技术，一个线程可处理多个操作，适用于连接多且短的架构。</p>
<p><strong>AIO</strong> 是异步非阻塞，采用 <strong>Proactor</strong> 模式，适用于连接多且长的架构。</p>
<h2 id="Java-BIO基本介绍"><a href="#Java-BIO基本介绍" class="headerlink" title="Java BIO基本介绍"></a>Java BIO基本介绍</h2><ol>
<li><strong>Java BIO</strong>就是传统的<strong>Java IO</strong>编程，其相关的类和接口在<strong>java.io</strong>包下。</li>
<li><strong>BIO</strong>（<strong>Blocking I/O</strong>）：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善。</li>
<li><strong>BIO</strong>方式适用于数据数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<strong>JDK1.4</strong>以前的唯一选择，程序简单易理解。</li>
</ol>
<h2 id="Java-BIO-工作机制"><a href="#Java-BIO-工作机制" class="headerlink" title="Java BIO 工作机制"></a>Java BIO 工作机制</h2><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2025/netty/chapter02_03.png" style="zoom:67%;" />

<h3 id="BIO编程简单流程"><a href="#BIO编程简单流程" class="headerlink" title="BIO编程简单流程"></a>BIO编程简单流程</h3><ol>
<li>服务器启动一个<strong>ServerSocket</strong>。</li>
<li>客户端启动一个<strong>Socket</strong>对服务器进行通信，默认情况下，服务器端需要对每一个客户端建立一个线程与之通信。</li>
<li>客户端发出请求后，先咨询服务器是否有线程相应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<h2 id="Java-BIO应用实例"><a href="#Java-BIO应用实例" class="headerlink" title="Java BIO应用实例"></a>Java BIO应用实例</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><ol>
<li>使用<strong>BIO</strong>模型编写一个服务器端，监听<strong>6666</strong>端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端。</li>
<li>服务端可以接受客户端发送的数据。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是服务端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 创建ServerSocket并且监听6666端口</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 监听---一直等待客户端连接</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 连接来了之后，启用一个线程去执行里面的方法</span></span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取客户端发送过来的输入流</span></span><br><span class="line">                    InputStream inputStream = socket.getInputStream();</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                    <span class="comment">// 读取发送过来的信息并打印</span></span><br><span class="line">                    <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 断开通讯</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个socket，并绑定本地ip及6666端口</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 获取output流</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 向输出流中写入</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello World!&quot;</span>.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码能够看到：在服务端的控制台中能有信息打印出来，且能得出结论：如果客户端一直没有请求发送，则服务端一直在等待；如果发送过来的数据是空的话，就会引起线程的消耗。</p>
<p>上述服务端可以通过线程池机制改善(实现多个客户连接服务器)。</p>
<p>实例说明：</p>
<ol>
<li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端。</li>
<li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li>
<li>代码演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wotzc.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">&quot;read....&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>out</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">服务器启动了</span><br><span class="line">线程信息id &#x3D; 1名字 &#x3D; main</span><br><span class="line">等待连接....</span><br><span class="line">连接到一个客户端</span><br><span class="line">线程信息id &#x3D; 1名字 &#x3D; main</span><br><span class="line">等待连接....</span><br><span class="line">线程信息id &#x3D; 12名字 &#x3D; pool-1-thread-1</span><br><span class="line">线程信息id &#x3D; 12名字 &#x3D; pool-1-thread-1</span><br><span class="line">read....</span><br><span class="line">Hello World!</span><br><span class="line">线程信息id &#x3D; 12名字 &#x3D; pool-1-thread-1</span><br><span class="line">read....</span><br><span class="line">关闭和client的连接</span><br></pre></td></tr></table></figure>

<h2 id="Java-BIO问题分析"><a href="#Java-BIO问题分析" class="headerlink" title="Java BIO问题分析"></a>Java BIO问题分析</h2><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据<strong>读</strong>，业务处理，然后再数据<strong>写</strong>。</li>
<li>当并发数较大时，需要创建大量的线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在<strong>读</strong>操作上，造成线程资源浪费。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8Ajar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8Ajar%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">记一次线上jar包冲突问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-21 14:40:16" itemprop="dateCreated datePublished" datetime="2024-11-21T14:40:16+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-26 17:22:33" itemprop="dateModified" datetime="2024-11-26T17:22:33+08:00">2024-11-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">项目问题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一次在项目开发过程中需要用到加密相关的功能，然后公司就给了一个<strong>jar</strong>包，我们上传私服就通过<strong>pom</strong>引入在项目中。并基于这个新依赖开发相关的功能，我们在本地<strong>IDEA</strong>编译测试都没问题，然后我们打包上传到虚拟机上运行时，调用加密方法的时候会报错，并且错误信息给不了我们任何提示，然后在本地测试却是正常的。</p>
<p><strong>Linux</strong>虚拟机上我们服务的运行方式如下：</p>
<ol>
<li>我们通过本地的<strong>IDEA</strong>把项目打成zip包上传到虚拟机上</li>
<li>我们通过运行启动脚本来启动我们的服务<ul>
<li>启动脚步先把<strong>zip</strong>文件解压到指定的<strong>lib</strong>文件夹</li>
<li>然后用<strong>nohup</strong>命令启动<strong>Java</strong>服务</li>
</ul>
</li>
</ol>
<p>我们通过启动脚本启动我们的服务时，服务起不起来，而且关键的错误信息没有打印。于是我们先调整了日志文件，让关键信息能够打印，调整日志文件后我们看到了关键的错误信息：<code>NoSuchMethodError</code></p>
<p>通过这个错误信息，就很容易想到应该是jar包冲突了，但是很奇怪的就是我们在本地测试没问题，但是部署到虚拟机上就报错，应该是类的加载顺序不一致导致的。</p>
<p><strong>复习一下类加载机制</strong></p>
<p>我们写的 Java 应用代码，一般是通过 <code>App ClassLoader</code> 应用加载器进行加载，它不会自己先去加载它，而是通过 <code>Extension ClassLoader</code> 扩展类加载器进行加载（其中扩展类加载器又会去找 <code>Bootstrap ClassLoader</code> 启动类加载器进行加载），只有父加载器无法加载情况下，才会让下级加载器进行加载。</p>
<blockquote>
<p>★</p>
<p>当一个<strong>ClassLoader</strong>实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器<strong>Bootstrap ClassLoader</strong>试图加载，如果没加载到，则把任务转交给<strong>Extension ClassLoader</strong>试图加载，如果也没加载到，则转交给<strong>App ClassLoader</strong> 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等<strong>URL</strong>中加载该类。如果它们都没有加载到这个类时，则抛出<strong>ClassNotFoundException</strong>异常。</p>
<p>”</p>
</blockquote>
<p><strong>ClassLoader</strong></p>
<p>Java 使用的是双亲委派加载机制，通过查看 <code>ClassLoader</code> 类，可以对此有所了解。</p>
<p>类被成功加载后，将被放入到内存中，内存中存放 <code>Class</code> 实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 首先，检查 class 是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有被加载</span></span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 寻找 parent 加载器</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果父加载器不存在，则委托给启动类加载器加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 如果仍然无法加载，才会尝试自身加载</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类加载顺序</strong></p>
<p>从代码中了解到，如果某个名字的类被加载后，类加载器是不会再重新加载，所以我们的问题根本原因可以是出现在：</p>
<p>我们本地通过IDEA启动时，加载的那个class文件正好是我们需要的使用的，但是当我们在虚拟机上启动的时候，首先加载的那个类是其他jar里面的同名类，并且全类名一样，并非我们需要的。</p>
<p>通过查阅文章：</p>
<blockquote>
<p>★</p>
<p>跟JAR文件的文件名有关。按照字母的顺序加载JAR文件。有了这个类以后，后面的类则不会加载了。</p>
<p>jvm 加载包名和类名相同的类时，先加载classpath中jar路径放在前面的，包名类名都相同，那jvm没法区分了，如果使用ide一般情况下是会提示发生冲突而报错，若不报错，只有第一个包被引入（在classpath路径下排在前面的包），第二个包会在classloader加载类时判断重复而忽略。</p>
<p>”</p>
</blockquote>
<p><strong>查看加载顺序</strong></p>
<p>在 <code>jvm</code> 启动脚本中，添加 <code>-verbose</code> 参数或者 <code>-XX:+TraceClassLoading</code></p>
<p>按理说加载顺序按照<strong>字母顺序</strong>加载，预发环境还是能够跟本地开发一样，加载到我们需要的类。实际上，加载器加载到的是另一个类，导致应用无法启动。</p>
<p>通过查找资料</p>
<blockquote>
<p>★</p>
<p>问题就是jar的加载顺序问题，而这个顺序实际上是由文件系统决定的，linux内部是用inode来指示文件的。</p>
<p>这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<p>Unix/linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>
<p>”</p>
</blockquote>
<hr>
<p><strong>相关知识点</strong></p>
<p><strong>maven</strong>包加载顺序和<strong>jvm</strong>类加载顺序</p>
<p>一、<code>mvaven jar</code>包加载顺序</p>
<p><code>Maven</code>对版本不同的相同依赖包生效优先级：</p>
<ol>
<li>不同依赖层级深度的遵从【最短路径优先】原则。</li>
<li>具有相同依赖层级深度的遵从<code>pom</code>中【最先声明优先】原则。</li>
</ol>
<p>二、<code>JVM</code>类加载顺序</p>
<p>相同的类指：类的全限定名一样<br>问题：怎么优先加载自己写的类</p>
<ol>
<li><p>解析：</p>
<p><code>class</code>文件所在位置， 直接在<code>classpath</code>下，在<code>jar</code>包中：</p>
</li>
</ol>
<ul>
<li>a.相同的类， 一个在工程<code>src</code>路径下， 一个在<code>jar</code>包中： 此时优先加载工程<code>src</code>文件。</li>
<li>b.相同的类， 都在<code>jar</code>包中：此时按照<code>jar</code>的装载顺序，它加载的顺序完全取决于操作系统！</li>
</ul>
<p><code>jar</code>包冲突的解决办法:</p>
<ol>
<li>如果引起冲突类的jar包可以进行排除，在引入的<code>pom</code>文件中进行<code>exclude</code></li>
<li>如果引起冲突的<code>jar</code>包排除了会引起项目启动报错，即两个jar包必须共存<ul>
<li>如果冲突的<code>class</code>文件数量不多，则可以将存在冲突并且我们需要的<code>class</code>文件，从<code>jar</code>中类<code>copy</code>到<code>src</code>目录下</li>
<li>如果冲突的<code>class</code>文件数量很多，上述方式不现实则可以考虑通过<code>maven shade plugin</code>插件改包名</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/15/%E8%A7%A3%E5%86%B3%E5%81%B6%E5%8F%91%E6%80%A7%E7%9A%84502-Bad-Gateway/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/15/%E8%A7%A3%E5%86%B3%E5%81%B6%E5%8F%91%E6%80%A7%E7%9A%84502-Bad-Gateway/" class="post-title-link" itemprop="url">解决偶发性的502 Bad Gateway</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-15 09:45:31" itemprop="dateCreated datePublished" datetime="2024-11-15T09:45:31+08:00">2024-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-19 14:55:51" itemprop="dateModified" datetime="2024-11-19T14:55:51+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HttpClient/" itemprop="url" rel="index"><span itemprop="name">HttpClient</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>现象：</strong></p>
<p>我们在对一些接口进行压测时，会偶发性的出现<strong>502 Bad Gateway</strong> 的报错，大约是2亿笔交易中会有2-3笔出现<strong>502 Bad Gateway</strong> 的报错。</p>
<p><strong>HTTP</strong> 数据流向如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[前置服务] --- [Ingress] --- [网关] --- [聚合服务] --- [基础服务]</span><br></pre></td></tr></table></figure>

<p>我们最开始怀疑这个错误是<strong>ingress</strong>爆出来的，怀疑是<strong>ingress</strong>导致的，然后我们就把<strong>ingress</strong>去掉，继续压测试试，此时的<strong>HTTP</strong>数据流如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[前置服务] --- [网关] --- [聚合服务] --- [基础服务]</span><br></pre></td></tr></table></figure>

<p>此时，<strong>502 Bad Gateway</strong> 的报错虽然没有出现，但是会偶发性的出现<strong>NoHttpResponseException</strong>的报错，大搞也是2亿笔出现3-4笔的<strong>NoHttpResponseException</strong>的报错。然后我们就怀疑<strong>502 Bad Gateway</strong> 报错和<strong>NoHttpResponseException</strong>报错本质上是一样的。</p>
<p><strong>NoHttpResponseException</strong>错误详情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">org.apache.http.NoHttpResponseException: target failed to respond</span><br><span class="line">  at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:<span class="number">141</span>)</span><br><span class="line">  at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:<span class="number">56</span>)</span><br><span class="line">  at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:<span class="number">259</span>)</span><br><span class="line">  at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:<span class="number">163</span>)</span><br><span class="line">  at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:<span class="number">157</span>)</span><br><span class="line">  at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:<span class="number">273</span>)</span><br><span class="line">  at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:<span class="number">125</span>)</span><br><span class="line">  at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:<span class="number">272</span>)</span><br><span class="line">  at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:<span class="number">186</span>)</span><br><span class="line">  at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:<span class="number">89</span>)</span><br><span class="line">  at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:<span class="number">110</span>)</span><br><span class="line">  at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:<span class="number">185</span>)</span><br><span class="line">  at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:<span class="number">83</span>)</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>看一下报错的源代码，相关注释提示服务端主动关闭了连接导致的：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/nohttpresonseexception.png"></p>
<p>通过<strong>WireShark</strong>抓包，我们可以看到的确是服务端已经发送了<code>FIN</code>,而客户端依旧使用了这个链接进行访问，所以就收到了<code>RST</code>，造成整个连接失败。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/tcpdump.png"></p>
<p>遇到问题，首先打开<strong>Debug</strong>日遇到问题，首先打开<strong>Debug</strong>日志，我们可以看到这是因为尝试读数据是没读到，所以链接失败了。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/endofstream.png"></p>
<ul>
<li>查阅<strong>TCP</strong>资料，我们可以知道一般读到<strong>end of stream</strong>都是因为服务端主动关闭连接造成的，此时客户端应该主动关闭连接，而不是继续复用。</li>
<li>通过网络抓包，我们可以看到的确是服务端已经发送了<code>FIN</code>,而客户端依旧使用了这个链接进行访问，所以就收到了<code>RST</code>，造成整个连接失败</li>
</ul>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/wireshark.png"></p>
<p><strong>那么为什么会继续复用已经关闭的链接呢？</strong></p>
<p>我们继续从代码出发，通过日志，我们可以看出每次链接前都有次向连接池请求连接的过程</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/httpclient1.png"></p>
<p>进入连接池管理代码，我们可以看到这边有两次检测是否要关闭:</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/abstractconnpool.png" style="zoom:67%;" />

<p>首先检测有没有配置<code>validateAfterInactivity</code>(默认为<strong>2000ms</strong>),如果超过了指定的时间间隔就进行<code>validate</code></p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/basicconnpool.png" style="zoom:67%;" />

<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/httpclient/bhttpconnectionbase.png" style="zoom:67%;" />

<ul>
<li><code>validate</code>就是尝试读一次(超时<strong>1ms</strong>)来判断有没有失效</li>
<li>如果读到**-1**(<strong>end of stream</strong>)或者发生<strong>IO</strong>异常了就认为失效了</li>
<li>如果超时了就认为还是正常(因为<strong>httpclient</strong>阻塞读)</li>
</ul>
<p>所以出现链接异常会有2种情况</p>
<ol>
<li><strong>keepalive</strong>时间太短，因此<strong>httpClient</strong>以为还能用就没有检测直接使用了，从日志可以看出，根本没有<code>validate</code>过程，在<strong>TCP</strong>的连接上表现为<strong>FIN</strong>后直接发起请求</li>
<li>刚好服务端释放请求时发起访问。如之前例子所示，在服务端还没发送<strong>FIN</strong>是进行了<strong>validate</strong>，但是刚好在正式发送请求前服务端发送了<strong>FIN</strong>，因此造成了<strong>RST</strong>。或者是如下正好在服务端关闭时发送了请求</li>
</ol>
<div class="note info no-icon"><p>就要提一下<strong>Keepalive</strong>机制。<strong>Keepalive</strong>是<strong>HTTP</strong>的连接复用机制，在<strong>HTTP1.0</strong>时代，每个请求经过三次握手后，只会传输一次<strong>HTTP</strong>请求和响应报文后，就进入四次挥手关闭连接了。而<strong>TCP</strong>建立连接和关闭连接的代价是比较大的，导致<strong>HTTP1.0</strong>的通道利用率较低，时延较高。针对这个问题，退出了<strong>Keepalive</strong>机制，一个<strong>TCP</strong>连接建立后，可以在上面发送多个<strong>HTTP</strong>报文，只有这个<strong>TCP</strong>连接的空闲时间达到超时时间，才会被关闭。<strong>HTTP1.1</strong>默认开启<strong>Keepalive</strong>。这里的关闭行为可能发生在客户端和服务端，比如客户端的<strong>Keepalive</strong>超时时间更短，则客户端就会先关闭连接，如果服务端配置的<strong>Keepalive</strong>超时时间更短，则服务端就会先关闭连接。</p>
<p>乍看起来无论那一边关闭连接都没什么问题，但是还是有细节需要注意。比如服务端关闭连接，发送<strong>FIN</strong>包，在这个<strong>FIN</strong>包发送但是还未到达客户端期间，客户端如果继续复用这个<strong>TCP</strong>连接，发送<strong>HTTP</strong>请求报文的话，服务端会因为在四次挥手期间不接收报文而发送<strong>RST</strong>报文给客户端，客户端收到<strong>RST</strong>报文就会提示异常。</p>
</div>

<p><strong>解决办法：</strong></p>
<p>我们调整前置、<code>Ingress</code>以及网关等服务的<code>keep-alive-timeout</code>的时间，确保前置小于<code>Ingress</code>，<code>Ingress</code>小于网关、网关小于聚合。即客户端设置的<code>keep-alive-timeout</code>的时间小于服务端的<code>keep-alive-timeout</code>的时间。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/12/JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/12/JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Java 监控和诊断工具：jps、jstat、jcmd、jmap和jstack</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-12 10:59:28" itemprop="dateCreated datePublished" datetime="2024-11-12T10:59:28+08:00">2024-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-14 14:45:13" itemprop="dateModified" datetime="2024-11-14T14:45:13+08:00">2024-11-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>Java</strong> 应用程序通常在复杂且动态的环境中运行，因此监控其性能并有效诊断问题至关重要。幸运的是，<strong>Java</strong> 开发工具包 (<strong>JDK</strong>) 附带了一套强大的工具来实现此目的。在本指南中，我们将探索四个基本工具：<strong>jps</strong>、<strong>jstat</strong>、<strong>jcmd</strong>、<strong>jmap</strong>和<strong>jstack</strong>。我们将讨论它们的功能、示例用法以及如何有效地解释它们的输出。</p>
<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p><code>jps(Java Process Status)</code> 工具列出本地计算机上的 <strong>Java</strong> 虚拟机 (<strong>JVM</strong>) 进程。它提供进程 ID (<strong>PID</strong>) 和正在执行的主类或 <strong>JAR</strong> 文件等信息。</p>
<p>Usage:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options]</span><br></pre></td></tr></table></figure>

<p>Sample Usage:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">12345 com.example.MainApp</span><br></pre></td></tr></table></figure>

<p>理解输出：</p>
<ul>
<li>第一列表示 <strong>PID</strong></li>
<li>第二列显示主类的完全限定类名或 <strong>JAR</strong> 文件名</li>
</ul>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p><code>jstat (JVM Statistics Monitoring Tool)</code> 是一个命令行工具，提供有关 <strong>JVM</strong> 内部统计信息，例如垃圾收集、类加载、编译器活动等。</p>
<p>Usage:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [options] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure>

<p>Sample Usage:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil 12345 1000 10</span><br></pre></td></tr></table></figure>

<p><code>-gcutil</code> 提供垃圾收集统计数据，每秒统计1次，共统计两次</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) mac7@TZC-Mac ~ % jstat -options</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure>

<p><code>option</code> 选项详解</p>
<ul>
<li><code>-class</code>  用于查看类加载情况的统计 </li>
<li><code>-compiler</code> 用于查看<strong>HotSpot</strong>中即时编译器编译情况的统计 </li>
<li><code>-gc</code> 用于查看<strong>JVM</strong>中堆的垃圾收集情况的统计 </li>
<li><code>-gccapacity</code> 用于查看新生代、老生代及持久代的存储容量情况 </li>
<li><code>-gccause</code> 显示[垃圾回收]的相关信息（同<code>-gcutil</code>）,同时显示最后一次仅当前正在发生的垃圾收集的原因 </li>
<li><code>-gcmetacapacity</code> 用于查看新生代垃圾收集的情况 </li>
<li><code>-gcnew</code> 用于查看新生代存储容量的情况 </li>
<li><code>-gcnewcapacity</code> 用于查看老生代及持久代垃圾收集的情况 </li>
<li><code>-gcold</code>  用于查看老生代及持久代垃圾收集的情况 </li>
<li><code>-gcoldcapacity</code>  用于查看老生代的容量 </li>
<li><code>-gcutil</code> 显示垃圾收集信息 </li>
<li><code>-printcompilation</code> 输出<strong>JIT</strong>编译的方法信息</li>
</ul>
<p><code>interval</code> 参数详解</p>
<ul>
<li>指定输出统计数据的周期，单位毫秒</li>
</ul>
<p><code>count</code> 参数详解</p>
<ul>
<li>一共输出多少次数据</li>
</ul>
<p>Usage:</p>
<p><code>-class</code>命令，每秒统一次<strong>classloader</strong>信息，一共输出 2 次</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -class 21074 1000 2</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  3198  6281.9        0     0.0       0.99</span><br><span class="line">  3198  6281.9        0     0.0       0.99</span><br></pre></td></tr></table></figure>

<p>装载了3198个类，大小6281.9个字节，卸载了0个类，大小0个字节，装载和卸载耗费时间总时间0.99秒</p>
<p><code>-compiler</code>命令，显示<strong>JVM</strong>实时编译的数量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -compiler 21074</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    3920      2       0    10.55          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run</span><br></pre></td></tr></table></figure>

<p>编译任务执行了3920个，失败了2个，失效了0个，编译耗费10.55秒，最后一个编译失败任务的类型为1 ，最后一个编译失败任务所在的方法</p>
<p><code>-gc</code>命令，显示<strong>GC</strong>堆相关信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gc 21074</span><br><span class="line"> S0C    	S1C    	S0U    S1U   EC        EU       OC         OU       MC     	MU    	CCSC   CCSU   	YGC   YGCT    FGC    FGCT     GCT   </span><br><span class="line">12800.0 	12288.0 288.0  0.0   3120640.0 360814.7 1048576.0  17050.0  20608.0 20235.5 2432.0 2280.5 	26    0.129   0      0.000    0.129</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li><p>S0C 年轻代中第一个S区容量（千字节）</p>
</li>
<li><p>S1C 年轻代中第二个S区容量（千字节）</p>
</li>
<li><p>S0U 年轻代中第一个S区已使用的空间（千字节）</p>
</li>
<li><p>S1U 年轻代中第二个S区已使用的空间（千字节）</p>
</li>
<li><p>EC 年轻代中E区容量（千字节）</p>
</li>
<li><p>EU 年轻代中E区使用空间（千字节）</p>
</li>
<li><p>OC old代的容量（千字节）</p>
</li>
<li><p>OU old代已使用空间（千字节）</p>
</li>
<li><p>MC metaspace元空间容量（千字节）</p>
</li>
<li><p>MU metaspace元空间已使用容量（千字节）</p>
</li>
<li><p>CCSC：当前压缩类空间的容量 (千字节)</p>
</li>
<li><p>CCSU：当前压缩类空间目前已使用空间 (千字节)</p>
</li>
<li><p>YGC 应用程序启动到采样时年轻代中GC次数</p>
</li>
<li><p>YGCT 应用程序启动到采样时年轻代中GC所用时间</p>
</li>
<li><p>FGC 应用程序启动到采样老年代GC次数（秒）</p>
</li>
<li><p>FGCT 应用程序启动到采样老年代GC所用时间（秒）</p>
</li>
<li><p>GCT 应用程序从启动到采样GC所用总时间（秒）</p>
</li>
</ul>
<p><code>-gcmetacapacity</code>命令，查看<code>metaspace</code>中对象的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gcmetacapacity 21074</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT   </span><br><span class="line">     0.0  1067008.0    20608.0        0.0  1048576.0     2432.0    31     0    0.000    0.134</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li>MCMN 最小元数据容量</li>
<li>MCMX 最大元数据容量</li>
<li>MC 当前元数据空间大小</li>
<li>CCSMN 最小压缩类空间大小</li>
<li>CCSMX 最大压缩类空间大小</li>
<li>CCSC 当前压缩类空间大小</li>
<li>YGC 从应用程序启动到采样YGC次数</li>
<li>FGC 从应用程序启动到采样FULL GC次数</li>
<li>FGCT 从应用程序到采样FULL GC所用时间</li>
<li>GCT 从应用程序到采样GC总时间</li>
</ul>
<p><code>-gcnew</code>命令，年轻代对象信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gcnew 21074</span><br><span class="line"> S0C    S1C    S0U   S1U   TT MTT	DSS      EC       EU     	YGC     YGCT  </span><br><span class="line">8704.0 9728.0  0.0  288.0  1  15	8704.0 3125760.0 3067072.3  31    0.134</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li><p>S0C 年轻代中第一个S区容量</p>
</li>
<li><p>S1C 年轻代中第二个S区容量</p>
</li>
<li><p>S0U 年轻代中第一个S区已使用容量</p>
</li>
<li><p>S1U 年轻代中第二个S区已使用容量</p>
</li>
<li><p>TT 持有次数限制</p>
</li>
<li><p>MTT 最大持有次数限制</p>
</li>
<li><p>DSS 期望的S区大小</p>
</li>
<li><p>EC 年轻代中E区大小</p>
</li>
<li><p>EU 年轻代中E区已使用大小</p>
</li>
<li><p>YGC 从应用程序启动到采样YGC次数</p>
</li>
<li><p>YGCT 从应用程序启动到采样YGC所用时间</p>
</li>
</ul>
<p><code>-gcnewcapacity</code>命令，年轻代对象信息以及占用量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gcnewcapacity 21074</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line"> 3145728.0  3145728.0  3145728.0 1048576.0   8704.0 1048576.0   8192.0  3144704.0  3128832.0    32     0</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li><p>NGCMN 年轻代初始化大小</p>
</li>
<li><p>NGCMX 年轻代最大容量</p>
</li>
<li><p>NGC 年轻代中当前容量</p>
</li>
<li><p>S0CMX S0最大的容量</p>
</li>
<li><p>S0C 当前S0大小</p>
</li>
<li><p>S1CM S1最大容量</p>
</li>
<li><p>S1C 当前S1大小</p>
</li>
<li><p>ECMX E区最大容量</p>
</li>
<li><p>EC E区当前大小</p>
</li>
<li><p>YGC 从应用程序启动到采样YGC次数</p>
</li>
<li><p>FGC 从应用程序启动到采样FGC次数</p>
</li>
</ul>
<p><code>-gcold</code>命令，老年代对象信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gcold 21074</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT   </span><br><span class="line"> 20608.0  20235.5   2432.0   2280.5   1048576.0     17234.0     32     0    0.000    0.135</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li><p>MC metaspace 元空间最大容量</p>
</li>
<li><p>MU metaspace 元空间当前大小</p>
</li>
<li><p>CCSC 压缩类空间大小</p>
</li>
<li><p>CCSU 压缩类空间当前使用大小</p>
</li>
<li><p>OC 老年代容量</p>
</li>
<li><p>OU 老年代已使用大小</p>
</li>
<li><p>YGC 从应用程序启动到采样YGC次数</p>
</li>
<li><p>FGC 从应用程序启动到采样FGC次数</p>
</li>
<li><p>FGCT 从应用程序启动到采样FGC耗费总时间</p>
</li>
<li><p>GCT 从应用程序启动到采样GC耗费总时间</p>
</li>
</ul>
<p><code>-gcoldcapacity</code>命令，老年代对象占用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gcoldcapacity 21074</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT   </span><br><span class="line">  1048576.0   1048576.0   1048576.0   1048576.0    32     0    0.000    0.135</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li>OGCMN 老年代初始化大小</li>
<li>OGCMX 老年代最大容量</li>
<li>OGC 老年代当前使用大小</li>
<li>OC 老年代容量</li>
</ul>
<p><code>-gcutil</code>命令，统计<strong>GC</strong>情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gcutil 21074</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  2.21   0.00  54.97   1.64  98.19  93.77     32    0.135     0    0.000    0.135</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li>S0 S0区占用比</li>
<li>S1 S1区占用比</li>
<li>E 伊甸园区占用比</li>
<li>O 老年代占用比</li>
<li>M 元空间占用比</li>
<li>CCS 压缩类占用比</li>
<li>YGC YGC发生的次数</li>
<li>YGCT 所有YGC的总共耗时</li>
<li>FGC FGC发生的次数</li>
<li>FGCT 所有FGC的共耗时</li>
<li>GCT 所有GC的总耗时</li>
</ul>
<p><code>-gccause</code>命令，显示<strong>GC</strong>导致的原因</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -gccause 21074</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 </span><br><span class="line">  2.21   0.00  68.95   1.64  98.19  93.77     32    0.135     0    0.000    0.135 Allocation Failure   No GC</span><br></pre></td></tr></table></figure>

<p>大部分字段同<code>-gcutil</code>命令</p>
<p>字段解释：</p>
<ul>
<li>LGCC 上一次GC原因</li>
<li>GCC 当前GC原因</li>
</ul>
<p><code>-printcompilation</code>命令，VM执行的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jstat -printcompilation 21074</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">    3964    311    1 com/alibaba/druid/sql/visitor/SchemaStatVisitor visit</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li>compiled 编译任务的数目</li>
<li>size 方法生成的字节码大小</li>
<li>type 编译类型</li>
<li>method 类名和方法名</li>
</ul>
<hr>
<h1 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h1><p><code>jcmd</code> - 向正在运行的 Java 虚拟机 (<code>JVM</code>) 发送诊断命令请求</p>
<p><code>jcmd</code> [<em>pid</em> | <em>main-class</em> ] <em>command</em> … | <code>PerfCounter.print</code> | <code>-f</code> <em>filename</em></p>
<p><code>jcmd</code> [<code>-l</code> ]</p>
<p><code>jcmd -h</code></p>
<p>查看帮助</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd -h</span><br><span class="line">Usage: jcmd &lt;pid | main class&gt; &lt;<span class="built_in">command</span> ...|PerfCounter.print|-f file&gt;</span><br><span class="line">   or: jcmd -l</span><br><span class="line">   or: jcmd -h</span><br><span class="line"></span><br><span class="line">  <span class="built_in">command</span> must be a valid jcmd <span class="built_in">command</span> <span class="keyword">for</span> the selected jvm.</span><br><span class="line">  Use the <span class="built_in">command</span> <span class="string">&quot;help&quot;</span> to see <span class="built_in">which</span> commands are available.</span><br><span class="line">  If the pid is 0, commands will be sent to all Java processes.</span><br><span class="line">  The main class argument will be used to match (either partially</span><br><span class="line">  or fully) the class used to start Java.</span><br><span class="line">  If no options are given, lists Java processes (same as -p).</span><br><span class="line"></span><br><span class="line">  PerfCounter.print display the counters exposed by this process</span><br><span class="line">  -f  <span class="built_in">read</span> and execute commands from the file</span><br><span class="line">  -l  list JVM processes on the <span class="built_in">local</span> machine</span><br><span class="line">  -h  this <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>查看正在运行的 <strong>Java</strong> 进程<strong>ID</strong>、名称和 <strong>main</strong> 函数参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd</span><br><span class="line">7200 sun.tools.jcmd.JCmd</span><br><span class="line">10614 com.install4j.runtime.launcher.MacLauncher</span><br><span class="line">88348 org.gradle.launcher.daemon.bootstrap.GradleDaemon 2.14</span><br></pre></td></tr></table></figure>

<p>注意，<strong>7200</strong> 进程是<code>jcmd</code>本身。执行完<code>jcmd</code>后，该进程已经结束了。</p>
<p>查看某个进程支持的命令</p>
<p>在<code>jcmd</code> 后加上进程 <strong>ID</strong>，然后加上 <strong>help</strong> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 <span class="built_in">help</span></span><br><span class="line">10614:</span><br><span class="line">The following commands are available:</span><br><span class="line">JFR.configure</span><br><span class="line">JFR.stop</span><br><span class="line">JFR.start</span><br><span class="line">JFR.dump</span><br><span class="line">JFR.check</span><br><span class="line">VM.log</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.check_commercial_features</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">ManagementAgent.status</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">Compiler.directives_clear</span><br><span class="line">Compiler.directives_remove</span><br><span class="line">Compiler.directives_add</span><br><span class="line">Compiler.directives_print</span><br><span class="line">VM.print_touched_methods</span><br><span class="line">Compiler.codecache</span><br><span class="line">Compiler.codelist</span><br><span class="line">Compiler.queue</span><br><span class="line">VM.classloader_stats</span><br><span class="line">Thread.print</span><br><span class="line">JVMTI.data_dump</span><br><span class="line">JVMTI.agent_load</span><br><span class="line">VM.stringtable</span><br><span class="line">VM.symboltable</span><br><span class="line">VM.class_hierarchy</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.finalizer_info</span><br><span class="line">GC.heap_info</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.info</span><br><span class="line">VM.uptime</span><br><span class="line">VM.dynlibs</span><br><span class="line">VM.set_flag</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line"><span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">For more information about a specific <span class="built_in">command</span> use <span class="string">&#x27;help &lt;command&gt;&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p><code>jcmd</code> 后也可以跟上进程名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd MacLauncher <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>输出结果和 <code>jcmd 10614 help</code> 相同。</p>
<p>查看某个进程的 JVM 版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 VM.version</span><br><span class="line">10614:</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM version 9.0.1+11</span><br><span class="line">JDK 9.0.1</span><br></pre></td></tr></table></figure>

<p>查看 JVM 进程信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 VM.info</span><br></pre></td></tr></table></figure>

<p>建议进程进行垃圾回收</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 GC.run</span><br></pre></td></tr></table></figure>

<p>获取类的统计信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 GC.class_histogram | more</span><br></pre></td></tr></table></figure>

<p>可以看到类名、对象数量、占用空间等。</p>
<p>获取启动参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 VM.flags</span><br></pre></td></tr></table></figure>

<p>获取进程到现在运行了多长时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 VM.uptime</span><br></pre></td></tr></table></figure>

<p>查看线程信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 Thread.print</span><br></pre></td></tr></table></figure>

<p>获取性能相关数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 PerfCounter.print</span><br></pre></td></tr></table></figure>

<p>导出堆快照到当前目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 10614 GC.heap_dump <span class="variable">$PWD</span>/heap.dump</span><br></pre></td></tr></table></figure>

<p>堆快照可以使用 <a target="_blank" rel="noopener" href="https://visualvm.github.io/">VisualVM</a> 等工具打开分析。</p>
<hr>
<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p><code>jmap (Memory Map for Java)</code> 为给定的 Java 进程生成与内存相关的信息，包括堆<code>dump</code>和内存使用情况统计信息。</p>
<p>Usage:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>查看一下<code>jmap</code>命令的帮助信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jmap -<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line"><span class="built_in">where</span> &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to <span class="built_in">print</span> same info as Solaris pmap</span><br><span class="line">    -heap                to <span class="built_in">print</span> java heap summary</span><br><span class="line">    -histo[:live]        to <span class="built_in">print</span> histogram of java object heap; <span class="keyword">if</span> the <span class="string">&quot;live&quot;</span></span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to <span class="built_in">print</span> class loader statistics</span><br><span class="line">    -finalizerinfo       to <span class="built_in">print</span> information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap <span class="keyword">in</span> hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; <span class="keyword">if</span> not specified,</span><br><span class="line">                                        all objects <span class="keyword">in</span> the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The <span class="string">&quot;live&quot;</span> suboption is not supported</span><br><span class="line">                         <span class="keyword">in</span> this mode.</span><br><span class="line">    -h | -<span class="built_in">help</span>           to <span class="built_in">print</span> this <span class="built_in">help</span> message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>option</code>： 选项参数</li>
<li><code>pid</code>： 需要打印配置信息的进程<strong>ID</strong></li>
<li><code>executable</code>： 产生核心<strong>dump</strong>的Java可执行文件</li>
<li><code>core</code>： 需要打印配置信息的核心文件</li>
<li><code>server-id</code> 可选的唯一<strong>id</strong>，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器</li>
<li><code>remote server IP or hostname</code> 远程调试服务器的IP地址或主机名</li>
</ul>
<p>这些参数里面一般使用option和pid即可</p>
<ul>
<li><code>no option</code>： 查看进程的内存映像信息，类似Solaris pmap命令</li>
<li><code>heap</code>： 显示Java堆详细信息</li>
<li><code>histo[:live]</code>： 显示堆中对象的统计信息</li>
<li><code>clstats</code>：打印类加载器信息</li>
<li><code>finalizerinfo</code>： 显示在<code>F-Queue</code>队列等待<code>Finalizer</code>线程执行<code>finalizer</code>方法的对象</li>
<li><code>dump</code>:：生成堆转储快照</li>
<li><code>F</code>： 当<code>-dump</code>没有响应时，使用<code>-dump</code>或者<code>-histo</code>参数。在这个模式下，<code>live</code>子参数无效</li>
<li><code>help</code>：打印帮助信息</li>
<li><code>J</code>：指定传递给运行<code>jmap</code>的<code>JVM</code>的参数</li>
</ul>
<p><strong>示例</strong></p>
<ol>
<li><code>jmap -heap pid</code>命令，打印堆内存详细信息</li>
</ol>
<p>打印一个堆的摘要信息，包括使用的<strong>GC</strong>算法、堆配置信息和各内存区域内存使用信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jmap -heap 21074</span><br><span class="line">Attaching to process ID 21074, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)	</span><br><span class="line"></span><br><span class="line">Heap Configuration:										<span class="comment">##堆配置情况，也就是JVM参数配置的结果</span></span><br><span class="line">   MinHeapFreeRatio         = 0							<span class="comment">##最小堆使用比例</span></span><br><span class="line">   MaxHeapFreeRatio         = 100						<span class="comment">##最大堆可用比例</span></span><br><span class="line">   MaxHeapSize              = 4294967296 (4096.0MB)		<span class="comment">##最大堆空间大小</span></span><br><span class="line">   NewSize                  = 3221225472 (3072.0MB)		<span class="comment">##新生代分配大小</span></span><br><span class="line">   MaxNewSize               = 3221225472 (3072.0MB)		<span class="comment">##最大可新生代分配大小</span></span><br><span class="line">   OldSize                  = 1073741824 (1024.0MB)		<span class="comment">##老年代大小</span></span><br><span class="line">   NewRatio                 = 2							<span class="comment">##新生代比例</span></span><br><span class="line">   SurvivorRatio            = 8							<span class="comment">##新生代与suvivor的比例</span></span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)	<span class="comment">##元空间大小</span></span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)		<span class="comment">##压缩类空间大小</span></span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB			<span class="comment">##最大元空间大小</span></span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)					<span class="comment">##G1的region大小</span></span><br><span class="line"></span><br><span class="line">Heap Usage:												<span class="comment">##堆使用情况</span></span><br><span class="line">PS Young Generation										<span class="comment">##新生代（伊甸Eden区 + 幸存者survior（from + to）区）</span></span><br><span class="line">Eden Space:												<span class="comment">##伊甸区</span></span><br><span class="line">   capacity = 3206021120 (3057.5MB)						<span class="comment">##伊甸区容量</span></span><br><span class="line">   used     = 1334298032 (1272.4857635498047MB)			<span class="comment">##已经使用大小</span></span><br><span class="line">   free     = 1871723088 (1785.0142364501953MB)			<span class="comment">##剩余容量</span></span><br><span class="line">   41.61850412264283% used								<span class="comment">##使用比例</span></span><br><span class="line">From Space:												<span class="comment">##survior1区</span></span><br><span class="line">   capacity = 7340032 (7.0MB)							<span class="comment">##survior1区容量</span></span><br><span class="line">   used     = 229376 (0.21875MB)						<span class="comment">##surviror1区已使用情况</span></span><br><span class="line">   free     = 7110656 (6.78125MB)						<span class="comment">##surviror1区剩余容量</span></span><br><span class="line">   3.125% used											<span class="comment">##survior1区使用比例</span></span><br><span class="line">To Space:												<span class="comment">##survior2 区</span></span><br><span class="line">   capacity = 6815744 (6.5MB)							<span class="comment">##survior2区容量</span></span><br><span class="line">   used     = 0 (0.0MB)									<span class="comment">##survior2区已使用情况</span></span><br><span class="line">   free     = 6815744 (6.5MB)							<span class="comment">##survior2区剩余容量</span></span><br><span class="line">   0.0% used											<span class="comment">##survior2区使用比例</span></span><br><span class="line">PS Old Generation										<span class="comment">##老年代使用情况</span></span><br><span class="line">   capacity = 1073741824 (1024.0MB)						<span class="comment">##老年代容量</span></span><br><span class="line">   used     = 17754144 (16.931671142578125MB)			<span class="comment">##老年代已使用容量</span></span><br><span class="line">   free     = 1055987680 (1007.0683288574219MB)			<span class="comment">##老年代剩余容量</span></span><br><span class="line">   1.653483510017395% used								<span class="comment">##老年代使用比例</span></span><br><span class="line"></span><br><span class="line">7111 interned Strings occupying 559016 bytes.			<span class="comment">##系统中使用的字符串总大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>jmap -histo:live pid</code>命令，显示堆中对象的统计信息</li>
</ol>
<p>其中包括每个Java类、对象数量、内存大小(单位：字节)、完全限定的类名。打印的虚拟机内部的类名称将会带有一个<code>*</code>前缀。如果指定了live子选项，则只计算活动的对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ jmap -histo:live 21074</span><br><span class="line"><span class="comment">#编号	#实例个数		#实例总大小 #全限定类名</span></span><br><span class="line">num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:        262144        6291456  org.apache.logging.log4j.core.async.AsyncLoggerConfigDisruptor<span class="variable">$Log4jEventWrapper</span></span><br><span class="line">   2:         16536        2830928  [C</span><br><span class="line">   3:          2622        1197536  [Ljava.lang.Object;</span><br><span class="line">   4:          1547        1122888  [I</span><br><span class="line">   5:           896         675144  [B</span><br><span class="line">   6:         16462         395088  java.lang.String</span><br><span class="line">   7:          3483         393304  java.lang.Class</span><br><span class="line">   8:         20149         322384  java.lang.Integer</span><br><span class="line">   9:          8820         282240  io.mycat.statistic.HeartbeatRecorder<span class="variable">$Record</span></span><br><span class="line">  10:          8954         214896  java.util.concurrent.ConcurrentLinkedQueue<span class="variable">$Node</span></span><br><span class="line">  11:          2007         211264  [Ljava.util.HashMap<span class="variable">$Node</span>;</span><br><span class="line">  12:          5444         174208  java.util.HashMap<span class="variable">$Node</span></span><br><span class="line">  13:          4183         133856  java.util.concurrent.ConcurrentHashMap<span class="variable">$Node</span></span><br><span class="line">  14:          1493         119440  io.mycat.route.RouteResultsetNode</span><br><span class="line">  15:          1959          94032  java.util.HashMap</span><br><span class="line">  16:             2          80560  [Ljava.lang.Integer;</span><br><span class="line">  17:            93          67352  [Ljava.util.concurrent.ConcurrentHashMap<span class="variable">$Node</span>;</span><br><span class="line">  18:          3713          59408  java.lang.Object</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>类名解释如下</p>
<ul>
<li><code>B</code> <code>byte</code></li>
<li><code>C</code> <code>char</code></li>
<li><code>D</code> <code>double</code></li>
<li><code>F</code> <code>float</code></li>
<li><code>I</code> <code>int</code></li>
<li><code>J</code> <code>long</code></li>
<li><code>Z</code> <code>boolean</code></li>
<li>[ 数组，如<code>[I</code>表示<code>int[]</code></li>
<li><code>[L</code>+类名 其他对象</li>
</ul>
<ol start="3">
<li><code>jmap -dump:format=b,file=heapdump.hprof pid</code>命令，<code>dump</code>当前内存快照</li>
</ol>
<p>以<code>hprof</code>二进制格式转储<code>Java</code>堆到指定<code>filename</code>的文件中。<code>live</code>子选项是可选的。如果指定了<code>live</code>子选项，堆中只有活动的对象会被转储。想要浏览heap dump，你可以使用jhat（Java堆分析工具）或者MAT等工具读取生成的文件。</p>
<hr>
<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p><code>jstack</code>（Java Virtual Machine Stack Trace）是JDK提供的一个可以生成Java虚拟机当前时刻的线程快照信息的命令行工具。线程快照一般被称为<strong>threaddump</strong>或者<strong>javacore</strong>文件，是当前Java虚拟机中每个线程正在执行的Java线程、虚拟机内部线程和可选的本地方法堆栈帧的集合。对于每个方法栈帧，将会显示完整的类名、方法名、字节码索引(<strong>bytecode index</strong>，<strong>BCI</strong>)和行号。生成的线程快照可以用于定位线程出现长时间停顿的原因，比如：线程间死锁、死循环、请求外部资源被长时间挂起等等。</p>
<blockquote>
<p>jstack prints Java stack traces of Java threads <strong>for</strong> a given Java process or core file or a remote debug server. </p>
</blockquote>
<ul>
<li><code>jstack</code>命令用于生成虚拟机当前时刻的线程快照。</li>
<li>线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。</li>
<li>线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</li>
<li>如果<strong>java</strong>程序崩溃生成<strong>core</strong>文件，<code>jstack</code>工具可以用来获得<strong>core</strong>文件的<strong>java stack</strong>和<strong>native stack</strong>的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</li>
<li>另外，<code>jstack</code>工具还可以附属到正在运行的<strong>java</strong>程序中，看到当时运行的<strong>java</strong>程序的<strong>java stack</strong>和<strong>native stack</strong>的信息, 如果现在运行的java程序呈现hung的状态，<code>jstack</code>是非常有用的。</li>
</ul>
<p>命令语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [options] pid</span><br></pre></td></tr></table></figure>

<p>命令参数说明：</p>
<ul>
<li><code>option</code>：<code>jstack</code>命令的可选参数。如果没有指定这个参数，<code>jstack</code>命令会显示<strong>Java</strong>虚拟机当前时刻的线程快照信息：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D:\Desktop&gt;jstack 9348</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281-b09 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;DestroyJavaVM&quot;</span> <span class="comment">#13 prio=5 os_prio=0 tid=0x0000018da5881000 nid=0x34c8 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mythread2&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x0000018dc2547000 nid=0x2580 waiting on condition [0x000000468cdff000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x000000076b8dbf28&gt; (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(Unknown Source)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(Unknown Source)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(Unknown Source)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Unknown Source)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>.lock(Unknown Source)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock.lock(Unknown Source)</span><br><span class="line">        at DeathLock.lambda<span class="variable">$deathLock</span><span class="variable">$1</span>(DeathLock.java:24)</span><br><span class="line">        at DeathLock$<span class="variable">$Lambda</span><span class="variable">$2</span>/1044036744.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Unknown Source)</span><br></pre></td></tr></table></figure>

<p>查看帮助信息</p>
<p>可以通过执行<code>jstack</code> 或者 <code>jstack -h</code>来查看帮助信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ jstack</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to <span class="built_in">print</span> both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -<span class="built_in">help</span> to <span class="built_in">print</span> this <span class="built_in">help</span> message</span><br></pre></td></tr></table></figure>

<p><strong>option参数说明如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-F 当’jstack [-l] pid’没有相应的时候强制打印栈信息</span><br><span class="line">-l 长列表. 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.</span><br><span class="line">-m 打印java和native c/c++框架的所有栈信息.</span><br><span class="line">-h | -<span class="built_in">help</span> 打印帮助信息</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pid 需要被打印配置信息的java进程id,可以用jps查询</strong></p>
</blockquote>
<p><strong>线程状态简介</strong></p>
<p><strong>jstack</strong>用于生成线程快照的，我们分析线程的情况，需要复习一下线程状态</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/jvm/threadstatus.jpg" style="zoom:67%;" />

<p><strong>Java语言定义了6种线程池状态：</strong></p>
<ul>
<li><code>New</code>：创建后尚未启动的线程处于这种状态，不会出现在<strong>Dump</strong>中。</li>
<li><code>RUNNABLE</code>：包括<strong>Running</strong>和<strong>Ready</strong>。线程开启<code>start（）</code>方法，会进入该状态，在虚拟机内执行的。</li>
<li><code>Waiting</code>：无限的等待另一个线程的特定操作。</li>
<li><code>Timed Waiting</code>：有时限的等待另一个线程的特定操作。</li>
<li>阻塞（<code>Blocked</code>）：在程序等待进入同步区域的时候，线程将进入这种状态，在等待监视器锁。</li>
<li>结束（<code>Terminated</code>）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<p><strong>Dump文件的线程状态一般其实就以下3种：</strong></p>
<ul>
<li><code>RUNNABLE</code>，线程处于执行中</li>
<li><code>BLOCKED</code>，线程被阻塞</li>
<li><code>WAITING</code>，线程正在等待</li>
</ul>
<p><strong>Dump 文件分析关注重点</strong></p>
<ul>
<li><code>runnable</code>，线程处于执行中</li>
<li><code>deadlock</code>，死锁（重点关注）</li>
<li><code>blocked</code>，线程被阻塞 （重点关注）</li>
<li><code>Parked</code>，停止</li>
<li><code>locked</code>，对象加锁</li>
<li><code>waiting</code>，线程正在等待</li>
<li><code>waiting to lock</code> 等待上锁</li>
<li><code>Object.wait()</code>，对象等待中</li>
<li><code>waiting for monitor entry</code> 等待获取监视器（重点关注）</li>
<li><code>Waiting on condition</code>，等待资源（重点关注），最常见的情况是线程在等待网络的读写</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/18/Linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/18/Linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BA%8C/" class="post-title-link" itemprop="url">Linux基础教程(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-18 10:38:44" itemprop="dateCreated datePublished" datetime="2024-06-18T10:38:44+08:00">2024-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-12 10:13:41" itemprop="dateModified" datetime="2024-11-12T10:13:41+08:00">2024-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="正则表达式与文件格式化处理"><a href="#正则表达式与文件格式化处理" class="headerlink" title="正则表达式与文件格式化处理"></a>正则表达式与文件格式化处理</h1><p>正则表达式（<strong>Regular Expression</strong> ）是通过一些特殊字符的排列，用来搜索或替换、删除一列或多列文字字符串</p>
<p>本章需要多练习：因为目前很多套件都使用正则表达式来达成过来、分析的目的，为了未来主机管理的便利性，使用者至少要能看懂正则表达式的含义</p>
<h2 id="开始之前：什么是正则表达式"><a href="#开始之前：什么是正则表达式" class="headerlink" title="开始之前：什么是正则表达式"></a>开始之前：什么是正则表达式</h2><ul>
<li><p>什么是正则表达式：</p>
<p>这个就不解释了，某些指令支持，比如 <code>grep &#39;mail&#39; /lib/systemd/system/*</code> 搜索该目录下的所有文件中包含 <strong>mail</strong> 的文件，但是 <strong>cp ls</strong> 等命令不支持正则表达式，只能使用 <strong>bash</strong> 自己本身的通配符</p>
</li>
<li><p>正则表达式对于系统管理员的用途</p>
<p>对于一般使用者来说，使用不多，对于系统管理员来说，是必学的知识，如 错误信息登录文件（第十八章中）的内容记录了系统产生的所有信息，包含是否被入侵的记录数据，可以通过正则表达式将这些登录信息进行处理，仅取出有问题的信息进行分析</p>
</li>
<li><p>正则表达式的广泛用途</p>
<p>由于正则表达式强大的字符串处理能力，一堆软件都支持</p>
</li>
<li><p>正则表达式与 <strong>shell</strong> 在 <strong>Linux</strong> 中的角色定位</p>
<p>这样说吧，小学的 九九乘法表 有多重要，<strong>shell</strong> 与 正则表达式就有多重要</p>
</li>
<li><p>扩展的正则表达式</p>
<p>正则表达式的字符串表示方式依照不同的严谨程度分为：基础正则表达式、扩展正则表达式。</p>
</li>
</ul>
<h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>既然正则表达式是处理字符串的一种表示方式，那么对字符排序有影响的语系数据就会对正则表达式的结果有影响。此外也需要有支持工具程序来辅助才行。</p>
<p>因此这里先介绍一个最简单的字符串摘取工具程序 <strong>grep</strong>。前面讲解了 <strong>grep</strong> 的相关参数与参数，本章着重讲解进阶的 <strong>grep</strong> 选项说明，介绍完 <strong>grep</strong> 的功能后，就进入正则表达式的特殊字符处理能力</p>
<h3 id="语系对正则表达式的影响"><a href="#语系对正则表达式的影响" class="headerlink" title="语系对正则表达式的影响"></a>语系对正则表达式的影响</h3><p>为什么语系数据会影响正则表达式的输出结果？在第 0 章计算器概论的文字编码系统里面谈到，文件其实记录的仅有 <strong>0</strong> 与 <strong>1</strong>，我们看到的字符与数值都是通过编码表转换来的。</p>
<p>由于不同语系的编码数据不同，就会造成数据处理结果的差异了，举例说明，假设两种语系输出结果为：</p>
<ul>
<li><strong>LANG=C：0 1 2 3 … A B C D ..Z a b c d .. z</strong></li>
<li><strong>LANG=zh_TW ：0 1 2 3 … a A b c C D .. z Z</strong></li>
</ul>
<p>两种语系明显不一样，如果想获取大写字符使用 <code>[A-Z]</code>时，会发现 <strong>C</strong> 可以获取到正确的大写字符（因为是连续的），<strong>zh_TW</strong> 连同小写也会 b-z 也会获取到，因为就编码的顺序来看，<strong>big5</strong> 语系可以获取到 <code>A b B c C .. z Z</code> 这一堆字符。</p>
<p>所以使用正则表达式时，需要留意当前的语系，否则可能发现与别人不同的截取结果</p>
<p>由于一般我们再联系正则表达式时，使用的是兼容于 <strong>POSIX</strong> 的标准，因此就使用 <strong>C</strong> 这个语系，因此下面的练习都是使用 <code>LANG=C</code>来练习的。为了避免这样编码所造成的英文与数字截取问题，因此特殊符号需要了解下</p>
<ul>
<li><code>[:alnum:]</code>：代表英文大小写字符及数字，即 <strong>0-9</strong>、<strong>A-Z</strong>、<strong>a-z</strong></li>
<li><code>[:alpha:]</code>：代表任何英文大小写字符，<strong>A-Z</strong>、<strong>a-z</strong></li>
<li><code>[:blank:]</code>：代表空格与 <strong>tab</strong></li>
<li><code>[:cntrl:]</code>：代表键盘上面的控制按键，包括 <strong>CR</strong>、<strong>LF</strong>、<strong>TAB</strong>、<strong>Del</strong> 等</li>
<li><code>[:digit:]</code>：代表数字，<strong>0-9</strong></li>
<li><code>[:graph:]</code>：除了空格符（空格键与 <strong>tab</strong> 键）外其他的所有按键</li>
<li><code>[:lower:]</code>：代表些小字符，<strong>a-z</strong></li>
<li><code>[:print:]</code>：代表任何可以被打印出来的字符</li>
<li><code>[:punct:]</code>：代表标点符号（<strong>punctuation symbol</strong>）</li>
<li><code>[:upper:]</code>：代表大写字符，<strong>A-Z</strong></li>
<li><code>[:space:]</code>：任何会产生空白的字符，包括空格、<strong>tab</strong>、<strong>CR</strong> 等</li>
<li><code>[:xdigit:]</code>：代表 <strong>16</strong> 进制的数值类型，包括 <strong>0-9</strong>、<strong>A-F</strong>、<strong>a-f</strong> 的数字与字符</li>
</ul>
<p>尤其是 <code>[:alnum:]</code>、<code>[:alpha:]</code>、<code>[:upper:]</code>、<code>[:lower:]</code>、<code>[:digit:]</code>一定要知道代表什么意思，因为他们要比 <strong>a-z</strong> 或 <strong>A-Z</strong> 的用途要确定。</p>
<h3 id="grep-的一些进阶选项"><a href="#grep-的一些进阶选项" class="headerlink" title="grep 的一些进阶选项"></a>grep 的一些进阶选项</h3><p>在第十章 <strong>BASH</strong> 中的 <strong>grep</strong> 谈论过一些基础用法，下面列出较进阶的 <strong>grep</strong> 选项与参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep [-A] [-B] [--color=<span class="string">&#x27;auto&#x27;</span>] <span class="string">&#x27;关键词&#x27;</span> filename</span><br><span class="line"></span><br><span class="line">-A：后面可以加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来</span><br><span class="line">-B：后面可以加数字，为 befer 的意思，处理列出该行外，前面的 n 行也列出来</span><br><span class="line">--colort=auto：可将正确的哪个截取数据列出颜色</span><br></pre></td></tr></table></figure>

<p>实践与练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：用 dmesg 列出核心信息，再以 grep 找出含有 qx1 那一行</span></span><br><span class="line">dmesg | grep <span class="string">&#x27;qx1&#x27;</span></span><br><span class="line"><span class="comment"># 笔者不知道自己使用的显卡是什么，而且使用的是虚拟机，而作者使用的显卡是 qx1，所以查看显卡信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：用 --color=auto 显示查找到的关键词高亮,并显示行号</span></span><br><span class="line">dmesg | grep -n --color=auto ‘qx1’</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：在关键词所在行的前两行与后三行也一起显示出来</span></span><br><span class="line">dmest | grep -n -A2 -B3 --color=auto <span class="string">&#x27;qx1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>grep</strong> 是一个很常见也很常用的指令，最重要的功能就是进行字符串的比对，然后将符合用户需求的字符串打印出来。需要注意的是：<strong>grep</strong> 是已整行为单位来进行数据截取的</p>
<h3 id="基础正则表达式练习"><a href="#基础正则表达式练习" class="headerlink" title="基础正则表达式练习"></a>基础正则表达式练习</h3><p>要了解正则表达式最简单的方法就是由实际练习去感受，所以在汇总特殊符号前，先以下面这个文件的内容来进行正则表达式的练习，练习前提为：</p>
<ul>
<li>语系已经使用 <code>export LANG=C；export LC_ALL=C</code></li>
<li><strong>grep</strong> 已经使用 <strong>alias</strong> 设置为 <code>grep --color=auto</code></li>
</ul>
<p>本机默认为 <code>LANG=en_US.UTF-8;LC_ALL=</code></p>
<p>文件为 <strong>regular——express.txt</strong> ，该文件内容是在 <strong>windows</strong> 系统下编辑的，所以包含 <strong>dos</strong> 的换行符；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">apple is my favorite food.</span><br><span class="line">Football game is not use feet only.</span><br><span class="line">this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">However, this dress is about $ 3183 dollars.</span></span><br><span class="line"><span class="string">GNU is free air not free beer.</span></span><br><span class="line"><span class="string">Her hair is very beauty.</span></span><br><span class="line"><span class="string">I can&#x27;</span>t finish the <span class="built_in">test</span>.</span><br><span class="line">Oh! The soup taste good.</span><br><span class="line">motorcycle is cheap than car.</span><br><span class="line">This window is clear.</span><br><span class="line">the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line">Oh!	My god!</span><br><span class="line">The gd software is a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">You are the best is mean you are the no. 1.</span><br><span class="line">The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">I like dog.</span><br><span class="line">google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">goooooogle yes!</span><br><span class="line">go! go! Let<span class="string">&#x27;s go.</span></span><br><span class="line"><span class="string"># I am VBird</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p><strong>范例 1：搜索特定字符</strong></p>
<p>从文件中取得 <strong>the</strong> 这个特定字符串，最简单的方式如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">8:I can<span class="string">&#x27;t finish the test.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="string">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br></pre></td></tr></table></figure>

<p>反向选择，可以看到输出结果少了上面的 <strong>8、12、15、16、18</strong> 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -vn <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">4:this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">5:However, this dress is about $ 3183 dollars.</span></span><br><span class="line"><span class="string">6:GNU is free air not free beer.</span></span><br><span class="line"><span class="string">7:Her hair is very beauty.</span></span><br><span class="line"><span class="string">9:Oh! The soup taste good.</span></span><br><span class="line"><span class="string">10:motorcycle is cheap than car.</span></span><br><span class="line"><span class="string">11:This window is clear.</span></span><br><span class="line"><span class="string">13:Oh!  My god!</span></span><br><span class="line"><span class="string">14:The gd software is a library for drafting programs.</span></span><br><span class="line"><span class="string">17:I like dog.</span></span><br><span class="line"><span class="string">19:goooooogle yes!</span></span><br><span class="line"><span class="string">20:go! go! Let&#x27;</span>s go.</span><br><span class="line">21:<span class="comment"># I am VBird</span></span><br><span class="line">22:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>忽略大小写 ，多出来几行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -<span class="keyword">in</span> <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">8:I can<span class="string">&#x27;t finish the test.</span></span><br><span class="line"><span class="string">9:Oh! The soup taste good.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">14:The gd software is a library for drafting programs.</span></span><br><span class="line"><span class="string">15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="string">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br></pre></td></tr></table></figure>

<p><strong>范例 2：利用中括号<code>[]</code>来搜索集合字符</strong></p>
<p>如果要搜索 test 或 taste 这两个单词时，可以发现他们其实有共同的 <code>t?st</code> 存在</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n &#x27;t[ae]st&#x27; regular_express.txt</span><br><span class="line">8:I can&#x27;t finish the test.</span><br><span class="line">9:Oh! The soup taste good.</span><br></pre></td></tr></table></figure>

<p>中括号中，无论几个字符都表示任意一个字符。如果想要搜索到所有 <strong>oo</strong> 字符时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;oo&#x27;</span> regular_express.txt</span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure>

<p>如果不想要 <strong>oo</strong> 前面的 <strong>g</strong> 呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[^g]oo&#x27;</span> regular_express.txt</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure>

<p>会发现可能会有一部分是正确的，一部分是错误的，比如 <strong>1</strong>、<strong>9</strong> 行少了，但是 <strong>google</strong> 和 <strong>goooooogle</strong> 还是出来了，是怎么回事？第 <strong>18</strong> 行，出现了 <strong>tools</strong> 所以也符合 <code>[^g]oo</code>，而 <strong>19</strong> 行，中间有那么多的 <strong>oo</strong>，也符合</p>
<p>继续，不想要 <strong>oo</strong> 前面是小写字符的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于小写字符的 ASCII 编码顺序是连续的，所以可以简化为，否则就需要把 a-z 都写出来</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[^a-z]oo&#x27;</span> regular_express.txt</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得有数字那一行</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[0-9]&#x27;</span> regular_express.txt</span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于考虑到语系对于编码顺序的影响，因此除了连续编码使用减号 <code>-</code>，还可以使用如下的方法来取得前面两个测试的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[^[:lower:]]oo&#x27;</span> regular_express.txt</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line"></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[[:digit:]]&#x27;</span> regular_express.txt</span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br></pre></td></tr></table></figure>

<p><strong>范例 3：行首与行尾字符</strong> <code>^、$</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只要行首是 the 的</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^the&#x27;</span> regular_express.txt </span><br><span class="line">12:the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要行首是小写字符开头的</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^[a-z]&#x27;</span> regular_express.txt </span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">4:this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">10:motorcycle is cheap than car.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br><span class="line"><span class="string">19:goooooogle yes!</span></span><br><span class="line"><span class="string">20:go! go! Let&#x27;</span>s go.</span><br><span class="line"><span class="comment"># 下面的等效</span></span><br><span class="line"><span class="comment"># [mrcode@study tmp]$ grep -n &#x27;^[[:lower:]]&#x27; regular_express.txt </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要英文字母开头的</span></span><br><span class="line"><span class="comment"># ^ 在中括号内表示反选，在外表示定位首航</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^[^a-zA-Z]&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">21:<span class="comment"># I am VBird</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>行尾练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出行尾为 . 符号的数据</span></span><br><span class="line"><span class="comment"># 使用 \ 对 小数点转义</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;\.$&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">4:this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">5:However, this dress is about $ 3183 dollars.</span></span><br><span class="line"><span class="string">6:GNU is free air not free beer.</span></span><br><span class="line"><span class="string">7:Her hair is very beauty.</span></span><br><span class="line"><span class="string">8:I can&#x27;</span>t finish the <span class="built_in">test</span>.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">10:motorcycle is cheap than car.</span><br><span class="line">11:This window is clear.</span><br><span class="line">12:the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">17:I like dog.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">20:go! go! Let<span class="string">&#x27;s go.</span></span><br></pre></td></tr></table></figure>

<p>这里需要说一句，原本的文件 <strong>5-9</strong> 行默认是 <code>.^M$</code> 结尾的，也就是 <code>\r\n</code>，由于没有网络，无法下载文件，所以复制粘贴丢失了这些换行符，和书上结果不一样。</p>
<p>也就是说上面的示例 <strong>5-9</strong> 不应该出来的，使用命令查看特殊字符应该如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ cat -An regular_express.txt | head -n 10 | tail -n 6</span><br><span class="line">     5  However, this dress is about $ 3183 dollars.^M$</span><br><span class="line">     6  GNU is free air not free beer.^M$</span><br><span class="line">     7  Her hair is very beauty.^M$</span><br><span class="line">     8  I can<span class="string">&#x27;t finish the test.^M$</span></span><br><span class="line"><span class="string">     9  Oh! The soup taste good.^M$</span></span><br><span class="line"><span class="string">    10  motorcycle is cheap than car.$		# 但实际上 ^M 被丢失了</span></span><br></pre></td></tr></table></figure>

<p>找出空白行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^$&#x27;</span> regular_express.txt </span><br><span class="line">22:</span><br><span class="line"><span class="comment"># 只有行首和行尾的表示法，中间没有任何字符，所以是 ^$</span></span><br></pre></td></tr></table></figure>

<p>假设你已经知道 <strong>shell script</strong> 或则是配置文件中，空白行与开头为 <strong>#</strong> 的那一行是批注，想要将这些数据忽略掉，该怎么做？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ cat -n /etc/rsyslog.conf </span><br><span class="line"><span class="comment"># 在 centOS 7 中可以看到有 91 行，有大量的空行与批注信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种写法：-v &#x27;^$&#x27; 是反选，也就是排除空行的，-v ‘^#’ 排除开头是 # 号的</span></span><br><span class="line"><span class="comment"># 但是这里的行号与源文件对不上了，后面的行号是针对前面排除空行后的行号</span></span><br><span class="line">[mrcode@study tmp]$ grep -v <span class="string">&#x27;^$&#x27;</span> /etc/rsyslog.conf | grep -vn <span class="string">&#x27;^#&#x27;</span></span><br><span class="line">6:<span class="variable">$ModLoad</span> imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span><br><span class="line">7:<span class="variable">$ModLoad</span> imjournal <span class="comment"># provides access to the systemd journal</span></span><br><span class="line">18:<span class="variable">$WorkDirectory</span> /var/lib/rsyslog</span><br><span class="line">20:<span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span><br><span class="line">25:<span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span><br><span class="line">28:<span class="variable">$OmitLocalLogging</span> on</span><br><span class="line">30:<span class="variable">$IMJournalStateFile</span> imjournal.state</span><br><span class="line">37:*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages</span><br><span class="line">39:authpriv.*                                              /var/<span class="built_in">log</span>/secure</span><br><span class="line">41:mail.*                                                  -/var/<span class="built_in">log</span>/maillog</span><br><span class="line">43:cron.*                                                  /var/<span class="built_in">log</span>/cron</span><br><span class="line">45:*.emerg                                                 :omusrmsg:*</span><br><span class="line">47:uucp,news.crit                                          /var/<span class="built_in">log</span>/spooler</span><br><span class="line">49:local7.*                                                /var/<span class="built_in">log</span>/boot.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种实现：直接匹配行首非 # 开头的</span></span><br><span class="line"><span class="comment"># 因为使用了中括号表示需要有一个字符存在，所以空行的不会被匹配</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;^[^#]&#x27;</span> /etc/rsyslog.conf </span><br><span class="line">9:<span class="variable">$ModLoad</span> imuxsock <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span><br><span class="line">10:<span class="variable">$ModLoad</span> imjournal <span class="comment"># provides access to the systemd journal</span></span><br><span class="line">26:<span class="variable">$WorkDirectory</span> /var/lib/rsyslog</span><br><span class="line">29:<span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span><br><span class="line">36:<span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf</span><br><span class="line">40:<span class="variable">$OmitLocalLogging</span> on</span><br><span class="line">43:<span class="variable">$IMJournalStateFile</span> imjournal.state</span><br><span class="line">54:*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages</span><br><span class="line">57:authpriv.*                                              /var/<span class="built_in">log</span>/secure</span><br><span class="line">60:mail.*                                                  -/var/<span class="built_in">log</span>/maillog</span><br><span class="line">64:cron.*                                                  /var/<span class="built_in">log</span>/cron</span><br><span class="line">67:*.emerg                                                 :omusrmsg:*</span><br><span class="line">70:uucp,news.crit                                          /var/<span class="built_in">log</span>/spooler</span><br><span class="line">73:local7.*                                                /var/<span class="built_in">log</span>/boot.log</span><br></pre></td></tr></table></figure>

<p>这里要注意的是批注可以出现在任意处，所以匹配行首的是最安全的做法</p>
<h3 id="范例-4：任意一个字符-与重复字符"><a href="#范例-4：任意一个字符-与重复字符" class="headerlink" title="范例 4：任意一个字符 . 与重复字符 *"></a>范例 4：任意一个字符 <code>.</code> 与重复字符 <code>*</code></h3><p>在第十章 <strong>bash</strong> 中，通配符 <code>*</code>表示任意（0 或 多个）字符，但是正则表达式中并不是这样，他们含义如下：</p>
<ul>
<li><code>.</code>：一定有一个任意字符</li>
<li><code>*</code>：重复前一个字符，0 到任意次，为组合形态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出 g??d 的字符串，也就是 g 开头 d 结尾的 4 字符的字符串</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;g..d&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 oo、ooo、ooo 等数据，至少含有 2 个 o</span></span><br><span class="line"><span class="comment"># 注意，这里不能写 oo* 因为，*是作用于第二个 o 的，表示 0 到任意个</span></span><br><span class="line"><span class="comment"># 也就是说如果是 oo* 有可能匹配到一个 o </span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;ooo*&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 开头与结尾都是 g ，并且中间至少含有一个 o 的数据</span></span><br><span class="line"><span class="comment"># 也就是 gog、goog 之类的数据</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;goo*g&#x27;</span> regular_express.txt </span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 开头与结尾都是 g，中间有无字符均可</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;g*g&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">13:Oh!  My god!</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">17:I like dog.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line">20:go! go! Let<span class="string">&#x27;s go.</span></span><br><span class="line"><span class="string"># 使用 g*g 发现第一行的数据就不匹配，这个还是需要再终端看，因为可以开启高亮，方便查看哈</span></span><br><span class="line"><span class="string"># 原因是 * 作用于 g，g* 代表空字符或一个以上的 g，因此应该匹配 g、gg、ggg 等</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 正确的应该这样实现</span></span><br><span class="line"><span class="string">[mrcode@study tmp]$ grep -n &#x27;</span>g.*g<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span></span><br><span class="line"><span class="string">14:The gd software is a library for drafting programs.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br><span class="line"><span class="string">19:goooooogle yes!</span></span><br><span class="line"><span class="string">20:go! go! Let&#x27;</span>s go.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出包含任意数字的数据</span></span><br><span class="line"><span class="comment"># 同上，[0-9]* 只作用于一个中括号</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;[0-9][0-9]*&#x27;</span> regular_express.txt </span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line"><span class="comment"># 直接使用 grep -n &#x27;[0-9]&#x27; regular_express.txt 也可以得到相同结果哈</span></span><br></pre></td></tr></table></figure>

<h3 id="范例-5：限定连续-正则字符范围"><a href="#范例-5：限定连续-正则字符范围" class="headerlink" title="范例 5：限定连续 正则字符范围 {}"></a>范例 5：限定连续 正则字符范围 <code>&#123;&#125;</code></h3><p>找出 <strong>2</strong> 个到 <strong>5</strong> 个 <strong>o</strong> 的连续字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 华括弧在 shell 中是特殊符号，需要转义</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;o\&#123;2\&#125;&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line"><span class="comment"># 上述结果是至少是 2 个 oo 的出来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单词开头结尾都是 g，中间 o，至少 2 个，最多 5 个</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;go\&#123;2,5\&#125;g&#x27;</span> regular_express.txt </span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 承上，只是中间的 o 至少 2 个</span></span><br><span class="line">[mrcode@study tmp]$ grep -n <span class="string">&#x27;go\&#123;2,\&#125;g&#x27;</span> regular_express.txt </span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure>

<h2 id="基础正则表示法字符汇总"><a href="#基础正则表示法字符汇总" class="headerlink" title="基础正则表示法字符汇总"></a>基础正则表示法字符汇总</h2><ul>
<li><p><code>^word</code>：搜索的关键词 <strong>word</strong> 在行首</p>
<p>范例：搜索行首为 <strong>#</strong> 的，并列出行号 <code>grep -n &#39;^#&#39; file</code></p>
</li>
<li><p><code>word$</code>：搜索的关键词 <strong>word</strong> 在行尾</p>
<p>范例：搜索以 ！结尾的，<code>grep -n &#39;!$&#39; file</code></p>
</li>
<li><p><code>.</code>：一定有一个任意字符</p>
<p>范例：搜索字符串可以是 <strong>eve</strong>、<strong>eae</strong>、<strong>eee</strong>、<strong>e e</strong>；<code>grep -n &#39;e.e&#39; file</code></p>
</li>
<li><p><code>\</code>：转义字符</p>
<p>范例：搜索含有单引号数据。<code>grep -n &#39;\’&#39; file</code></p>
</li>
<li><p><code>*</code>：重复另个到无穷多个前一个字符</p>
<p>范例：找出含有 <strong>es</strong>、<strong>ess</strong>、<strong>esss</strong> 等字符串；<code>grep -n &#39;es*&#39; file</code></p>
</li>
<li><p><code>[list]</code>：里面列出想要截取的字符合集</p>
<p>范例：找出含有 <strong>g1</strong> 或 <strong>gd</strong> 的数据；<code>grep -n &#39;g[1d]&#39; file</code></p>
</li>
<li><p><code>[n1-n2]</code>：字符合集范围</p>
<p>范例：找出含有任意大写字母的数据；<code>grep -n &#39;[A-Z]&#39; file</code></p>
</li>
<li><p><code>[^list]</code>：不要包含该集合中的字符或该范围的字符</p>
<p>范例：找出 <strong>ooa</strong>、<strong>oog</strong> 但是不包含 <strong>oot</strong> 的数据; <code>grep -n &#39;oo[^t]&#39;</code></p>
</li>
<li><p><code>\&#123;n,m\&#125;</code>：连续 <strong>n</strong> 到 <strong>m</strong> 个前一个字符</p>
</li>
<li><p><code>\&#123;n\&#125;</code>：连续 <strong>n</strong> 个前一个字符</p>
</li>
<li><p><code>\&#123;n,\&#125;</code>：至少 <strong>n</strong> 个以上的前一个字符；咋效果上感觉和 <code>\&#123;n\&#125;</code> 是一样的</p>
</li>
</ul>
<p>最后再强调，通配符和正则表达式不一样，比如在 <strong>ls</strong> 命令中找出以 <strong>a</strong> 开头的文件</p>
<ul>
<li>通配符：<code>ls -l a*</code></li>
<li>正则表达式：<code>ls | grep -n &#39;^a&#39;</code> 或则 <code>ls | grep -n &#39;^a.*&#39;</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例：以 ls -l 配合 grep 找出 /etc/ 下文件类型为链接文件属性的文件名</span></span><br><span class="line"><span class="comment"># 符号链接文件的特点是权限前面一位是 l，根据 ls 的输出，只要找到行首为 l 的即可</span></span><br><span class="line">[mrcode@study tmp]$ ls -l /etc | grep <span class="string">&#x27;^l&#x27;</span></span><br><span class="line">lrwxrwxrwx.  1 root root       56 Oct  4 18:22 favicon.png -&gt; /usr/share/icons/hicolor/16x16/apps/fedora-logo-icon.png</span><br><span class="line">lrwxrwxrwx.  1 root root       22 Oct  4 18:23 grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>

<h3 id="sed-工具"><a href="#sed-工具" class="headerlink" title="sed 工具"></a>sed 工具</h3><p>了解了一些正则基础使用后，可以来玩一玩 <strong>sed</strong> 和 <strong>awk</strong> ；作者就利用他们两个实现了一个小工具：<strong>logfile.sh</strong> 分析登录文件（第十八章会讲解）。里面绝大部分关键词的提取、统计等都是通过他们来完成的</p>
<p><strong>sed</strong>：本身是一个管线命令，可以分析 <strong>standard input</strong> 的数据，还可以将数据进行替换、新增、截取特定行等功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed [-nefr] [动作]</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><p><strong>n</strong>：使用安静（<strong>silent</strong>）模式</p>
<p>在一般 <strong>sed</strong> 的用法中，所有来自 <strong>STDIN</strong> 的数据一般都会列出到屏幕上，加上 <strong>-n</strong> 之后，只有经过 <strong>sed</strong> 特殊处理的那一行（或则动作）才会被打印出来</p>
</li>
<li><p><strong>e</strong>：直接在指令模式上进行 <strong>sed</strong> 的动作编辑</p>
</li>
<li><p><strong>f</strong>：直接将 <strong>sed</strong> 的动作写在一个文件内，<code>- f filename</code> 则可以执行 <strong>filename</strong> 内的 <strong>sed</strong> 动作</p>
</li>
<li><p><strong>r</strong>：<strong>sed</strong> 的动作支持是延伸类型正则表达式的语法（预设是基础正则表达式语法）</p>
</li>
<li><p><strong>i</strong>：直接修改读取的文件内容，而不是由屏幕输出</p>
</li>
</ul>
<p>动作说明：<code>[n1[,n2]]function</code></p>
<p><code>n1,n2</code>：不见得会存在，一般代表「选择进行动作的行数」，比如：如果我的动作是需要再 <strong>10</strong> 到 <strong>20</strong> 行之间进行的，则「10,20[动作行为]」</p>
<p><strong>function</strong> 有如下：</p>
<ul>
<li><strong>a</strong>：新增，<strong>a</strong> 后面可以接字符串，这些字符串会在新的一行出现（当前的下一行）</li>
<li><strong>c</strong>：替换，<strong>c</strong> 后面可以接字符串，这些字符串替换 <strong>n1,n2</strong> 之间的行</li>
<li><strong>d</strong>：删除，后面不接任何字符串</li>
<li><strong>i</strong>：插入，<strong>i</strong> 的后面可以接字符串，而这些字符串会在新的一行出现（当前的上一行）</li>
<li><strong>p</strong>：打印，将某个选择的数据打印。通常 <strong>p</strong> 会参与 <strong>sed -n</strong> 一起运作</li>
<li><strong>s</strong>：替换，可以直接进行替换工作。通常这个 <strong>s</strong> 的动作可以搭配正则表达式，例如：<code>1,20s/old/new/g</code></li>
</ul>
<h4 id="以行为单位的新增-删除功能"><a href="#以行为单位的新增-删除功能" class="headerlink" title="以行为单位的新增/删除功能"></a><strong>以行为单位的新增/删除功能</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：将 /etc/passwd 的内容列出并且打印行号，同时将第 2~5 行删除</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2,5d&#x27;</span>   	<span class="comment"># 注意写法和结果</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     6  sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line"><span class="comment"># 另外这里，应该带上 sed -e &#x27;2,5d&#x27; 才标准，不过不带也可以，但是需要使用单引号括起来</span></span><br><span class="line"><span class="comment"># 实测不用单引号也可以实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例2：只删除第二行</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2d&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例3：删除第三行到最后一行</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;3,$d&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     2  bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例4：在第二行后（也就是加载第三行）加上「drink tea？」字样</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2a drink tea?&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     2  bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea?</span><br><span class="line">     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例5：在第二行后面加入两行字</span></span><br><span class="line"><span class="comment"># 注意：不要一开始就写好所有的单引号，因为需要使用 \ + 回车触发换行</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2a drink tea \</span></span><br><span class="line"><span class="string">&gt; drink beer?&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     2  bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea </span><br><span class="line">drink beer?</span><br></pre></td></tr></table></figure>

<h4 id="以行为单位的取代显示功能"><a href="#以行为单位的取代显示功能" class="headerlink" title="以行为单位的取代显示功能"></a>以行为单位的取代显示功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：将第 2-5 行的内容替换为 no 2-5 nuber</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed <span class="string">&#x27;2,5c no 2-5 number&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">no 2-5 number</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例2：取出第 11-20 行</span></span><br><span class="line"><span class="comment"># 通过之前的知识来达成需要这样写</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | head -n 20 | tail -n 10</span><br><span class="line">    11  games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">    12  ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">    13  nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">    14  systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">    15  dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">    16  polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">    17  colord:x:998:997:User <span class="keyword">for</span> colord:/var/lib/colord:/sbin/nologin</span><br><span class="line">    18  libstoragemgmt:x:997:995:daemon account <span class="keyword">for</span> libstoragemgmt:/var/run/lsm:/sbin/nologin</span><br><span class="line">    19  rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin</span><br><span class="line">    20  saslauth:x:996:76:Saslauthd user:/run/saslauthd:/sbin/nologin</span><br><span class="line"><span class="comment"># 注意需要使用 -n 只输出 sed 处理过的数据</span></span><br><span class="line">[mrcode@study ~]$ nl /etc/passwd | sed -n <span class="string">&#x27;11,20p&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="部分数据的搜索并替换功能"><a href="#部分数据的搜索并替换功能" class="headerlink" title="部分数据的搜索并替换功能"></a>部分数据的搜索并替换功能</h4><p>除了整行的处理模式外，还可以用行为单位进行部分数据的搜索并替换的功能，基本上 <strong>sed</strong> 的搜索与替换与 <strong>vi</strong> 类似</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/要被替换的字符串/新的字符串/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：先观察原始信息，利用 /sbin/ifconfig 查询 IP</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig </span><br><span class="line">enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line">        inet6 fe80::deb9:3a1b:fd0f:f6c2  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:a0:49:8f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 2436261  bytes 219827411 (209.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2011081  bytes 319310584 (304.5 MiB)</span><br><span class="line"><span class="comment"># 还未讲解到 IP,这里先关注第二行的 IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用关键词配合 grep 截取出关键的一行数据</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span></span><br><span class="line">        inet 192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 ip 前面的信息删除，也就是 inet </span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span> | sed <span class="string">&#x27;s/inet //g&#x27;</span></span><br><span class="line">        192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line"><span class="comment"># 需要使用通配符，不然会留下前面的空白符号：任意字符开头另个或多个</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span> | sed <span class="string">&#x27;s/^.*inet //g&#x27;</span></span><br><span class="line">192.168.0.128  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再删除后续部分，只剩下 192.168.0.128</span></span><br><span class="line"><span class="comment"># 注意这里需要使用：空格任意个，来匹配前面多个空格</span></span><br><span class="line">[mrcode@study ~]$ /sbin/ifconfig enp0s3 | grep <span class="string">&#x27;inet &#x27;</span> | sed <span class="string">&#x27;s/^.*inet //g&#x27;</span> | sed <span class="string">&#x27;s/ *netmask.*$//g&#x27;</span></span><br><span class="line">192.168.0.128</span><br></pre></td></tr></table></figure>

<p>上面例子建议一步一步的来做，下面继续研究 <strong>sed</strong> 与正则表示法配合练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例2：只要 MAN 存在的那几行数据，但是含有 # 在内的批注和空白行不要</span></span><br><span class="line"><span class="comment"># 步骤1：先使用 grep 将关键词 MAN 所在行取出来</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/man_db.conf | grep <span class="string">&#x27;MAN&#x27;</span></span><br><span class="line"><span class="comment"># MANDATORY_MANPATH                     manpath_element</span></span><br><span class="line"><span class="comment"># MANPATH_MAP           path_element    manpath_element</span></span><br><span class="line"><span class="comment"># MANDB_MAP             global_manpath  [relative_catpath]</span></span><br><span class="line"><span class="comment"># every automatically generated MANPATH includes these fields</span></span><br><span class="line"><span class="comment">#MANDATORY_MANPATH                      /usr/src/pvm3/man</span></span><br><span class="line">MANDATORY_MANPATH                       /usr/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/share/man</span><br><span class="line">...省略...</span><br><span class="line"><span class="comment"># 步骤2：删除掉批注数据行</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/man_db.conf | grep <span class="string">&#x27;MAN&#x27;</span> | sed <span class="string">&#x27;s/^#.*$//g&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MANDATORY_MANPATH                       /usr/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/share/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/<span class="built_in">local</span>/share/man</span><br><span class="line"><span class="comment"># 步骤3：删除空白行</span></span><br><span class="line"><span class="comment"># 注意这里使用了动作里面的 d 命令，前面是正则匹配？</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/man_db.conf | grep <span class="string">&#x27;MAN&#x27;</span> | sed <span class="string">&#x27;s/^#.*$//g&#x27;</span> | sed <span class="string">&#x27;/^$/d&#x27;</span></span><br><span class="line">MANDATORY_MANPATH                       /usr/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/share/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/<span class="built_in">local</span>/share/man</span><br></pre></td></tr></table></figure>

<h4 id="直接修改文件内容（危险动作）"><a href="#直接修改文件内容（危险动作）" class="headerlink" title="直接修改文件内容（危险动作）"></a>直接修改文件内容（危险动作）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例1：利用 sed 将 /tmp/regular_express.txt 内每一行结尾若为 . 则换成 ！</span></span><br><span class="line"><span class="comment"># 下面还是使用了动作 s 替换，后面的是转义 . 和 !</span></span><br><span class="line"><span class="comment"># 这样可以直接修改文件内容</span></span><br><span class="line">[mrcode@study tmp]$ sed -i <span class="string">&#x27;s/\./\!/g&#x27;</span> regular_express.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例2：利用 sed 直接在 /tmp/regular_express.txt 最后一行加入 # This is a test</span></span><br><span class="line"><span class="comment"># $ 表示最后一行</span></span><br><span class="line">[mrcode@study tmp]$ sed -i <span class="string">&#x27;$a # This is a test &#x27;</span> regular_express.txt </span><br><span class="line"><span class="comment"># 想要删除最后一行就简单了</span></span><br><span class="line">[mrcode@study tmp]$ sed -i <span class="string">&#x27;$d&#x27;</span> regular_express.txt</span><br></pre></td></tr></table></figure>

<h2 id="延伸正则表示法"><a href="#延伸正则表示法" class="headerlink" title="延伸正则表示法"></a>延伸正则表示法</h2><p>一般来说，只要了解了基础正则表示法大概就已经相当足够了，所谓技多不压身；还可以了解使用范围更广的延伸正则表示法。举个例子：前面讲解到要去除空白行与行首为 <code>#</code> 的行，使用的是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&#x27;^$&#x27;</span> regular_express.txt | grep -v <span class="string">&#x27;^#&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要使用到管线命令来搜寻两次，使用延伸的正则表示法则如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -v <span class="string">&#x27;^$|^#&#x27;</span> regular_express.txt</span><br></pre></td></tr></table></figure>

<p>此外，<strong>grep</strong> 预设仅支持基础的正则表示法，可以使用 <code>-E</code> 参数开启，不过建议用别名 <strong>egrep</strong></p>
<p>下面是延伸正则表示法的符号（RE 字符）说明：</p>
<p><code>+</code>：重复「一个或一个以上」的前一个 RE 字符</p>
<p>范例：搜索 <code>(god)(good)(goood)...</code>等字符串。 可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;go+d&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs!</span><br><span class="line">9:Oh! The soup taste good!</span><br><span class="line">13:Oh!  My god!</span><br></pre></td></tr></table></figure>

<p><code>?</code>：「<strong>0</strong> 个或 <strong>1</strong> 个」的前一个 <strong>RE</strong> 字符</p>
<p>范例：搜索 <strong>gd</strong>、<strong>god</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;go?d&#x27;</span> regular_express.txt </span><br><span class="line">13:Oh!  My god!</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs!</span><br></pre></td></tr></table></figure>

<p><code>|</code>：用或（or）的方式找出数个字符串</p>
<p>范例：搜索 <strong>gd</strong> 或 <strong>good</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;gd|good&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs!</span><br><span class="line">9:Oh! The soup taste good!</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs!</span><br></pre></td></tr></table></figure>

<p><code>()</code>：找出「群组」字符串</p>
<p>范例：搜索 <strong>glad</strong> 或 <strong>good</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当然，这里使用上面完整的或来匹配两个固定单词也是可以的</span></span><br><span class="line">[mrcode@study tmp]$ egrep -n <span class="string">&#x27;g(la)|(oo)d&#x27;</span> regular_express.txt </span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs!</span><br><span class="line">2:apple is my favorite food!</span><br><span class="line">9:Oh! The soup taste good!</span><br><span class="line">16:The world &lt;Happy&gt; is the same with <span class="string">&quot;glad&quot;</span>!</span><br></pre></td></tr></table></figure>

<p><code>()+</code>：多个重复群组的判别</p>
<p>范例：将「<strong>AxyzxyzxyzxyzC</strong>」用 <strong>echo</strong> 叫出，然后再使用如下的方法搜索</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study tmp]$ <span class="built_in">echo</span> <span class="string">&#x27;AxyzxyzxyzxyzC&#x27;</span> | egrep <span class="string">&#x27;A(xyz)&#x27;</span></span><br><span class="line">Axyz xyzxyzxyzC <span class="comment"># 在命令行中是有红色高亮的，这个只能高亮到 Axyz</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">echo</span> <span class="string">&#x27;AxyzxyzxyzxyzC&#x27;</span> | egrep <span class="string">&#x27;A(xyz)+&#x27;</span></span><br><span class="line">Axyzxyzxyzxyz C <span class="comment"># C 不会高亮</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">echo</span> <span class="string">&#x27;AxyzxyzxyzxyzC&#x27;</span> | egrep <span class="string">&#x27;A(xyz)+C&#x27;</span></span><br><span class="line">AxyzxyzxyzxyzC <span class="comment"># 完全匹配</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>TIP</strong></p>
<p>要特别注意：<code>grep -n &#39;[!&gt;]&#39; xx.txt</code> 的含义并不是除了 &gt; 字符之外的字符，因为 <code>!</code> 不是一个特殊符号</p>
<p>想要表示非，需要这样写 <code>grep -n &#39;[^a-z]&#39; xx.txt</code></p>
</blockquote>
<h2 id="文件的格式化与相关处理"><a href="#文件的格式化与相关处理" class="headerlink" title="文件的格式化与相关处理"></a>文件的格式化与相关处理</h2><p>不需要通过 <strong>vim</strong> 去编辑，而是通过数据流重导向配置 <strong>printf</strong> 功能以及 <strong>awk</strong> 指令，可以对文字信息进行排版显示</p>
<h3 id="格式化打印：printf"><a href="#格式化打印：printf" class="headerlink" title="格式化打印：printf"></a>格式化打印：printf</h3><p>比如将考试分数输出，姓名与科目及分数之间，稍微做个比较漂亮的版面，比如输出下面这样的表格</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name		Chinese		Enlish		Math		Average</span><br><span class="line">DmTsai		80				60				92			77.33</span><br><span class="line">VBird			75				55				80			70.00</span><br><span class="line">Ken				60				90				70			73.33</span><br></pre></td></tr></table></figure>

<p>上表数据主要分成 <strong>5</strong> 个字段，每个字段之间可以使用 <strong>tab</strong> 或空格进行分割。将上表存储到 <strong>printf.txt</strong> 文件中，后续会使用到这个文件进行练习。</p>
<p>由于每个字段的长度并不一样，所以要达到上表效果，就需要打印格式管理员 <strong>printf</strong> 来帮忙了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;打印格式&#x27;</span> 实际类容</span><br><span class="line">选项与参数：</span><br><span class="line"> 关于格式方面的几个特殊样式：</span><br><span class="line"> 		\a	警告剩余输出</span><br><span class="line"> 		\b	退格键（backspace）</span><br><span class="line"> 		\f	清楚屏幕（form feed）</span><br><span class="line"> 		\n 	输出新的一行</span><br><span class="line"> 		\r	Enter 按键，换行</span><br><span class="line"> 		\t	水平的 tab 按键</span><br><span class="line"> 		\v	垂直的 tab 按键</span><br><span class="line"> 		\xNN	NN 为两位数的数字，可以转换数字称为字符</span><br><span class="line"> 关于 C 程序语言内，常见的变量格式：</span><br><span class="line"> 		%ns		n 数字，s 表示 string，也就是多少个字符</span><br><span class="line"> 		%ni		n 数字，i 表示 <span class="built_in">integer</span>，多少整数数字</span><br><span class="line"> 		%N.nf 	n 与 N 都是数字，f 表示 floating（浮点），如果有小数，比如共 10 个位数，小数点 2 位数，则写成 %10.2f</span><br></pre></td></tr></table></figure>

<p>下面进行练习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：将上面存储的 printf.txt 内容仅列出姓名与成绩，并且用 tab 分割</span></span><br><span class="line"><span class="comment"># 文件存储时，字段之间全部用 tab 隔开的，复制进去就变成下面展示这样了</span></span><br><span class="line"> [mrcode@study tmp]$ cat printf.txt </span><br><span class="line">Name            Chinese         Enlish          Math            Average</span><br><span class="line">DmTsai          80                              60                              92                      77.33</span><br><span class="line">VBird                   75                              55                              80                      70.00</span><br><span class="line">Ken                             60                              90                              70                      73.33</span><br><span class="line"><span class="comment"># 由于 printf 不是管线命令，需要通过 cat 先提取出来内容</span></span><br><span class="line"><span class="comment"># %s 表示不固定长度的字符串，后面跟了一个空格，并使用横向制表符 \t 来格式化</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">printf</span> <span class="string">&#x27;%s \t %s \t %s \t %s \t %s \t \n &#x27;</span> $(cat printf.txt)</span><br><span class="line">Name     Chinese         Enlish          Math    Average         </span><br><span class="line"> DmTsai          80      60      92      77.33   </span><br><span class="line"> VBird   75      55      80      70.00   </span><br><span class="line"> Ken     60      90      70      73.33 </span><br></pre></td></tr></table></figure>

<p>可以看到上述的效果虽然好多了，但是还是没有对齐。可能是由于 <strong>Chinese</strong> 比其他的长度要长，导致对不齐，那么下面来固定长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将上述第二行以后，分别以字符串、整数、小数点来显示</span></span><br><span class="line"><span class="comment"># grep -v Name 排除包含 Name 字符的行</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">printf</span> <span class="string">&#x27;%10s %5i %5i %5i %8.2f \n&#x27;</span> $(cat printf.txt | grep -v Name)</span><br><span class="line">    DmTsai    80    60    92    77.33 </span><br><span class="line">     VBird    75    55    80    70.00 </span><br><span class="line">       Ken    60    90    70    73.33 </span><br><span class="line"><span class="comment"># 由于这里是格式化数字，所以第一行无法使用这里的表达式，如果使用将得到数字 0 的展示</span></span><br><span class="line"><span class="comment"># 展示效果好了很多</span></span><br><span class="line"> %10s：这一个字段永远显示 10 个字符宽度，不足的用空格补位</span><br><span class="line"> %8.2f：表示 00000.00</span><br></pre></td></tr></table></figure>

<p><strong>printf</strong> 除了可以格式化处理之外，还可以根据 ASCII 的数字与图形对应来显示数据，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3： 列出 16 进制 45 代表的字符是什么</span></span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">printf</span> <span class="string">&#x27;\x45\n&#x27;</span></span><br><span class="line">E</span><br><span class="line"><span class="comment"># 可以将数值转换为字符，如果你会写 script 的话</span></span><br><span class="line"><span class="comment"># 可以测试下，20~80 之间的数值表示的字符是什么</span></span><br></pre></td></tr></table></figure>

<p><strong>printf</strong> 使用相当广泛，包括后面提到的 <strong>awk</strong> 以及在 <strong>c</strong> 程序语言中使用的屏幕输出，都是利用 <strong>printf</strong>。</p>
<p><strong>printf</strong> 使用场景就是格式化输出，如果你要写自己的软件，把信息漂亮的输出到屏幕的话，可是很有用的</p>
<h3 id="awk：好用的数据处理工具"><a href="#awk：好用的数据处理工具" class="headerlink" title="awk：好用的数据处理工具"></a>awk：好用的数据处理工具</h3><ul>
<li><strong>sed</strong>：常常用于一整行的处理</li>
<li><strong>awk</strong>：倾向于将一行分成数个字段来处理</li>
</ul>
<p>因此，<strong>awk</strong> 适合处理小型的数据处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#x27;</span> filename</span><br><span class="line"></span><br><span class="line">awk 后可以跟文件，也可以接受前个指令的 standard output</span><br><span class="line">awk 主要处理每一行的字段内的数据，他默认的分隔符为「空格键」或「tab 键」</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例：使用 last 将登录者数据取出来</span></span><br><span class="line">[mrcode@study tmp]$ last -n 5		<span class="comment"># 取出前 5 行</span></span><br><span class="line">mrcode   pts/1        192.168.0.105    Wed Jan 15 22:20   still logged <span class="keyword">in</span>   </span><br><span class="line">mrcode   pts/0        192.168.0.105    Wed Jan 15 22:20   still logged <span class="keyword">in</span>   </span><br><span class="line">reboot   system boot  3.10.0-1062.el7. Wed Jan 15 22:19 - 23:05  (00:45)    </span><br><span class="line">mrcode   pts/1        192.168.0.105    Mon Jan 13 22:51 - 23:13  (00:22)    </span><br><span class="line">mrcode   pts/0        192.168.0.105    Mon Jan 13 22:51 - 23:13  (00:22) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要取出账户与登录 IP ，且账户与 IP 之间以 tab 隔开，可以这样写</span></span><br><span class="line">[mrcode@study tmp]$ last -n 5 | awk <span class="string">&#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">reboot  boot</span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">mrcode  192.168.0.105</span><br><span class="line">        </span><br><span class="line">wtmp    Fri</span><br><span class="line"><span class="comment"># 由于每一行数据都需要处理，所以不需要有条件类型</span></span><br><span class="line"><span class="comment"># 通过 print 功能将数据列出来</span></span><br><span class="line"><span class="comment"># 第 3 行数据被误判了，第二个字段中包含了空格</span></span><br><span class="line"><span class="comment"># 那么 $1 开始的变量表示哪一个字段，要注意的是：$0 表示整行数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于上面示例，<strong>awk</strong> 的处理流程是：</p>
<ol>
<li>读入第一行，并将第一行的内容填入 <code>$0、$1...</code> 变量中</li>
<li>依据 条件类型 的限制，判断是否需要进行后面的 动作</li>
<li>做完所有的动作与条件类型</li>
<li>若还有后续的「行」数据，则重复上面 <strong>1~3</strong> 步骤，直到所有数据都处理完为止</li>
</ol>
<p><strong>awk</strong> 是「以行为一次处理的单位」而「以字段为最小的处理单位」，那么 <strong>awk</strong> 中还提供了以下变量信息</p>
<table>
<thead>
<tr>
<th align="center">变量名称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NF</td>
<td align="center">每一行（<code>$0</code>）拥有的字段总数</td>
</tr>
<tr>
<td align="center">NR</td>
<td align="center">目前 awk 所处理的是「第几行」数据</td>
</tr>
<tr>
<td align="center">FS</td>
<td align="center">目前的分割字符，默认是空格</td>
</tr>
</tbody></table>
<p>继续上面 <strong>last -n 5</strong> 的例子来做说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要列出每一行的账户：就是 $1</span></span><br><span class="line"><span class="comment"># 列出目前处理的行数：NR 变量</span></span><br><span class="line"><span class="comment"># 该行有多少字段：NF 变量</span></span><br><span class="line"><span class="comment"># 注意：在 awk 的格式内使用 print 打印时，非变量部分需要用双引号引用起来，因为 awk 动作是以单引号的</span></span><br><span class="line">[mrcode@study ~]$ last -n 5 | awk <span class="string">&#x27;&#123;print $1 &quot;\t lines:&quot; NR &quot;\t columns:&quot; NF&#125;&#x27;</span></span><br><span class="line">mrcode   lines:1         columns:10</span><br><span class="line">mrcode   lines:2         columns:10</span><br><span class="line">reboot   lines:3         columns:11</span><br><span class="line">mrcode   lines:4         columns:10</span><br><span class="line">mrcode   lines:5         columns:10</span><br><span class="line">         lines:6         columns:0</span><br><span class="line">wtmp     lines:7         columns:7</span><br><span class="line"><span class="comment"># 注意 NF 等变量不需要有 $ 并且需要大写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="awk-的逻辑运算字符"><a href="#awk-的逻辑运算字符" class="headerlink" title="awk 的逻辑运算字符"></a>awk 的逻辑运算字符</h3><p>既然有「条件」，那么就有逻辑运算符号</p>
<table>
<thead>
<tr>
<th align="center">运算单元</th>
<th align="center">代表意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&gt;</code></td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">大于或等于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">小于或等于</td>
</tr>
<tr>
<td align="center"><code>==</code></td>
<td align="center"><strong>等于</strong></td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">不等于</td>
</tr>
</tbody></table>
<p>范例：在 <strong>/etc/passwd</strong> 中是以冒号「:」来分割字段的，第一个字段为账户，第三字段则是 <strong>UID</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查阅 第三栏小于 10 以下的数据，并且仅列出账户与第三栏</span></span><br><span class="line"><span class="comment"># FS 是字段分隔符</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/passwd | awk <span class="string">&#x27;&#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin     1</span><br><span class="line">daemon  2</span><br><span class="line">adm     3</span><br><span class="line">lp      4</span><br><span class="line">sync    5</span><br><span class="line">shutdown        6</span><br><span class="line">halt    7</span><br><span class="line">mail    8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行，没有生效是为啥呢？在 <strong>awk</strong> 中，在上述定义中，<strong>FS</strong> 仅能在第二行开始，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要使用关键字 BEGIN，对应的还有 END</span></span><br><span class="line">[mrcode@study ~]$ cat /etc/passwd | awk <span class="string">&#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line">root    0</span><br><span class="line">bin     1</span><br><span class="line">daemon  2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <strong>awk</strong> 的计算功能，比如有如下的数据 <strong>pay.txt</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name		1st		2nd		3th</span><br><span class="line">Mrcode	2300	2400	2500</span><br><span class="line">DMTsai	2100	2000	2300</span><br><span class="line">Mrcode2	4300	4200	4100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每个人的总额，而且还要格式化输出</span></span><br><span class="line"> - 第一行是说明，不需要计算，所以需要使用条件 NR=1 时再处理</span><br><span class="line"> - 第二行才开始计算，NR &gt;=2 才处理</span><br><span class="line"></span><br><span class="line">[mrcode@study tmp]$ cat pay.txt | </span><br><span class="line">&gt; awk <span class="string">&#x27;NR==1 &#123;printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125;</span></span><br><span class="line"><span class="string">&gt; NR&gt;=2 &#123;total = $2 + $3 + $4 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line">      Name        1st        2nd        3th      Total</span><br><span class="line">    Mrcode       2300       2400       2500    7200.00</span><br><span class="line">    DMTsai       2100       2000       2300    6400.00</span><br><span class="line">   Mrcode2       4300       4200       4100   12600.00</span><br><span class="line"></span><br><span class="line">为了方便复制，这里粘贴上完整的一行命令：cat pay.txt |  awk <span class="string">&#x27;NR==1 &#123;printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125; NR&gt;=2 &#123;total = $2 + $3 + $4 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在来分解上面指令</span></span><br><span class="line"><span class="comment"># 1. 在 awk 中，非变量需要使用双引号引用起来</span></span><br><span class="line"><span class="comment"># 2. 使用 printf 时，需要加上 \n 才能换行</span></span><br><span class="line"><span class="comment"># 下面的含义是，当是第一行的时候，执行打印个格式化，前面是格式化表达式</span></span><br><span class="line"><span class="comment"># 后面用逗号分割，给出对应内容，这里给出了 1~4 个字段，并新增了一个 total 字段</span></span><br><span class="line">[mrcode@study tmp]$ cat pay.txt | awk <span class="string">&#x27;NR==1 &#123;printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;total&quot;&#125;&#x27;</span></span><br><span class="line">      Name        1st        2nd        3th      total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于计算的讲解</span></span><br><span class="line"><span class="comment"># 1. 在&#123;&#125; 动作中可以设置变量，进行运算；这里设置了一个 total 变量，并把 1~3 个字段相加</span></span><br><span class="line"><span class="comment"># 2. 由于这里有多个指令，所以需要使用冒号 「;」 进行分割</span></span><br><span class="line"><span class="comment"># 3. 使用 printf 常规打印，第 5 个字段引用了动作内设置的变量 total，记住 awk 中引用变量不需要使用 % 符号</span></span><br><span class="line">[mrcode@study tmp]$ cat pay.txt | awk <span class="string">&#x27;NR&gt;=2 &#123;total=$1+$2+$3 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line">    Mrcode       2300       2400       2500    4700.00</span><br><span class="line">    DMTsai       2100       2000       2300    4100.00</span><br><span class="line">   Mrcode2       4300       4200       4100    8500.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么上面两条是针对各自条件进行处理的，相当于 if 语句；多个条件动作之间使用空格分割；链接起来就完成了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用 <strong>awk</strong> 可以帮助我们处理很多日常工作了，在 <strong>awk</strong> 的输出格式中，常常会以 <strong>printf</strong> 来辅助。另外在 <strong>{}</strong> 动作内，也支持 <strong>if</strong>(条件) 语句。那么上面的指令可以使用 <strong>if</strong> 来做，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat pay.txt | awk <span class="string">&#x27;&#123;if(NR==1) printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125; NR&gt;=2 &#123;total = $2 + $3 + $4 ; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>笔者没有感觉这个 <strong>if</strong> 有多方便啊？</p>
<p>另外，<strong>awk</strong> 还可以进行循环计算，不过这个属于比较进阶的单独课程了</p>
<h2 id="文件比对工具"><a href="#文件比对工具" class="headerlink" title="文件比对工具"></a>文件比对工具</h2><p>通常会在同一个软件包的不同版本之间，比较配置文件与原始文件的差异的时候，就会用到文件对比。</p>
<p>很多时候所谓的对比，通常是用在 <strong>ASCII</strong> 纯文本的比对。常见的指令有 <strong>diff</strong>，还可以使用 <strong>cmp</strong> 来对比非纯文本。同时也可以使用 <strong>diff</strong> 建立分析文档，以处理补丁 <strong>patch</strong> 功能的文件</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p><strong>diff</strong> 用在比对两个文件之间的差异，以行为单位来比对的。一般是用在 <strong>ASCII</strong> 纯文本文件的比对上。</p>
<p>比如：将 <strong>/etc/passwd</strong> 删除第 4 行，第 6 行则替换为「<strong>no six line</strong>」，新文件放置到 <strong>/tmp/test</strong> 里，该如何做？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试目录</span></span><br><span class="line">[mrcode@study tmp]$ mkdir -p /tmp/testpw</span><br><span class="line">[mrcode@study tmp]$ <span class="built_in">cd</span> /tmp/testpw/</span><br><span class="line">[mrcode@study testpw]$ cp /etc/passwd passwd.old </span><br><span class="line"><span class="comment"># sed -e 直接在命令行模式上修改；d 是删除，c是替换；前面 sed 中有讲到过的</span></span><br><span class="line"><span class="comment"># 这里把修改后的内容存到了 passwd.new 文件中</span></span><br><span class="line"><span class="comment"># sed 中有超过两个以上的动作时需要加 -e</span></span><br><span class="line">[mrcode@study testpw]$ cat /etc/passwd | sed -e <span class="string">&#x27;4d&#x27;</span> -e <span class="string">&#x27;6c no six line&#x27;</span> &gt; passwd.new</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diff [-bBi] from-file to-file</span><br><span class="line">选项与参数：</span><br><span class="line"></span><br><span class="line">from-file：文件名，原始对比文件</span><br><span class="line">to-file：文件名，目的比较文件</span><br><span class="line">注意：两个文件，都可以使用 - 表示，- 代表 standard input</span><br><span class="line"></span><br><span class="line">-b：忽略一行当中，仅有多个空白的差异；例如：“about me“ 与 “about         me” 视为相同</span><br><span class="line">-B：忽略空白行的差异</span><br><span class="line">-i：忽略大小写的不同</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：比对 passwd.old passwd.new 文件</span></span><br><span class="line">[mrcode@study testpw]$ diff passwd.old passwd.new </span><br><span class="line">4d3						<span class="comment"># 左边第 4 行被删除(d)掉了，基准是右边第 3 行</span></span><br><span class="line">&lt; adm:x:3:4:adm:/var/adm:/sbin/nologin				<span class="comment"># 列出了左边被删除的那一行内容</span></span><br><span class="line">6c5						<span class="comment"># 左边第 6 行，被替换（c）成右边文件的第 5 行</span></span><br><span class="line">&lt; sync:x:5:0:sync:/sbin:/bin/sync			<span class="comment"># 左边文件第 6 行内容</span></span><br><span class="line">---	</span><br><span class="line">&gt; no six line								<span class="comment"># 右边文件第 5 行内容</span></span><br><span class="line"><span class="comment"># 注意这里的，左边第 4 行被删除意思是：左边文件是完整的，右边是修改之后的，右边与左边对比，原来的第 4 行被删除了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果用 <strong>diff</strong> 去对比两个完全不相干的文件，是对比不出来什么的；另外 <strong>diff</strong> 还可以对比整个目录下的差异</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例：了解一下不同的开机执行等级（runlevel）内容有啥不同？假设你已经知道执行等级 0 与 5的启动脚本分别放置到 /etc/rc0.d 及 /etc/rc5.d 则可以对比下</span></span><br><span class="line">[mrcode@study testpw]$ diff /etc/rc0.d/ /etc/rc5.d/</span><br><span class="line">只在 /etc/rc0.d/ 存在：K90network</span><br><span class="line">只在 /etc/rc5.d/ 存在：S10network</span><br></pre></td></tr></table></figure>

<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p><strong>cmp</strong> 主要也是对比两个文件，主要利用字节单位去对比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp [-l] file1 file2</span><br><span class="line">-i：将所有的不同点的字节处都列出来。因为 cmp 预设仅会输出第一个发现的不同点</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：用 cmp 比较 passwd.old 与 passwd.new</span></span><br><span class="line">[mrcode@study testpw]$ cmp passwd.old passwd.new </span><br><span class="line">passwd.old passwd.new 不同：第 106 字节，第 4 行</span><br></pre></td></tr></table></figure>

<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p><strong>patch</strong> 与 <strong>diff</strong> 可配合使用，<strong>diff</strong> 比较出不同，而 <strong>patch</strong> 则可以将「旧文件升级为新的文件」。</p>
<ol>
<li>先比较新旧版本的差异</li>
<li>将差异制作成补丁文件</li>
<li>再由补丁文件更新旧文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：以 /tmp/testpw 内的 passwd.old 与 passwd.new 制作补丁文件</span></span><br><span class="line">[mrcode@study testpw]$ diff -Naur passwd.old passwd.new &gt; passwd.patch</span><br><span class="line">[mrcode@study testpw]$ cat passwd.patch </span><br><span class="line">--- passwd.old	2020-01-17 15:58:55.405462402 +0800			<span class="comment"># 新旧文件的信息</span></span><br><span class="line">+++ passwd.new	2020-01-17 16:01:03.115462402 +0800</span><br><span class="line">@@ -1,9 +1,8 @@		<span class="comment"># 新旧文件要修改数据的界定范围，旧文件在 1-0 行，新文件在 1-8 行</span></span><br><span class="line"> root:x:0:0:root:/root:/bin/bash</span><br><span class="line"> bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line"> daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">-adm:x:3:4:adm:/var/adm:/sbin/nologin			<span class="comment"># 左侧文件删除</span></span><br><span class="line"> lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">-sync:x:5:0:sync:/sbin:/bin/sync				<span class="comment"># 左侧文件删除</span></span><br><span class="line">+no six line									<span class="comment"># 右侧新加入</span></span><br><span class="line"> shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line"> halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line"> mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 这里怎么理解？ 可以理解为 old 文件是基准文件</span></span><br><span class="line"> <span class="comment"># 根据这里的基准文件，看到 - 就剪掉，看到 + 就增加；执行完成后，则会得到 new 这个文件；</span></span><br><span class="line"> <span class="comment"># 并且补丁中限制了行数。</span></span><br></pre></td></tr></table></figure>

<p>将 <strong>passwd.old</strong> 同步为 <strong>passwd.new</strong> 相同的内容，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于系统未预装 patch 软件，需要将之前的 iso 镜像文件挂载</span></span><br><span class="line"><span class="comment"># 在虚拟机上找到顺序为 0 的控制器位置，选择 iso 文件，设备就能被 linux 找到了</span></span><br><span class="line">[root@study ~]<span class="comment"># mount /dev/sr0 /mnt/</span></span><br><span class="line">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class="line">[root@study ~]<span class="comment"># rpm -ivh /mnt/Packages/patch-2.*</span></span><br><span class="line">警告：/mnt/Packages/patch-2.7.1-11.el7.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID f4a80eb5: NOKEY</span><br><span class="line">准备中...                          <span class="comment">################################# [100%]</span></span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:patch-2.7.1-11.el7               <span class="comment">################################# [100%]</span></span><br><span class="line">[root@study ~]<span class="comment"># umount /mnt/</span></span><br><span class="line">[root@study ~]<span class="comment"># exit</span></span><br><span class="line"><span class="comment"># 透过上述方式安装所需软件</span></span><br></pre></td></tr></table></figure>

<p>语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">patch -pN &lt; patch_file  <span class="comment"># 更新</span></span><br><span class="line">patch -R -pN &lt; patch_file  <span class="comment"># 还原</span></span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-p：后面可以接 取消几层目录 的意思</span><br><span class="line">-R：代表还原，将新的文件还原成原来的旧文件</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将刚刚制作出来的 patch file 用来更新旧版本数据</span></span><br><span class="line">[mrcode@study testpw]$ patch -p0 &lt; passwd.patch </span><br><span class="line">patching file passwd.old</span><br><span class="line">[mrcode@study testpw]$ ll passwd.*</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode 2266 1月  17 16:01 passwd.new</span><br><span class="line">-rw-r--r--. 1 mrcode mrcode 2266 1月  17 16:50 passwd.old	<span class="comment"># 文件大小和new文件一样了</span></span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode  480 1月  17 16:38 passwd.patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：恢复旧文件内容</span></span><br><span class="line">[mrcode@study testpw]$ patch -R -p0 &lt; passwd.patch </span><br><span class="line">patching file passwd.old</span><br><span class="line">[mrcode@study testpw]$ ll passwd.*</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode 2266 1月  17 16:01 passwd.new</span><br><span class="line">-rw-r--r--. 1 mrcode mrcode 2323 1月  17 16:52 passwd.old</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里为什么会使用 <code>-p0</code> ？因为两个文件在同一个目录下，因此不需要减去目录。如果是整体目录比对（<strong>diff</strong> 旧目录 新目录）时，就要依据建立 <strong>patch</strong> 文件所在目录来进行目录删减</p>
<p>更详细的 <strong>patch</strong> 用法在后续的第二十章「原始码编译」</p>
<h3 id="文件打印准备：pr"><a href="#文件打印准备：pr" class="headerlink" title="文件打印准备：pr"></a>文件打印准备：pr</h3><p>在图形界面中的文字处理软件，打印时可以选择每一页的标头和页码，在文字界面下，可以使用 <strong>pr</strong> 来实现，由于 <strong>pr</strong> 参数实在太多了，这里使用最简单的方式来处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印 /etc/man_db.conf</span></span><br><span class="line">[mrcode@study testpw]$ pr /etc/man_db.conf </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2018-10-31 04:26                /etc/man_db.conf                 第 1 页</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is used by the man-db package to configure the man and cat paths.</span></span><br><span class="line"><span class="comment"># It is also used to provide a manpath for those without one by examining</span></span><br><span class="line"><span class="comment"># their PATH environment variable. For details see the manpath(5) man page.</span></span><br></pre></td></tr></table></figure>

<p>最上面的一行就是 <strong>pr</strong> 处理之后的效果。依次是：文件时间、文件名、页码</p>
<h1 id="学习-Shell-Scripts"><a href="#学习-Shell-Scripts" class="headerlink" title="学习 Shell Scripts"></a>学习 Shell Scripts</h1><p>基本上 <strong>shell script</strong> 类似早期的批处理文件，将一些指令汇总起来一次执行，但是 <strong>shell script</strong> 拥有更强大的功能，可以进行类似程序的编写，并且不需要经过编译就可以执行。</p>
<p>我们可以通过 <strong>shell script</strong> 来简化我们日常的管理工作，而且整个 <strong>Linux</strong> 环境中，一些服务（<strong>services</strong>）的启动都是透过 <strong>shell script</strong> 的。</p>
<p>所以 <strong>shell scripts</strong> 是很重要的课程</p>
<h2 id="什么是-Shell-Scripts"><a href="#什么是-Shell-Scripts" class="headerlink" title="什么是 Shell Scripts"></a>什么是 Shell Scripts</h2><p>Shell Scripts ：程序化脚本；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- shell ：在前面第十章中讲过的 BASH，是一个文字接口让我们与系统沟通的一个工具接口。</span><br><span class="line">- script：脚本</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>那么就是针对 <strong>shell</strong> 写的脚本</p>
<p><strong>shell script</strong> 可以简单的看成是批处理文件，也可以称为一种程序语言，该语言是利用 <strong>shell</strong> 与相关工具指令，所以不需要编译即可执行，且有不错的 <strong>debug</strong> 工具，所以，它可以帮助系统管理员快速的管理好主机</p>
<h2 id="为什么要学习-shell-scripts"><a href="#为什么要学习-shell-scripts" class="headerlink" title="为什么要学习 shell scripts?"></a>为什么要学习 shell scripts?</h2><p>简单说：想要玩清楚 <strong>Linux</strong> 的来龙去脉，<strong>shell script</strong> 是必须的知识，因为：</p>
<ul>
<li><p>自动化管理的重要依据</p>
<p>管理一部主机每天要进行的任务就有：</p>
<ul>
<li>查询登录文件</li>
<li>追踪流量</li>
<li>监控用户使用主机状态</li>
<li>主机各项硬件设备状态</li>
<li>主机软件更新查询</li>
</ul>
<p>等等，这里白不包括有其他使用者突然的要求了。这些工作进行又可以分为：</p>
<ol>
<li>自行手动处理</li>
<li>写个简单的程序来帮你每日「自动处理分析」</li>
</ol>
</li>
<li><p>追踪与管理系统的重要工作</p>
<p> 在 <strong>CentOS 6.x</strong> 以前的版本中，系统的服务（<strong>services</strong>）启动的接口是在 <code>/etc/init.d</code> 目录下，所有文件都是 <strong>scripts</strong>；另外，包括开机（<strong>booting</strong>）过程也是利用 <strong>shell script</strong> 来帮忙搜索系统的相关设置数据，再代入各个服务的设置参数。</p>
<p> 比如：想要重新启动系统注册表，可以使用 <code>/etc/init.d/rsyslogd restart</code> <strong>rsyslogd</strong> 文件就是 <strong>script</strong> 了</p>
<p> 另外，比如 <strong>Mysql</strong> 数据库服务启动时，有可能就在 <strong>script</strong> 中主动以「空密码」尝试登陆 <strong>Mysql</strong>，为了安全性，那么你就可以修改这个 <strong>script</strong> 文件。</p>
<p> 虽然 <code>/etc/init.d/*</code> 这个脚本目前的启动方式（<strong>systemV</strong>）已经被新一代的 <strong>systemd</strong> 所代替了（从 CentOS 7 开始），但是很多的个别服务在管理他们的服务启动方面，还是使用 <strong>shell script</strong> 的机制</p>
</li>
<li><p>简单入侵检测功能</p>
<p>当系统有异常状态时，大多会讲这些记录在「系统注册表」中（系统记录器），那么就可以在固定的几分钟内主动的去分析注册表文件，若察觉有问题，就立刻通知管理员，或者是立刻加强防火墙的规则，如此一来，主机就能过达到自我保护的聪明学习功能了。</p>
<p>比如：可以通过 <strong>shell script</strong> 分析「当该封包尝试几次还是联机失败之后，就抵挡住该 <strong>IP</strong>」之类的动作</p>
</li>
<li><p>连续指令单一化</p>
<p>简单说，<strong>script</strong> 最简单的功能就是，将一批指令写入 <strong>script</strong> 中，达到执行一个文件就能下达一批指令的目的。</p>
<p>比如：防火墙连续规则（<strong>iptables</strong>）、开机加载程序的项目（<B>/etc/rc.d/rc.local</B>） 等等</p>
</li>
<li><p>简易的数据处理</p>
<p>前面几章讲解的如 <strong>awk</strong> 等指令就可以用来处理简单的数据。配合各种指令来达到处理数据的目的</p>
</li>
<li><p>跨平台支持与学习历程较短</p>
<p>几乎所有的 <strong>Unix Like</strong> 上都可以运行 <strong>shell script</strong>，连 <strong>MS Windows</strong> 系列也有相关的 <strong>script</strong> 仿真器可以用</p>
</li>
</ul>
<p>虽然 <strong>shell script</strong> 号称是程序，实际上，<strong>shell script</strong> 处理数据的速度上还是不够快，因为用的是外部的指令与 <strong>bash shell</strong> 的一些默认工具，所以常常去调用外部的函数库，因此指令周期上面比不上传统的程序语言</p>
<p>所以，<strong>shell script</strong> 用在系统管理上是很好的一项工具，但是用在处理大量数值运算上，就不行了，速度较慢，使用 <strong>CPU</strong> 资源较多，造成主机资源的分配不良。我们通常利用 <strong>shell script</strong> 来处理服务器的侦测就比较合适</p>
<h2 id="第一支-script-的编写与执行"><a href="#第一支-script-的编写与执行" class="headerlink" title="第一支 script 的编写与执行"></a>第一支 script 的编写与执行</h2><p><strong>shell script</strong> 是纯文本文件，可以在里面一次性执行多个指令，或者是利用一些运算与逻辑判断来帮助我们达成某些功能。所以需要具备 <strong>bash</strong> 指令下达相关知识（第四章中开始下达指令中讲过），除此之外，还有以下知识需要了解：</p>
<ol>
<li>指令的执行是从上而下、从左而右的分析与执行</li>
<li>指令的下达：指令、选项与参数间的多个空白都会被忽略掉</li>
<li>空白行也将被忽略，并且「<strong>tab</strong>」按键锁推开的空白行同样视为空格</li>
<li>如果读取到一个 <strong>enter</strong> 符号（<strong>CR</strong>），就尝试开始执行改行（或该串）命令</li>
<li>如果一行内容太多，则可以使用「<code>\[Enter]</code>」来延伸至下一行</li>
<li><code>#</code>可作为批注。任何加在 <code>#</code>后面的文字将被视为批注文字而被忽略</li>
</ol>
<p>假设现在存在一个 <strong>script</strong> 是 <code>/home/mrcode/shell.sh</code>，有如下的方式执行这个文件</p>
<ul>
<li>直接指令下达：<strong>shell.sh</strong> 文件必须有可读与执行权限（rx）<ul>
<li>绝对路径：使用 <code>/home/mrcode/shell.sh</code>执行</li>
<li>相对路径：假设工作目录在 <code>/home/mnrcode</code>，就使用 <code>./shell.sh</code>执行</li>
<li>变量「<strong>PATH</strong>」功能：将 <strong>shell.sh</strong> 放在 <strong>PATH</strong> 指定目录内，例如 ~<code>/bin/</code></li>
</ul>
</li>
<li>以 <strong>bash</strong> 程序来执行：<code>bash shell.sh</code> 或 <code>sh shell.sh</code> 执行</li>
</ul>
<p>至于那个相对路径 <code>./shell.sh</code> 为什么需要这样，是因为 <a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/04.html">路径与指令搜索顺序</a> 的关系；</p>
<p><code>sh shell.sh</code> 为啥可以执行？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">type</span> -a sh</span><br><span class="line">sh is /usr/bin/sh</span><br><span class="line">[mrcode@study ~]$ ll /usr/bin/sh</span><br><span class="line">lrwxrwxrwx. 1 root root 4 Jan 17 14:32 /usr/bin/sh -&gt; bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 <strong>sh</strong> 是 <strong>bash</strong> 的链接文件，同时还可以使用参数 <code>-n 和 -x</code> 来检查与追踪 <strong>shell.sh</strong> 的语法是否正确</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>先来一个 <strong>Hello World</strong> 脚本，再来逐步说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/mrcode</span><br><span class="line">[mrcode@study ~]$ mkdir bin; <span class="built_in">cd</span> bin</span><br><span class="line">[mrcode@study bin]$ vi hello.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows &quot;Hello World&quot; in your screen.</span></span><br><span class="line"><span class="comment"># HIstory:</span></span><br><span class="line"><span class="comment"># 2020/02/19    mrcode  first release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Hello World! \a \n&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>在本章中，请将所有编写的 <strong>script</strong> 放置到你家目录的 <code>~/bin</code> 目录内，未来比较好管理，针对如上脚本的写法，分段说明：</p>
<ol>
<li><p><code>#!/bin/bash</code>：宣告这个 <strong>script</strong> 使用的 <strong>shell</strong> 名称</p>
<p>因为我们使用的是 <strong>bash</strong>，所以必须以 <code>#!/bin/bash</code> 来声明该文件内的语法使用 <strong>bash</strong> 语法。</p>
<p>当这个程序被执行时，能够加载 <strong>bash</strong> 的相关环境配置文件（一般来说是 <strong>non-login shell</strong> 的 <code>~/.bashrc</code>），并且执行 <strong>bash</strong> 来使指令能够执行。很多情况下导致无法执行可能就是因为这一行的原因，系统无法判断该 <strong>sh</strong> 文件使用什么 <strong>shell</strong> 来执行</p>
</li>
<li><p>程序内容说明</p>
<p>整个文件中，除了第一行的 <code>#!</code> 是用来声明 <strong>shell</strong> 之外，其他的 <code>#</code>都是批注信息。一般来说，建议一定要养成说明该 <strong>script</strong> 的：</p>
<ol>
<li>内容与功能</li>
<li>版本信息</li>
<li>作者与联络方式</li>
<li>建档日期</li>
<li>历史记录</li>
</ol>
<p>等等，这将有助于未来程序的改写与 <strong>debug</strong></p>
</li>
<li><p>主要环境变量的声明</p>
<p>建议务必将一些重要的环境变量设置好，<strong>PATH</strong> 与 <strong>LANG</strong>（输出相关信息时） 是当中最重要的，如此一来就可以直接下达外部指令，而不用写绝对路径，比较方便</p>
</li>
<li><p>主要程序部分</p>
<p>在本例中，就是 <strong>echo</strong> 那一行</p>
</li>
<li><p>执行结果告知（定义回传值）</p>
<p><a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/05.html#%E6%8C%87%E4%BB%A4%E5%9B%9E%E4%BC%A0%E5%80%BC-%E4%B8%8E-%E5%92%8C">指令回传值</a> 中讲解到，可以使用 <code>$?</code> 来观察，那么可以利用 <strong>exit</strong> 这个指令来让程序中断，并且回传一个数值给系统。</p>
<p>本例中使用的是 <code>exit 0</code>，表示离开 <strong>script</strong> 并且回传一个 <strong>0</strong> 给系统，所以执行完这个 <strong>shell.sh</strong> 之后，下达 <code>echo $?</code> 则可以得到 <strong>0</strong> 的值。</p>
<p>利用这个 <strong>exit n</strong>（<strong>n</strong> 是数字）的功能，还可以自定义错误信息，让这支程序变得更加智能</p>
</li>
</ol>
<p>执行与观察结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察权限，目前没有 x 执行权限</span></span><br><span class="line">[mrcode@study bin]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode 239 Jan 19 11:25 hello.sh</span><br><span class="line"><span class="comment"># 尝试执行，报错无权限</span></span><br><span class="line">[mrcode@study bin]$ ./hello.sh</span><br><span class="line">-bash: ./hello.sh: Permission denied</span><br><span class="line"><span class="comment"># 添加执行权限</span></span><br><span class="line">[mrcode@study bin]$ chmod u+x hello.sh </span><br><span class="line">[mrcode@study bin]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rwxrw-r--. 1 mrcode mrcode 239 Jan 19 11:25 hello.sh</span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">[mrcode@study bin]$ ./hello.sh </span><br><span class="line">Hello World!  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看回传值</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="编写-shell-script-的良好习惯建立"><a href="#编写-shell-script-的良好习惯建立" class="headerlink" title="编写 shell script 的良好习惯建立"></a>编写 shell script 的良好习惯建立</h2><p>一个良好习惯的养成至关重要，往往最开始时最容易忽视这部分的，觉得程序只要写出来就可以了，但是随着时间的拉长，不断的维护和修改。后续维护就可能出现问题</p>
<p>比如：作者管理很多计算机，由于太懒，经常同一个程序在不同的主机上进行修改，最最后也不知道哪一个程序是最新的，其中做了什么修改，又为什么做那样的修改。</p>
<p>所以，在写程序时，需要仔细的将程序的设计过程记录下来，而且还会记录一些历史记录，这样会导致维护成本降低</p>
<p>另外，在一些环节设置上面，毕竟每个人的环境都不相同，为了取得较佳的执行环境，一般都会预先定义一些一定会被用到的环境变量，例如上面的 <strong>PATH</strong>。因此养成良好的 <strong>script</strong> 编写习惯，建议在每个 <strong>script</strong> 文件头记录如下信息：</p>
<ul>
<li>功能描述</li>
<li>版本信息</li>
<li>作者与联系方式</li>
<li>版权信息</li>
<li>历史记录（<strong>History</strong>）</li>
<li><strong>script</strong> 内较为特殊的指令，使用「绝对路径」方式来下达</li>
<li><strong>script</strong> 运作时需要的环境变量预先声明与设置</li>
</ul>
<p>除了这些信息之外，在关键和难理解的代码部分添加批注信息。另外推荐代码编排格式使用 「巢状方式」，使用 <strong>tab</strong> 来缩进。编写 <strong>script</strong> 的工具是 <strong>vim</strong> 而不是 <strong>vi</strong>，因为 <strong>vim</strong> 有额外的语法校验机制</p>
<h2 id="简单的-Shell-Script-练习"><a href="#简单的-Shell-Script-练习" class="headerlink" title="简单的 Shell Script 练习"></a>简单的 Shell Script 练习</h2><p>本章 范例中，实现的方式很多，建议先自行编写，再参考例子，才能加深概念</p>
<h3 id="简单范例"><a href="#简单范例" class="headerlink" title="简单范例"></a>简单范例</h3><p>本小节范例在很多脚本程序中都会用到，而且简单</p>
<h3 id="对谈式脚本：变量类容由用户决定"><a href="#对谈式脚本：变量类容由用户决定" class="headerlink" title="对谈式脚本：变量类容由用户决定"></a>对谈式脚本：变量类容由用户决定</h3><p>在很多场景中，需要用户输入一些内容，让程序可以顺利运行。比如，安装软件时，让用户选择安装目录；</p>
<p><a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.mdl#read">BASH 中的变量读取指令 read</a> ，那么以 <strong>read</strong> 指令的用途实现：</p>
<ol>
<li>用户输入 <strong>first name</strong></li>
<li>用户输入 <strong>last name</strong></li>
<li>最后在屏幕上显示：<strong>You full name is：xxx</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ vim read.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;first name: &#x27;</span> firstName</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;last name: &#x27;</span> lastName</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You full name: <span class="variable">$&#123;firstName&#125;</span><span class="variable">$&#123;lastName&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加执行权限</span></span><br><span class="line">[mrcode@study bin]$ chmod a+x read.sh</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">[mrcode@study bin]$ ./read.sh </span><br><span class="line">first name: zhu</span><br><span class="line">last name: mrcode</span><br><span class="line">You full name: zhumrcode</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是书上的程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim showname.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program：</span></span><br><span class="line"><span class="comment">#	用户输入姓名，程序显示出输入的姓名</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#	2020/01/19	mrcode	first release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input you first name: &quot;</span> firstname		<span class="comment"># 提示使用者输入</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input you last name: &quot;</span> lastname			<span class="comment"># 提示使用者输入</span></span><br><span class="line"><span class="comment"># -e 开启反斜杠转移的特殊字符显示，比如下面的 \n 换行显示</span></span><br><span class="line"><span class="built_in">echo</span> -e “\n Your full name is: <span class="variable">$&#123;firstname&#125;</span><span class="variable">$&#123;lastname&#125;</span>”	<span class="comment"># 结果由屏幕输出	</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">[mrcode@study bin]$ ./showname.sh </span><br><span class="line">Please input you first name: zhu</span><br><span class="line">Please input you last name: mrcode</span><br><span class="line"></span><br><span class="line"> Your full name is: zhumrcode</span><br></pre></td></tr></table></figure>

<p>笔者小结：可以看到上面这个脚本，增加了一个良好的习惯，就是脚本说明等信息</p>
<h3 id="随日期变化：利用-date-进行文件的建立"><a href="#随日期变化：利用-date-进行文件的建立" class="headerlink" title="随日期变化：利用 date 进行文件的建立"></a>随日期变化：利用 date 进行文件的建立</h3><p>考虑一个场景，每天备份 <strong>MySql</strong> 的数据文件，备份文件名以当天日期命名，如 <code>backup.2020-01-19.data</code>.</p>
<p>重点是 <code>2020-01-19</code> 是怎么来的？范例需求如下：</p>
<ol>
<li>用户输入一个文件名前缀</li>
<li>创建出以日期为名的三个空文件（通过 <strong>touch</strong> 指令），生成 前天、昨天、今天 日期，及格式为：<strong>filename_2020-01-19</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vim create_3_filename.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program: </span></span><br><span class="line"><span class="comment">#       用户输入文件名前缀，生成前天、昨天、今天的三个空文件</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#       2020/01/19      mrcode          first release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;将使用 ‘touch’ 命令创建 3 个文件&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入文件名：&quot;</span> fileuser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容错，使用变量功能判定与赋值默认值</span></span><br><span class="line">filename=<span class="variable">$&#123;fileuser:-&quot;filename&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># date 命令的使用</span></span><br><span class="line">date1=$(date --date=<span class="string">&#x27;2 days ago&#x27;</span> +%Y-%m-%d)		<span class="comment"># 两天前的日期，并格式化显示</span></span><br><span class="line">date2=$(date --date=<span class="string">&#x27;1 days ago&#x27;</span> +%Y-%m-%d)	</span><br><span class="line">date3=$(date +%Y-%m-%d)</span><br><span class="line"></span><br><span class="line">file1=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date1&#125;</span>&quot;</span></span><br><span class="line">file2=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date2&#125;</span>&quot;</span></span><br><span class="line">file3=<span class="string">&quot;<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;date3&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这里其实可以直接拼接文件名</span></span><br><span class="line">touch <span class="string">&quot;<span class="variable">$&#123;file1&#125;</span>&quot;</span></span><br><span class="line">touch <span class="string">&quot;<span class="variable">$&#123;file2&#125;</span>&quot;</span></span><br><span class="line">touch <span class="string">&quot;<span class="variable">$&#123;file3&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里使用了变量的赋值相关功能，详参考：<a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.html#%E5%8F%98%E9%87%8F%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%86%85%E5%AE%B9%E6%9B%BF%E6%8D%A2">变量功能</a></p>
<p>运行测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./create_3_filename.sh </span><br><span class="line">将使用 ‘touch’ 命令创建 3 个文件</span><br><span class="line">请输入文件名：mrcode</span><br><span class="line">[mrcode@study bin]$ ll</span><br><span class="line">总用量 16</span><br><span class="line">-rwxrwxr-x. 1 mrcode mrcode 677 1月  19 14:15 create_3_filename.sh</span><br><span class="line">-rwxrwxr-x. 1 mrcode mrcode 239 1月  19 11:25 hello.sh</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode   0 1月  19 14:15 mrcode_2020-01-17</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode   0 1月  19 14:15 mrcode_2020-01-18</span><br><span class="line">-rw-rw-r--. 1 mrcode mrcode   0 1月  19 14:15 mrcode_2020-01-19</span><br><span class="line"><span class="comment"># 一次正常输入文件名，一次直接按 enter 按键完成输入，查看是否达到默认赋值等功能</span></span><br></pre></td></tr></table></figure>

<h3 id="数值运算：简单的加减乘除"><a href="#数值运算：简单的加减乘除" class="headerlink" title="数值运算：简单的加减乘除"></a>数值运算：简单的加减乘除</h3><p>在变量功能课程中讲解到，需要使用 <a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.html#declare-%E3%80%81-typeset">declare</a> 来定义变量为正数才能进行计算，此外，也可以利用 <code>$((计算表达式))</code> 来进行数值运算，可惜的是，<strong>bashe shell</strong> 预设仅支持整数数据。</p>
<p>范例需求：</p>
<ol>
<li>要求用户输入两个变量</li>
<li>将两个变量相乘后输出到屏幕</li>
</ol>
<p>下面是笔者自己写的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       用户输入 2 个整数；输出相乘后的结果</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#       2020/01/19      mrcode          first release</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第一个整数：&#x27;</span> intUser1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第二个整数：&#x27;</span> intUser2</span><br><span class="line"><span class="built_in">declare</span> -i int1=<span class="variable">$&#123;intUser1&#125;</span></span><br><span class="line"><span class="built_in">declare</span> -i int2=<span class="variable">$&#123;intUser2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="string">&quot;\n <span class="variable">$&#123;int1&#125;</span> x <span class="variable">$&#123;int2&#125;</span> = <span class="subst">$((int1*int2)</span>)&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./multiplying.sh </span><br><span class="line">请输入第一个整数：2</span><br><span class="line">请输入第二个整数：3</span><br><span class="line"></span><br><span class="line"> 2 x 3 = 6</span><br></pre></td></tr></table></figure>

<p>其实用下面这样的方式来定义和输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第一个整数：&#x27;</span> intUser1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入第二个整数：&#x27;</span> intUser2</span><br><span class="line">total=$((<span class="variable">$&#123;intUser1&#125;</span>*<span class="variable">$&#123;intUser2&#125;</span>))		<span class="comment"># 使用 $((运算内容)) 方式计算</span></span><br><span class="line"><span class="comment"># declare -i total=$&#123;intUser1&#125;*$&#123;intUser2&#125;		# 还可以使用此种方式</span></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="string">&quot;\n <span class="variable">$&#123;intUser1&#125;</span> x <span class="variable">$&#123;intUser2&#125;</span> = <span class="variable">$&#123;total&#125;</span>&quot;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>建议用 <code>var = $((计算内容))</code> 方式来计算，此种方式简单。比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取余数</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> $((<span class="number">3</span> % <span class="number">2</span>))</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于小数，可以使用 bc 指令来协助</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> $((<span class="number">3</span> / <span class="number">2</span>)); <span class="built_in">echo</span> <span class="string">&quot;3/2&quot;</span> | bc -l</span><br><span class="line">1</span><br><span class="line">1.50000000000000000000</span><br></pre></td></tr></table></figure>

<h3 id="数值运算：通过-bc-计算-pi"><a href="#数值运算：通过-bc-计算-pi" class="headerlink" title="数值运算：通过 bc 计算 pi"></a>数值运算：通过 bc 计算 pi</h3><p>bc 提供了一个计算 pi 的公式： <code>pi=$(echo &quot;scale=10; 4*a(1)&quot; | bc -l)</code>，此计算公式可以通过 <code>man bc | grep &#39;pi&#39;</code> 定位到相关文档。这里的 <strong>scale</strong> 是计算 <strong>pi</strong> 的精度，越高则利用到的 <strong>cpu</strong> 资源越多，计算时间越长。</p>
<p>好了，了解到怎么启用 <strong>pi</strong> 计算，这里要求用户输入 <strong>scale</strong> 进行计算 <strong>pi</strong> 值，并输出显示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim cal_pi.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program：</span></span><br><span class="line"><span class="comment">#	用户输入 scale 的值，程序计算出 scale 精度的 pi 值，并显示</span></span><br><span class="line"><span class="comment"># History：</span></span><br><span class="line"><span class="comment">#	2020/01/19		mrcode		first release</span></span><br><span class="line"><span class="comment"># PATH 常规赋值</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;请输入 scale 的值（10~10000）？&#x27;</span> checking</span><br><span class="line">num=<span class="variable">$&#123;checking:-&quot;10&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\n开始计算 pi 的值&#x27;</span></span><br><span class="line">time <span class="built_in">echo</span> <span class="string">&quot;scale=<span class="variable">$&#123;num&#125;</span>; 4*a(1)&quot;</span> | bc -l</span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./cal_pi.sh </span><br><span class="line">请输入 scale 的值（10~10000）？20</span><br><span class="line"></span><br><span class="line">开始计算 pi 的值</span><br><span class="line">3.14159265358979323844</span><br><span class="line"></span><br><span class="line">real	0m0.002s</span><br><span class="line">user	0m0.000s</span><br><span class="line">sys	0m0.001s</span><br></pre></td></tr></table></figure>

<h2 id="script-的执行方式差异（source、sh-script、-script）"><a href="#script-的执行方式差异（source、sh-script、-script）" class="headerlink" title="script 的执行方式差异（source、sh script、./script）"></a>script 的执行方式差异（source、sh script、./script）</h2><p>不同的方式执行执行会造成不一样的结果，尤其影响 <strong>bash</strong> 的环境很大。</p>
<h3 id="利用直接执行的方式来执行-script：在子程序中执行"><a href="#利用直接执行的方式来执行-script：在子程序中执行" class="headerlink" title="利用直接执行的方式来执行 script：在子程序中执行"></a>利用直接执行的方式来执行 script：在子程序中执行</h3><p><a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/12/01.html#%E7%AC%AC%E4%B8%80%E6%94%AF-script-%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C">直接指令下达</a> 或者是利用 <strong>bash</strong>（<strong>sh</strong>）来运行脚本时，都会使用一个新的 <strong>bash</strong> 环境来执行脚本的指令。也就是说这种方式执行是在子程序的 <strong>bash</strong> 内执行的。在第十章 <strong>BASH</strong> 内谈到 <a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/10/02.html"><code>export</code> 自定义变量转成环境变量</a> 的功能时，重点在于：当子程序完成后，子程序内的各项变量或动作将会结束儿不会传回到父程序中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行上面范例的姓名打印</span></span><br><span class="line">[mrcode@study bin]$ ./showname.sh </span><br><span class="line">Please input you first name: m</span><br><span class="line">Please input you last name: q</span><br><span class="line"></span><br><span class="line"> Your full name is: mq		<span class="comment">#  echo -e &quot;\n Your full name is: $&#123;firstname&#125;$&#123;lastname&#125;&quot; 打印出来了信息</span></span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> <span class="variable">$&#123;fristname&#125;</span><span class="variable">$&#123;lastname&#125;</span>		<span class="comment"># 但是在父程序中却没有信息</span></span><br></pre></td></tr></table></figure>

<h3 id="利用-source-来执行脚本：在父程序中执行"><a href="#利用-source-来执行脚本：在父程序中执行" class="headerlink" title="利用 source 来执行脚本：在父程序中执行"></a>利用 source 来执行脚本：在父程序中执行</h3><p>同样的测试代码，使用 <strong>source</strong> 就不一样了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ <span class="built_in">source</span> showname.sh </span><br><span class="line">Please input you first name: m</span><br><span class="line">Please input you last name: q</span><br><span class="line"></span><br><span class="line"> Your full name is: mq</span><br><span class="line">[mrcode@study bin]$ <span class="built_in">echo</span> <span class="variable">$&#123;firstname&#125;</span><span class="variable">$&#123;lastname&#125;</span></span><br><span class="line">mq			<span class="comment"># 在父程序中还能获取到</span></span><br></pre></td></tr></table></figure>

<h2 id="善用判断"><a href="#善用判断" class="headerlink" title="善用判断"></a>善用判断</h2><p>在 上一章中，提到过 <code>$?</code> 这个变量所代表的含义，以及通过 <code>&amp;&amp; 和 ||</code> 来判定前一个指令执行回传值对于后一个指令是否要进行的依据。</p>
<p>在上一章中，判定一个目录是否存在，使用了 <code>ll 目录 &amp;&amp; 执行指令</code> 的方式来判定 <strong>xx</strong> 目录是否存在，从而决定后续指令是否执行，但是有更简单的方式进行条件判断，就是通过 <strong>test</strong> 指令</p>
<h3 id="使用-test-指令的测试功能"><a href="#使用-test-指令的测试功能" class="headerlink" title="使用 test 指令的测试功能"></a>使用 test 指令的测试功能</h3><p><strong>test</strong> 指令主要用于检测文件或相关属性时的指令和比较值，比如检查 <strong>/mrcode</strong> 是否存在时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -e 是检测文件是否存在的选项</span></span><br><span class="line">[root@cloud-08 script]<span class="comment"># test -e /mrcode</span></span><br></pre></td></tr></table></figure>

<p>上面命令没有任何输出值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cloud-08 script]<span class="comment"># test -e /mrcode &amp;&amp; echo &quot;exist&quot; || &quot;not exist&quot;</span></span><br><span class="line">exist</span><br><span class="line"><span class="comment"># 通过与 &amp;&amp; 或 || 可以知道是存在还是不存在了</span></span><br></pre></td></tr></table></figure>

<p>要善用 man 查看该指令的信息，下面是整理翻译出来的其他选项</p>
<p>关于某个文件名的 <strong>文件类型</strong> 判断。如 <code>test -e filename</code> 标识是否存在</p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-e</strong></td>
<td align="left">文件是否存在；<strong>常用</strong></td>
</tr>
<tr>
<td align="center"><strong>-f</strong></td>
<td align="left">该文件是否存在且为文件（<strong>file</strong>）？<strong>常用</strong></td>
</tr>
<tr>
<td align="center"><strong>-d</strong></td>
<td align="left">该文件是否存在且为目录（<strong>directory</strong>）？<strong>常用</strong></td>
</tr>
<tr>
<td align="center"><strong>-b</strong></td>
<td align="left">该文件是否存在且为一个 <strong>block device</strong> 装置？</td>
</tr>
<tr>
<td align="center"><strong>-c</strong></td>
<td align="left">该文件是否存在且为一个 <strong>character device</strong> 装置？</td>
</tr>
<tr>
<td align="center"><strong>-S</strong></td>
<td align="left">该文件是否存在且为一个 <strong>Socket</strong> 文件？</td>
</tr>
<tr>
<td align="center"><strong>-p</strong></td>
<td align="left">该文件是否存在且为一个 <strong>FIFO</strong>（<strong>pipe</strong>）文件？</td>
</tr>
<tr>
<td align="center"><strong>-L</strong></td>
<td align="left">该文件是否存在且为一个连接文件？</td>
</tr>
</tbody></table>
<p>关于文件的 <strong>权限</strong> 判定。如 <code>test -r filename</code> 标识是否可读？（但 <strong>root</strong> 权限常有例外）</p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-r</strong></td>
<td align="left">该文件是否存在且具有可读权限？</td>
</tr>
<tr>
<td align="center"><strong>-w</strong></td>
<td align="left">该文件是否存在且具有可写权限？</td>
</tr>
<tr>
<td align="center"><strong>-x</strong></td>
<td align="left">该文件是否存在且具有可执行权限？</td>
</tr>
<tr>
<td align="center"><strong>-u</strong></td>
<td align="left">该文件是否存在且具有 <strong>SUID</strong> 属性？</td>
</tr>
<tr>
<td align="center"><strong>-g</strong></td>
<td align="left">该文件是否存在且具有 <strong>SGID</strong> 属性？</td>
</tr>
<tr>
<td align="center"><strong>-k</strong></td>
<td align="left">该文件是否存在且具有 <strong>Sticky bit</strong> 属性？</td>
</tr>
<tr>
<td align="center"><strong>-s</strong></td>
<td align="left">该文件是否存在且为「非空白文件」？</td>
</tr>
</tbody></table>
<p>两个文件之间的比较。如 <code>test file1 -nt file2</code></p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-nt</strong></td>
<td align="left">（<strong>newer than</strong>）判断 <strong>file1</strong> 是否比 <strong>file2</strong> 新</td>
</tr>
<tr>
<td align="center"><strong>-ot</strong></td>
<td align="left">（<strong>older than</strong>）判断 <strong>file1</strong> 是否比 <strong>file2</strong> 旧</td>
</tr>
<tr>
<td align="center"><strong>-ef</strong></td>
<td align="left">判断 <strong>file1</strong> 与 <strong>file2</strong> 是否是同一文件，可用在判断 <strong>hard link</strong> 的判定上。主要意义在判定两个文件是否均指向同一个 <strong>inode</strong></td>
</tr>
</tbody></table>
<p>两个整数之间的判定。<code>test nl -eq n2</code></p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-eq</strong></td>
<td align="left">两数值相等（<strong>equal</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-ne</strong></td>
<td align="left">不相等（<strong>not equal</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-gt</strong></td>
<td align="left">大于（<strong>greater than</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-lt</strong></td>
<td align="left">小于（<strong>less than</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-ge</strong></td>
<td align="left">大于等于（<strong>greater than or equal</strong>）</td>
</tr>
<tr>
<td align="center"><strong>-le</strong></td>
<td align="left">小于等于（<strong>less than or equal</strong>）</td>
</tr>
</tbody></table>
<p>判定字符串的数据</p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>test -z string</strong></td>
<td align="left">判定字符串是否为 <strong>0</strong>？若为空串，则为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>test -n string</strong></td>
<td align="left">判定字符串是否不为 <strong>0</strong>？若为空串，则为 <strong>false</strong>；注意：<strong>-n</strong> 可省略</td>
</tr>
<tr>
<td align="center"><strong>test str1 == str2</strong></td>
<td align="left">是否相等，相等则为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>test str1 != str2</strong></td>
<td align="left">是否不相等，相等则为 <strong>false</strong></td>
</tr>
</tbody></table>
<p>多重条件判断。比如 <code>test -r filename -a -x filename</code></p>
<table>
<thead>
<tr>
<th align="center">测试的标志</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-a</strong></td>
<td align="left">（<strong>and</strong>）两状况同时成立；如：<code>test -r filename -a -x filename</code>，则 <strong>file</strong> 同时具有 <strong>r</strong> 与 <strong>x</strong> 权限时才为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>-o</strong></td>
<td align="left">（<strong>or</strong>）任意一个成立。如：<code>test -r filename -o -x filename</code>，则 <strong>file</strong> 具有 <strong>r</strong> 或 <strong>x</strong> 权限时就为 <strong>true</strong></td>
</tr>
<tr>
<td align="center"><strong>!</strong></td>
<td align="left">反向状态。</td>
</tr>
</tbody></table>
<p>总结完这么多的判定，就可以来写几个简单的例子。让用户输入一个文件名，我们判断：</p>
<ol>
<li>该文件是否存在，若不存在则给予一个「<strong>Filename does not exist</strong>」 提示，并中断程序</li>
<li>若该文件存在，则判断是文件还是目录：文件输出「<strong>Filename is regular file</strong>」，目录输出 「<strong>Filename is directory</strong>」</li>
<li>判断执行者的身份对这个文件或目录所拥有的权限，并输出权限数据</li>
</ol>
<p>下面是笔者写的思路，代码组织方面有点糟糕。还有指令使用不太熟悉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># History</span></span><br><span class="line"><span class="comment">#       2020/01/19              mrcode          first relese</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个文件名：&quot;</span> filename</span><br><span class="line"><span class="comment"># 判断是否输入了字符串</span></span><br><span class="line"><span class="built_in">test</span> -z <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;请输入一个有效的文件名！&quot;</span> &amp;&amp; <span class="built_in">exit</span> -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断该文件是否存在: 不存在输出提示信息并退出</span></span><br><span class="line"><span class="comment"># 特别是这里的多条指令的执行，使用 || 会很难处理，只能转成 true</span></span><br><span class="line"><span class="built_in">test</span> ! -e <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> does not exist&quot;</span> &amp;&amp; <span class="built_in">exit</span> -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示是文件还是目录</span></span><br><span class="line"><span class="built_in">test</span> -f <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> is regular file&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> is directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断执行者的身份对这个文件拥有的权限，并输出</span></span><br><span class="line"><span class="built_in">test</span> -r <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> 可读&quot;</span></span><br><span class="line"><span class="built_in">test</span> -w <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> 可写&quot;</span></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;filename&#125;</span> 可执行&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./file_perm.sh </span><br><span class="line">请输入一个文件名：ss</span><br><span class="line">ss does not exist</span><br><span class="line">[mrcode@study bin]$ ./file_perm.sh </span><br><span class="line">请输入一个文件名：/etc</span><br><span class="line">/etc is directory</span><br><span class="line">/etc 可读</span><br><span class="line">/etc 可执行</span><br></pre></td></tr></table></figure>

<p>书上代码如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim file_perm.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program</span></span><br><span class="line"><span class="comment">#   User input a filename,program will check the flowing:</span></span><br><span class="line"><span class="comment">#	1.) exist?</span></span><br><span class="line"><span class="comment">#	2.) file/directory?</span></span><br><span class="line"><span class="comment">#	3.) file permissions</span></span><br><span class="line"><span class="comment"># History</span></span><br><span class="line"><span class="comment">#       2020/01/19              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Please input a filename,I will check the filename&#x27;s type and permission. \n\n&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Input a filename ：&quot;</span> filename</span><br><span class="line"><span class="comment"># 判断是否输入了字符串</span></span><br><span class="line"><span class="built_in">test</span> -z <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;You MUST input a filename. &quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断该文件是否存在: 不存在输出提示信息并退出</span></span><br><span class="line"><span class="built_in">test</span> ! -e <span class="variable">$&#123;filename&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;The filename <span class="variable">$&#123;filename&#125;</span> does not exist&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始判断文件类型与属性</span></span><br><span class="line"><span class="built_in">test</span> -f <span class="variable">$&#123;filename&#125;</span> &amp;&amp; filetype=<span class="string">&quot;regulare file&quot;</span></span><br><span class="line"><span class="built_in">test</span> -d <span class="variable">$&#123;filename&#125;</span> &amp;&amp; filetype=<span class="string">&quot;directory&quot;</span></span><br><span class="line"><span class="built_in">test</span> -r <span class="variable">$&#123;filename&#125;</span> &amp;&amp; perm=<span class="string">&quot;readable&quot;</span></span><br><span class="line"><span class="built_in">test</span> -w <span class="variable">$&#123;filename&#125;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> writable&quot;</span></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$&#123;filename&#125;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> executable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信息输出</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The filename: <span class="variable">$&#123;filename&#125;</span> is a <span class="variable">$&#123;filetype&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;And the permissions for you are : <span class="variable">$&#123;perm&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./file_perm.sh </span><br><span class="line">Please input a filename,I will check the filename<span class="string">&#x27;s type and permission. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input a filename ：ss</span></span><br><span class="line"><span class="string">The filename ss does not exist</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./file_perm.sh </span></span><br><span class="line"><span class="string">Please input a filename,I will check the filename&#x27;</span>s <span class="built_in">type</span> and permission. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input a filename ：/etc</span><br><span class="line">The filename: /etc is a directory</span><br><span class="line">And the permissions <span class="keyword">for</span> you are : readable executable</span><br></pre></td></tr></table></figure>

<p>自己写的脚本组织来看，除了不熟悉指令用法之外，对于程序结构的抽象不够好，对比书上的，发觉这个代码组织的不错</p>
<p>另外，该脚本检查权限的指令是针对运行该脚本的用户所反馈的，所以当使用 <strong>root</strong> 的时候，常常会发现与 <strong>ls -l</strong> 观察到的结果并不相同</p>
<h3 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号 []"></a>利用判断符号 <code>[]</code></h3><p>除了 <strong>test</strong> 外，还可以使用中括号 <code>[]</code> 来判定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断 $&#123;HOME&#125; 这个变量是否为空</span></span><br><span class="line">[mrcode@study bin]$ [ -z <span class="string">&quot;<span class="variable">$&#123;HOME&#125;</span>&quot;</span> ]; <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>使用该种方式需要特别注意，因为中括号在很多地方都代表特殊符号，在 <strong>bash</strong> 的语法中作为 <strong>shell</strong> 判断时，必须要注意 <strong>中括号的两端需要有空格符来分隔</strong></p>
<ul>
<li>在中括号内的每个组件都需要有空格来分隔</li>
<li>在中括号内的变量，最好都以双引号括起来</li>
<li>在中括号内的常量，都好都以单或双引号括起来</li>
</ul>
<p>看一个例子，设置一个 <strong>name</strong> 变量，再用中括号方式判断</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ name=<span class="string">&quot;Mrcode Tset&quot;</span></span><br><span class="line">[mrcode@study bin]$ [ <span class="variable">$&#123;name&#125;</span> == <span class="string">&quot;Mrcode&quot;</span> ]</span><br><span class="line">-bash: [: 参数太多</span><br><span class="line"><span class="comment"># 是因为，如果 $&#123;name&#125; 没有使用双引号括起来就会变成  [ Mrcode Test  == &quot;Mrcode&quot; ]</span></span><br><span class="line"><span class="comment"># 中括号内的变量是以空格来分隔的，那么这里就出现了 Mrcode Test “Mrcode” 三个比较对象了</span></span><br><span class="line"><span class="comment"># 那么使用 [ “$&#123;name&#125;” == &quot;Mrcode&quot; ] 就变成了 [ “Mrcode Test”  == &quot;Mrcode&quot; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了以上注意之外，中括号使用方式与 <strong>test</strong> 几乎一模一样，只是中括号比较常用在 <strong>条件判断 if…then..fi</strong> 的情况中。</p>
<p>实践范例需求如下：</p>
<ol>
<li>当执行一个程序的时候，要求用户选择 <strong>Y</strong> 或 <strong>N</strong></li>
<li>如果用户输入 <strong>Y</strong> 或 <strong>y</strong> 时，就显示「<strong>Ok，continue</strong>」</li>
<li>如果用户输入 <strong>N</strong> 或 n 时，就显示「<strong>Oh，interrupt！</strong>」</li>
<li>如果不是以上规定字符，则显示「<strong>I don’t know what your choice is</strong>」</li>
</ol>
<p>利用中括号、<code>&amp;&amp;</code>、<code>||</code> 来达成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi ans_yn.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#	This program shows the user&#x27;s choice</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#	2020/01/20		mrcode		first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入 Y/N：&quot;</span> yn</span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> -o <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Ok，continue&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;N&quot;</span> -o <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;n&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Oh，interrupt！&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know what your choice is&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里报错时因为 [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; || &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]  中使用了 || 来达成条件判定</span></span><br><span class="line">[mrcode@study bin]$ ./ans_yn.sh </span><br><span class="line">请输入 Y/N：n</span><br><span class="line">./ans_yn.sh: 第 10 行:[: 缺少 `]<span class="string">&#x27;</span></span><br><span class="line"><span class="string">./ans_yn.sh:行10: n: 未找到命令</span></span><br><span class="line"><span class="string">./ans_yn.sh: 第 11 行:[: 缺少 `]&#x27;</span></span><br><span class="line">./ans_yn.sh:行11: n: 未找到命令</span><br><span class="line">I don<span class="string">&#x27;t know what your choice is</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] 使用了 test 中的参数， -o 只要任意一个成立都算 true</span></span><br><span class="line"><span class="string"># 程序正常</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ vim ans_yn.sh </span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./ans_yn.sh </span></span><br><span class="line"><span class="string">请输入 Y/N：n</span></span><br><span class="line"><span class="string">Oh，interrupt！</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./ans_yn.sh </span></span><br><span class="line"><span class="string">请输入 Y/N：y</span></span><br><span class="line"><span class="string">Ok，continue</span></span><br><span class="line"><span class="string">[mrcode@study bin]$ ./ans_yn.sh </span></span><br><span class="line"><span class="string">请输入 Y/N：</span></span><br><span class="line"><span class="string">I don&#x27;</span>t know what your choice is</span><br></pre></td></tr></table></figure>

<h3 id="shell-script-的默认变量-0-1"><a href="#shell-script-的默认变量-0-1" class="headerlink" title="shell script 的默认变量 $0,$1..."></a>shell script 的默认变量 <code>$0,$1...</code></h3><p>指令可以带有选项与参数，如 <code>ls -la</code> 可以查看包含隐藏文件的所有属性。那么 <strong>script</strong> 也可以携带参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动系统的网络</span></span><br><span class="line">[mrcode@study bin]$ file /etc/init.d/network </span><br><span class="line">/etc/init.d/network: Bourne-Again shell script, ASCII text executable</span><br><span class="line"><span class="comment"># 利用 file 指令查询该文件，显示是个可执行的 shell script 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里携带 restart 参数，如果替换成 stop 参数就是关闭该服务了</span></span><br><span class="line">[mrcode@study bin]$ /etc/init.d/network restart </span><br></pre></td></tr></table></figure>

<p><strong>read</strong> 是使用过程中需要手动输入，而参数是可以跟随在执行命令后的，这样就比较方便</p>
<p><strong>script</strong> 针对参数已经设置好一些变量名称了，对应如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/path/to/scriptname		opt1	opt2	opt3	opt4</span><br><span class="line"> 		&amp;0				 &amp;1		 &amp;2		 &amp;3		 &amp;4</span><br></pre></td></tr></table></figure>

<p>除了这些数字的变量参数外，还有一些较为特殊的变量可以使用</p>
<ul>
<li><code>$#</code>：代表后接的参数「个数」，以上表为例这里显示「<strong>4</strong>」</li>
<li><code>$@</code>：代表 「<code>&quot;&amp;1&quot; &quot;&amp;2&quot; &quot;&amp;3&quot; &quot;&amp;4&quot;</code>」 的意思，每个变量是独立的（用双引号括起来）</li>
<li><code>$*</code>：代表「<code>&quot;&amp;1c&amp;2c&amp;3c&amp;4&quot;</code>」，其中 <strong>c</strong> 为分隔符，默认为空格，所以本例中代表「<code>&quot;&amp;1 &amp;2 &amp;3 &amp;4&quot;</code>」</li>
</ul>
<p><code>$@ 与 $*</code> 基本上还是有所不同，一般使用 <code>$@</code> 较多。</p>
<p>范例需求：输出如下数据</p>
<ul>
<li>程序的文件名</li>
<li>共有几个参数</li>
<li>若参数小于 <strong>2</strong> ，则告知使用者参数数量太少</li>
<li>全部的参数内容</li>
<li>第一个参数</li>
<li>第二个参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vi prit_info.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       输出脚本文件名，与相关参数信息</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"><span class="comment"># 这样写，语法是错误的，要记得这里是使用 test 里面的语法</span></span><br><span class="line"><span class="comment"># 并且，不能用 $&#123;变量&#125; 的方式来写</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;$#&#125;</span>&quot;</span> &lt; <span class="string">&quot;2&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;参数数量太少，比如大于等于 2 个&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./print_info.sh </span><br><span class="line">./print_info.sh</span><br><span class="line">0</span><br><span class="line">./print_info.sh:行11: 2: 没有那个文件或目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./print_info.sh a b</span><br><span class="line">./print_info.sh</span><br><span class="line">2</span><br><span class="line">./print_info.sh:行11: 2: 没有那个文件或目录</span><br><span class="line">a b</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>以下是书上的写法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vi how_paras.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       输出脚本文件名，与相关参数信息</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The script name is			==&gt; <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -lt 2 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;参数数量太少，比如大于等于 2 个&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The 1st parameter 			==&gt; <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The 2nd parameter 			==&gt; <span class="variable">$2</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./how_paras.sh </span><br><span class="line">The script name is			==&gt; ./how_paras.sh</span><br><span class="line">Total parameter number is		==&gt; 0</span><br><span class="line">参数数量太少，比如大于等于 2 个</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./how_paras.sh a b</span><br><span class="line">The script name is			==&gt; ./how_paras.sh</span><br><span class="line">Total parameter number is		==&gt; 2</span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b&#x27;</span></span><br><span class="line">The 1st parameter 			==&gt; a</span><br><span class="line">The 2nd parameter 			==&gt; b</span><br></pre></td></tr></table></figure>

<h3 id="shift：造成参数变量位置偏移"><a href="#shift：造成参数变量位置偏移" class="headerlink" title="shift：造成参数变量位置偏移"></a>shift：造成参数变量位置偏移</h3><p>先修改下上面的范例，<code>how_paras.sh</code> 先来看看效果什么是偏移</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vi how_paras.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Program shows the effect of shift function</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27; \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span>	<span class="comment"># 进行第一次 一个变量的 shift</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27; \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> 3	<span class="comment"># 进行第二次 三个变量的 shift</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total parameter number is		==&gt; <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your whole parameter is		==&gt; &#x27;<span class="variable">$@</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./how_paras.sh a b c d e f</span><br><span class="line">Total parameter number is		==&gt; 6		<span class="comment"># 位偏移的参数数量，是 6 个</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b c d e f&#x27;</span></span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 5		<span class="comment"># 偏移一次后，只剩下 5 个，并且第一个参数 a 不见了</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c d e f&#x27;</span></span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 2		<span class="comment"># 第二次偏移掉 3 个后，b c d 不见了</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;e f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来看看如果参数不够偏移会出现什么情况</span></span><br><span class="line">[mrcode@study bin]$ ./how_paras.sh a b c	<span class="comment"># 给 3 个参数</span></span><br><span class="line">Total parameter number is		==&gt; 3</span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b c&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 2		<span class="comment"># 第一次偏移 1 个，只生效 2 个了</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 2		<span class="comment"># 第二次偏移 3 个，发现没有生效，不够偏移</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./how_paras.sh a b c d		<span class="comment"># 给 4 个参数</span></span><br><span class="line">Total parameter number is		==&gt; 4</span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;a b c d&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 3		<span class="comment"># 第一次偏移 1 个，还剩下 3 个</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;b c d&#x27;</span> </span><br><span class="line"></span><br><span class="line">Total parameter number is		==&gt; 0		<span class="comment"># 第二次偏移 3 个，剩下 0 个</span></span><br><span class="line">Your whole parameter is		==&gt; <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>总结如下：</p>
<ul>
<li><strong>shift</strong> 可以忽略掉 <strong>n</strong> 个参数</li>
<li><strong>shif</strong> 中的 <strong>n</strong> 必须要有足够的参数才会生效，否则不会偏移</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>在程序中，没有条件判断 <code>if then</code> 方式的话，在执行多条指令的时候，就会很麻烦。</p>
<h3 id="利用-if-then"><a href="#利用-if-then" class="headerlink" title="利用 if...then"></a>利用 <code>if...then</code></h3><p><strong>单层、简单条件判断</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 表达式 ]; <span class="keyword">then</span></span><br><span class="line">	当条件成立时，可以进行的指令工作内容</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>至于表达式的编码，与上一章的 <strong>test</strong> 一致，但是有一个特别的是，可以使用 <code>&amp;&amp;</code> 与 <code>||</code> 来连接多个中括号，在这里他们的含义就是表示 并且 和 或者 的意思</p>
<p>所以在使用中括号的时候， <code>&amp;&amp;</code> 和 <code>||</code> 与指令状态下的含义不同。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> -o <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]</span><br><span class="line">可以替换为下面的方式</span><br><span class="line">[ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>这样就很方便维护了，一个中括号一个表达式。那么将这个 <strong>script</strong> 修改为 <code>if...then</code> 的形式如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ vi ans_yn.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows the user&#x27;s choice</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入 Y/N：&quot;</span> yn</span><br><span class="line"><span class="comment"># [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;Ok，continue&quot; &amp;&amp; exit 0</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Ok，continue&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh，interrupt！&quot; &amp;&amp; exit 0</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;N&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;n&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Oh，interrupt！&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know what your choice is&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>此方式只是在代码组织上更偏向于笔者所学的 JAVA 语言了，对于变量的判定还可以使用如下的多重判断来达到效果</p>
<p><strong>多重、复杂条件判断</strong></p>
<p>简单说，上述实例对于变量 <code>$&#123;yn&#125;</code> 使用了两次 <strong>if</strong>，那么可以使用如下方式简化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件表达式 ]; <span class="keyword">then</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>更复杂的情况，增加 <strong>elseif</strong> ，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件表达式 ]; <span class="keyword">then</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">elif</span> [ 条件表达式 ]; <span class="keyword">then</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	做点啥</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>改写 <code>ans_yn.sh</code> 脚本如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows the user&#x27;s choice</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入 Y/N：&quot;</span> yn</span><br><span class="line"><span class="comment"># [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;Ok，continue&quot; &amp;&amp; exit 0</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Ok，continue&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Oh，interrupt！&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know what your choice is&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>另一个范例知识，上一节提到参数功能（**$1<strong>），让用户在下达指令的时候将参数带进去，让用户输入 **hello</strong> 关键词，利用参数的方法可以如下设计：</p>
<ol>
<li>判断 <code>$1</code> 是否为 <strong>hello</strong> ，如果是，则显示「**Hello, how ary you?**」</li>
<li>如果无参数，则提示使用者必须要使用的参数下达方法</li>
<li>如果参数不是 <strong>hello</strong>，则提示使用者仅能使用 <strong>hello</strong> 为参数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       直接携带参数提示</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;hello&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;请携带参数&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;只能携带参数 hello&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./hello-2.sh </span><br><span class="line">请携带参数</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hello</span><br><span class="line">Hello, how ary you?</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hellox</span><br><span class="line">只能携带参数 hello</span><br></pre></td></tr></table></figure>

<p>书上例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Chek $1 is equal to &quot;hello&quot;</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;hello&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;You MUST input parameters, ex&gt; &#123;<span class="variable">$&#123;0&#125;</span> someword&#125;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;The only parameter is &#x27;hello&#x27;, ex&gt; &#123;<span class="variable">$&#123;0&#125;</span> hello&#125;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>信息输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./hello-2.sh </span><br><span class="line">You MUST input parameters, ex&gt; &#123;./hello-2.sh someword&#125;</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hell</span><br><span class="line">The only parameter is <span class="string">&#x27;hello&#x27;</span>, ex&gt; &#123;./hello-2.sh hello&#125;</span><br><span class="line">[mrcode@study bin]$ ./hello-2.sh hello</span><br><span class="line">Hello, how ary you?</span><br></pre></td></tr></table></figure>

<p>那么深入练习。</p>
<p>在第十章学习了 grep 指令，现在多了解一个 netstat 指令，可以查询到目前主机有开启的网络服务端口（service ports），相关功能会在 <strong>服务器架设篇</strong> 继续介绍；这里只需要知道 <code>netstat -tuln</code>可以取得目前主机有启动的服务，而且取得的信息类似下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ netstat -tuln</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line"><span class="comment"># 封包格式			 本地 IP:端口			  远程 IP:端口				是否监听</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:6011                :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN     </span><br><span class="line">udp        0      0 0.0.0.0:48829           0.0.0.0:*                          </span><br><span class="line">udp        0      0 192.168.122.1:53        0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:67              0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                          </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:672             0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                          </span><br><span class="line">udp6       0      0 :::111                  :::*                               </span><br><span class="line">udp6       0      0 ::1:323                 :::*                               </span><br><span class="line">udp6       0      0 :::672                  :::*  </span><br></pre></td></tr></table></figure>

<p>重点关注 <strong>Local Address</strong> 字段（本地主机 <strong>IP</strong> 与端口对应），代表本机所启动的网络服务，<strong>127.0.0.1</strong> 则是针对本机开放，若是 <strong>0.0.0.0 或 :::</strong> 则代表对整个 <strong>Internet</strong> 开放。每个端口 <strong>port</strong> 都有其特定的网络服务，几个常见的 <strong>port</strong> 与网络服务的关系是：</p>
<ul>
<li><strong>80</strong>：<strong>www</strong></li>
<li><strong>22</strong>：<strong>ssh</strong></li>
<li><strong>21</strong>：<strong>ftp</strong></li>
<li><strong>25</strong>：<strong>mail</strong></li>
<li><strong>111</strong>：<strong>RPC</strong></li>
<li><strong>631</strong>：<strong>CUPS</strong>（打印服务功能）</li>
</ul>
<p>假设我要检测常见端口 <strong>port 21、22、25、80</strong> 时，可以通过 <strong>netstat</strong> 检测主机是否有开启这四个主要的网络服务端口，由于每个服务的关键词都是接在冒号「**:<strong>」后面，所以可以截取类似「</strong>:80**」来检测。那么程序如下</p>
<p>下面是笔者写的脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim netstat.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;现在开始检测当前主机上的服务&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;www、ftp、mail、www 服务将被检测 \n&quot;</span></span><br><span class="line"><span class="comment"># 将 local Address 字段截取出来</span></span><br><span class="line">datas=$(netstat -tuln | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line">testing=$(grep <span class="string">&quot;:80&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;www&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:22&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;ssh&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:21&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;ftp&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:25&quot;</span> <span class="variable">$&#123;datas&#125;</span>) </span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;mail&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>不过很遗憾，<strong>grep</strong> 后只能跟一个文件路径。那么正确的做法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Using netstat and grep to detect www⽀~Assh⽀~Aftp and mail services</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 佅~H佑~J潟¥彎¥䷾K彝¥襾A佁~Z亾@举H</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;潎°作¨廾@妾K梾@派K弾S佉~M主彜º䷾J潚~D彜~M佊¡&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;www⽀~Aftp⽀~Amail⽀~Awww 彜~M佊¡対F被梾@派K \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 达[蠾L佈¤孾Z佒~L信彁¯轾S佇º </span></span><br><span class="line"><span class="comment"># 対F local Address 嬾W段彈ª住~V佇º彝¥﻾L并潔~_彈~P彖~G件</span></span><br><span class="line">testfile=/dev/shm/netstat_checking.txt</span><br><span class="line">netstat -tuln | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> &gt; <span class="variable">$&#123;testfile&#125;</span></span><br><span class="line"></span><br><span class="line">testing=$(grep <span class="string">&quot;:80&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;www is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">testing=$(grep <span class="string">&quot;:22&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ssh  is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">testing=$(grep <span class="string">&quot;:21&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ftp  is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">testing=$(grep <span class="string">&quot;:25&quot;</span> <span class="variable">$&#123;testfile&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$&#123;testing&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;mail  is running in you system. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>输出信息如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./netstat.sh </span><br><span class="line">现在开始检测当前主机上的服务</span><br><span class="line">www、ftp、mail、www 服务将被检测 </span><br><span class="line"></span><br><span class="line">ssh  is running <span class="keyword">in</span> you system. </span><br><span class="line">mail  is running <span class="keyword">in</span> you system.</span><br></pre></td></tr></table></figure>

<p>条件判断还可以更复杂，比如：在台湾当兵是国民应尽的义务，不过，在当兵的时候总是很想退伍，那么写个脚本程序来实现：让用户输入他的退伍日期，计算出还有多少天才退伍？的功能</p>
<p>那么思路如下：</p>
<ol>
<li>用户输入自己的退伍日期</li>
<li>由现在的日期对比退伍日期</li>
<li>由两个日期的比较来显示「还需要几天」才能够退伍的字样</li>
</ol>
<p>温馨提示：日期可以使用 <code>date --date=&quot;YYYYMMDD&quot; +%s</code> 来取得指定日期的秒数，再利用秒数相减，再计算到天</p>
<p>笔者从现在开始，就不再贴出自己写的代码了，先自己写，然后对照书上的，最后部分修改成书上的展示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vim cal_retired.sh</span><br><span class="line">  </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       You input you demobilization date,I calculate how many days before you demobilize.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 告知用户程序的用途，并且告知应该如何输入日期格式</span></span><br><span class="line"><span class="comment"># 这个程序将尝试计算出，您的退伍日期还有多少天</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This program will try to calculate :&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;How many days before your demobilization date...&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input your demobilization date (YYYYMMDD ex&gt;20200112)：&quot;</span> date2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 测试判定，输入内容是否正确，使用正则表达式</span></span><br><span class="line">date_d=$(<span class="built_in">echo</span> <span class="variable">$&#123;date2&#125;</span> | grep <span class="string">&#x27;[0-9]\&#123;8\&#125;&#x27;</span>)             <span class="comment"># 匹配 8 位数的字符串</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;date_d&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 您输入了错误的日期格式</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;You input the wrong date format...&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 开始计算日期</span></span><br><span class="line"><span class="built_in">declare</span> -i date_dem=$(date --date=<span class="string">&quot;<span class="variable">$&#123;date_d&#125;</span>&quot;</span> +%s)              <span class="comment"># 退伍日期秒数</span></span><br><span class="line"><span class="built_in">declare</span> -i date_now=$(date +%s)                                 <span class="comment"># 当前日期秒数</span></span><br><span class="line"><span class="built_in">declare</span> -i date_total_s=$((<span class="variable">$&#123;date_dem&#125;</span>-<span class="variable">$&#123;date_now&#125;</span>))    		<span class="comment"># 剩余秒数</span></span><br><span class="line"><span class="comment"># 需要注意的是：这种嵌套执行的时候，括号一定要嵌套对位置</span></span><br><span class="line"><span class="built_in">declare</span> -i date_d=$((<span class="variable">$&#123;date_total_s&#125;</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>))                 <span class="comment"># 转换为日</span></span><br><span class="line"><span class="comment"># 中括号里面不能直接使用 &lt; 这种符号</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;date_total_s&#125;</span>&quot;</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="comment"># 这里是用 -1 乘，得到是正数，标识已经退伍多少天了</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;You had been demobilization before:  <span class="subst">$((-1*$&#123;date_d&#125;)</span>)  ago&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 这里使用 总秒数 - 转换为日的变量（这里只是转换为了天），剩余数据转成小时</span></span><br><span class="line">        <span class="comment"># 则计算到 n 天 n 小时</span></span><br><span class="line">        <span class="built_in">declare</span> -i date_h=$(($((<span class="variable">$&#123;date_total_s&#125;</span>-<span class="variable">$&#123;date_d&#125;</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>))/60/60))</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;You will demobilize after <span class="variable">$&#123;date_d&#125;</span> days and <span class="variable">$&#123;date_h&#125;</span> hours.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20200120	<span class="comment"># 输入当天</span></span><br><span class="line">You had been demobilization before:  0  ago</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20200119	<span class="comment"># 输入前一天</span></span><br><span class="line">You had been demobilization before:  1  ago</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20200121	<span class="comment"># 输入明天</span></span><br><span class="line">You will demobilize after 0 days and 8 hours.</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：2020^H^H3	<span class="comment"># 输入错误的格式</span></span><br><span class="line">You input the wrong date format...</span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./cal_retired.sh </span><br><span class="line">This program will try to calculate :</span><br><span class="line">How many days before your demobilization date...</span><br><span class="line">Please input your demobilization date (YYYYMMDD ex&gt;20200112)：20300120	<span class="comment"># 输入10 年后</span></span><br><span class="line">You will demobilize after 3652 days and 8 hours.</span><br></pre></td></tr></table></figure>

<p>笔者总结：</p>
<ul>
<li>本例结合了 <strong>grep</strong> 查找符合条件的参数，如果完全不符合，则为空白返回了</li>
<li>结合了 <strong>declare -i</strong> 定义整数变量</li>
<li>使用了 <code>$(($(())))</code> 嵌套指令执行语法</li>
<li>该范例还是有难度的，难点在于 用正则检查输入参数 和 计算 天 并计算小时</li>
</ul>
<h3 id="利用-case-esac-判断"><a href="#利用-case-esac-判断" class="headerlink" title="利用 case...esac 判断"></a>利用 <code>case...esac</code> 判断</h3><p>作为 <strong>JAVA</strong> 程序员，这个不用多解释，直接看语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名称 <span class="keyword">in</span>		<span class="comment"># 关键词为 case 还有 变量前的 $ 符号</span></span><br><span class="line">	“变量内容 1”)		<span class="comment"># 每个变量内容建议用双引号括起来，关键词则为小括号</span></span><br><span class="line">	 	程序段</span><br><span class="line">	 ;;				  <span class="comment"># 使用两个连续的分号来结尾</span></span><br><span class="line">	“变量内容 2”)</span><br><span class="line">	 	程序段</span><br><span class="line">	 ;;</span><br><span class="line">	*)			 	  <span class="comment"># 最后一个变量内容需要用 * 来代表所有其他值</span></span><br><span class="line">		程序段</span><br><span class="line">	 ;;</span><br><span class="line"><span class="keyword">esac</span>				  <span class="comment"># 最终的 case 结尾，就是反过来拼写的字符 esac</span></span><br></pre></td></tr></table></figure>

<p>将上面 <code>./hello-2.sh</code> 的例子使用该语法修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">./hello-3.sh </span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       直接携带参数提示</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">	<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Hello, how ary you?&quot;</span></span><br><span class="line">	;;</span><br><span class="line">	<span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;请携带参数&quot;</span></span><br><span class="line">	;;</span><br><span class="line">	*)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;只能携带参数 hello&quot;</span></span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>此种判定方式，针对于判定字符串时会更加的方便，<strong>CentOS6.x</strong> 以前系统很多服务的启动都是使用使用这种写法写的。虽然 <strong>CentOS7</strong> 已经使用 <strong>systemd</strong> ，不过任然有数个服务时放在 <code>/etc/init.d</code> 目录下的、比如有个名为 <code>netconsole</code> 的服务在该目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动该服务</span></span><br><span class="line"><span class="comment"># 注意该服务需要使用 root 身份才行，一般账户可以执行，但是不会成功</span></span><br><span class="line">/etc/init.d/netconsole restart</span><br></pre></td></tr></table></figure>

<p>查阅该文件，找到文件末尾为发现以下的内容，这里就判定了输入的参数，使用的就是 case 语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    stop) stop ;;</span><br><span class="line">    status) status ;;</span><br><span class="line">    start|restart|reload|force-reload) restart ;;</span><br><span class="line">    condrestart) condrestart ;;</span><br><span class="line">    *) usage ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>所以对于脚本的编写，可以参考这些已经有的，看看人家是怎么写的</p>
<p>一般来说，使用「<code>case $变量 in</code>」语法，那个变量大致有两种取得方式：</p>
<ul>
<li>直接下达：利用 <code>script.sh variable</code> 方式直接给 <strong>$1</strong> 变量，这也是在 <code>/etc/init.d</code> 目录下大多数程序的设计方式</li>
<li>交互式：通过 <strong>read</strong> 指令让用户输入变量内容</li>
</ul>
<p>下面来演示下：</p>
<ul>
<li>用户输入 <code>one、two、three</code> 并显示在屏幕上</li>
<li>如果不是以上变量，那么提示用户只有这三种选择</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim show123.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如需要让用户交互性输入，那么可以用这两行代替：case &quot;$1&quot; in</span></span><br><span class="line"><span class="comment"># read -p &quot;请输入您的选择：&quot; choice</span></span><br><span class="line"><span class="comment"># case &quot;$&#123;choice&#125;&quot; in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">	<span class="string">&quot;one&quot;</span>) <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	<span class="string">&quot;two&quot;</span>) <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	<span class="string">&quot;three&quot;</span>) <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">&quot;只能输入 one、two、three&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./show123.sh </span><br><span class="line">只能输入 one、two、three</span><br><span class="line">[mrcode@study bin]$ ./show123.sh one</span><br><span class="line">one</span><br><span class="line">[mrcode@study bin]$ ./show123.sh two</span><br><span class="line">two</span><br><span class="line">[mrcode@study bin]$ ./show123.sh three</span><br><span class="line">three</span><br><span class="line">[mrcode@study bin]$ ./show123.sh three111</span><br><span class="line">只能输入 one、two、three</span><br></pre></td></tr></table></figure>

<h3 id="利用-function-功能"><a href="#利用-function-功能" class="headerlink" title="利用 function 功能"></a>利用 function 功能</h3><p>函数功能，不用多说，可以被复用，优化程序结构，语法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fname</span></span>()&#123;</span><br><span class="line">	程序段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><p><strong>TIP</strong></p>
<p>由于 <strong>shell script</strong> 执行方式是由上而下，由左而右，因此 <strong>function</strong> 的代码一定要在程序的最前面</p>
</div>

<p>下面将 <strong>show123.sh</strong> 改写成使用 <strong>function</strong> 方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim show123-2.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如需要让用户交互性输入，那么可以用这两行代替：case &quot;$1&quot; in</span></span><br><span class="line"><span class="comment"># read -p &quot;请输入您的选择：&quot; choice</span></span><br><span class="line"><span class="comment"># case &quot;$&#123;choice&#125;&quot; in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printit</span></span>()&#123;</span><br><span class="line">	<span class="built_in">echo</span> -n <span class="string">&quot;Your choice is &quot;</span> <span class="comment"># -n 可以不断行连续在同一行显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">	<span class="string">&quot;one&quot;</span>) printit; <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	<span class="string">&quot;two&quot;</span>) printit; <span class="built_in">echo</span> <span class="variable">$1</span> | tr <span class="string">&#x27;a-z&#x27;</span> <span class="string">&#x27;A-z&#x27;</span> ;;  <span class="comment"># 转换为大写</span></span><br><span class="line">	<span class="string">&quot;three&quot;</span>) printit; <span class="built_in">echo</span> <span class="variable">$1</span> ;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">&quot;只能输入 one、two、three&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>输出信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./show123-2.sh one</span><br><span class="line">Your choice is one</span><br><span class="line">[mrcode@study bin]$ vim show123-2.sh</span><br><span class="line">[mrcode@study bin]$ ./show123-2.sh tow</span><br><span class="line">只能输入 one、two、three</span><br><span class="line">[mrcode@study bin]$ ./show123-2.sh two</span><br><span class="line">Your choice is TWO</span><br></pre></td></tr></table></figure>

<p>上述代码，做了一个打印部分重复信息的功能，这个例子比较简单，当在程序中有大量重复，和大量逻辑的时候，就会体现出来了</p>
<p>同样，<strong>function</strong> 也可以有参数变量，改写成有参数调用函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim show123-3.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/01/20              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printit</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Your choice is <span class="variable">$&#123;1&#125;</span>&quot;</span> <span class="comment"># 在函数域中，的参数变量，与外部的不一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;one&quot;</span>) printit 1 ;;</span><br><span class="line">        <span class="string">&quot;two&quot;</span>) printit 2 ;;</span><br><span class="line">        <span class="string">&quot;three&quot;</span>) printit <span class="variable">$1</span> ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;只能输入 one、two、three&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./show123-3.sh one</span><br><span class="line">Your choice is 1			</span><br><span class="line">[mrcode@study bin]$ ./show123-3.sh two</span><br><span class="line">Your choice is 2 	<span class="comment"># 可以看到，这里给定参数 1，那么在里面获取 $&#123;1&#125;，的时候就获取到了</span></span><br><span class="line"></span><br><span class="line">[mrcode@study bin]$ ./show123-3.sh three		</span><br><span class="line">Your choice is three	<span class="comment"># 在外部给定的是脚本中的变量 $1, 在内部也能获取到变量的具体内容</span></span><br><span class="line">[mrcode@study bin]$ ./show123-3.sh threex</span><br><span class="line">只能输入 one、two、three</span><br></pre></td></tr></table></figure>

<h2 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h2><p>循环可以不断执行某个程序段楼，直到用户设定的条件达成为止。</p>
<h3 id="while-do-done、until-do-done（不定循环）"><a href="#while-do-done、until-do-done（不定循环）" class="headerlink" title="while do done、until do done（不定循环）"></a>while do done、until do done（不定循环）</h3><p>当条件成立时，执行循环体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]   <span class="comment"># 中括号中条件判断</span></span><br><span class="line"><span class="keyword">do</span>    <span class="comment"># 循环开始</span></span><br><span class="line">  程序段落</span><br><span class="line"><span class="keyword">done</span>  <span class="comment"># 循环结束</span></span><br></pre></td></tr></table></figure>

<p>还有一种不定循环的方式，当条件成立时退出循环体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    程序段落</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>范例：让使用者输入 <strong>yes</strong> 或则是 <strong>YES</strong> 才结束程序的执行，否则就一直告知用户输入字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim yes_to_stop.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> != <span class="string">&#x27;yes&#x27;</span> -a <span class="string">&quot;<span class="variable">$&#123;yn&#125;</span>&quot;</span> != <span class="string">&#x27;YES&#x27;</span> ]</span><br><span class="line"><span class="comment"># 使用 until 则是如下</span></span><br><span class="line"><span class="comment"># until [ &quot;$&#123;yn&#125;&quot; == &#x27;yes&#x27; -o &quot;$&#123;yn&#125;&quot; == &#x27;YES&#x27; ]</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">read</span> -p <span class="string">&#x27;请输入 yes 或 YES 退出程序&#x27;</span> yn</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你输入了正确答案&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./yes_to_stop.sh</span><br><span class="line">请输入 yes 或 YES 退出程序j</span><br><span class="line">请输入 yes 或 YES 退出程序jj</span><br><span class="line">请输入 yes 或 YES 退出程序yes</span><br><span class="line">你输入了正确答案</span><br></pre></td></tr></table></figure>

<p>如果想要计算 <code>1+2+3+..100</code>则如下写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim cal_1_100.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       计算 1+2+3+..100 的结果</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">total=0	<span class="comment"># 计算结果</span></span><br><span class="line">i=0			<span class="comment"># 当前数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;i&#125;</span>&quot;</span> != 100 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	i=$((<span class="variable">$i</span>+<span class="number">1</span>))		<span class="comment"># 每次增加 1</span></span><br><span class="line">	total=$((<span class="variable">$total</span>+<span class="variable">$i</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1+2+3+..100 = <span class="variable">$&#123;total&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="for-do-done-固定循环"><a href="#for-do-done-固定循环" class="headerlink" title="for...do...done 固定循环"></a><code>for...do...done</code> 固定循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3 ...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	循环体</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>范例：假设有三种动物，分别是 <strong>dog</strong>、<strong>cat</strong>、<strong>elephant</strong> 三种，输出三行信息，如 <code>There are dogs...</code> 之类的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim show_animal.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;There are <span class="variable">$&#123;animal&#125;</span>s...&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>/etc/passwd</strong> 中第一个字段存放了用户名，使用循环打印出每个用户名的 <strong>id</strong> 信息；可使用 <strong>cut</strong> 截取第一字段，使用 <strong>id</strong>指令获取用户名的信息（标识符与特殊参数）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim userid.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">users=$(cut -d <span class="string">&#x27;:&#x27;</span> -f1 /etc/passwd)		<span class="comment"># 获取到所有的用户名</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> <span class="variable">$&#123;users&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	id <span class="variable">$&#123;user&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然还可以使用数字来做循环项，比如需要执行 <code>ping 192.168.1.1~192.168.1.100</code> 也就是从 <strong>1 ping</strong> 到 <strong>100</strong>，但是不可能需要我们手动输入 <strong>100</strong> 个数字吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim pingip.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">network=<span class="string">&quot;192.168.0&quot;</span>			<span class="comment"># 先定义一个网域的前部分</span></span><br><span class="line"><span class="keyword">for</span> sitenu <span class="keyword">in</span> $(seq 1 100)	<span class="comment"># seq 为 sequence 连续的意思</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="comment"># ping -c 1 -w 1 192.168.0.101 &amp;&gt; /dev/null &amp;&amp; echo &quot;1&quot; || echo &quot;0&quot;</span></span><br><span class="line">	<span class="comment"># 不显示执行结果，并获取命令是否执行成功</span></span><br><span class="line">	ping -c 1 -w 1 <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> &amp;&gt; /dev/null &amp;&amp; result=0 || result=1</span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;result&#125;</span>&quot;</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is up&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is down&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./pingip.sh</span><br><span class="line">192.168.0.1 is up</span><br><span class="line">192.168.0.2 is down</span><br><span class="line">192.168.0.3 is down</span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p>对于 <code>$(seq 1 100)</code> 来说，还可以使用 <strong>bash</strong> 的内建机制 <code>&#123;1..100&#125;</code> 来代替，中间两个点表示连续的意思，比如想要输出 <strong>a~g</strong> 则可以使用 <code>a..g</code></p>
<p>最后一个范例：</p>
<ol>
<li>让用户输入一个目录</li>
<li>如果目录不存在，则提示并退出程序</li>
<li>如果目录存在，则获取该目录下第一级文件是否可读、可写、可执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vim dir_perm.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个目录，将会检测该目录是否可读、可写、可执行：&quot;</span> dir</span><br><span class="line"><span class="comment"># 判定输入不为空，并且目录存在</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span> == <span class="string">&#x27;&#x27;</span> -o ! -d <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;The <span class="variable">$&#123;dir&#125;</span> is NOT exist in your system&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取该目录下的文件权限信息</span></span><br><span class="line">filelist=$(ls <span class="variable">$&#123;dir&#125;</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;filelist&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        perm=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">test</span> -r <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&quot;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> readable&quot;</span></span><br><span class="line">        <span class="built_in">test</span> -w <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&quot;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> writable&quot;</span></span><br><span class="line">        <span class="built_in">test</span> -x <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&quot;</span> &amp;&amp; perm=<span class="string">&quot;<span class="variable">$&#123;perm&#125;</span> executable&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;The file <span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;file&#125;</span>&#x27;s permission is <span class="variable">$&#123;perm&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用这种方式，可以很轻易的来处理一些文件的特性</p>
<h3 id="for-do-done-数值处理"><a href="#for-do-done-数值处理" class="headerlink" title="for...do...done 数值处理"></a><code>for...do...done</code> 数值处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( 初始值; 限制值; 执行步阶))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	循环体</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始值：某个变量在循环中的起始值，可以以 <strong>i=1</strong> 设置好初始值</li>
<li>限制值：当变量值在这个限制值范围内，则继续循环。例如 <strong>i&lt;=100</strong></li>
<li>执行步阶：每执行一次循环时，变量的变化量。例如 <strong>i=i+1</strong>，如果是自增则可以使用 <strong>i++</strong> 来替代</li>
</ul>
<p>范例：计算从 <strong>1</strong> 累加到指定数值的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim cal_1_100-2.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个数值，将计算出从 1 累加到该数值的计算结果&quot;</span> nu</span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=<span class="variable">$&#123;nu&#125;</span>; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	total=$((<span class="variable">$&#123;total&#125;</span>+<span class="variable">$&#123;i&#125;</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1+..+<span class="variable">$&#123;nu&#125;</span> = <span class="variable">$&#123;total&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./cal_1_100-2.sh</span><br><span class="line">请输入一个数值，将计算出从 1 累加到该数值的计算结果2</span><br><span class="line">1+..+2 = 3</span><br><span class="line">[mrcode@study bin]$ ./cal_1_100-2.sh</span><br><span class="line">请输入一个数值，将计算出从 1 累加到该数值的计算结果100</span><br><span class="line">1+..+100 = 5050</span><br></pre></td></tr></table></figure>

<h3 id="搭配随机数与数组的实验"><a href="#搭配随机数与数组的实验" class="headerlink" title="搭配随机数与数组的实验"></a>搭配随机数与数组的实验</h3><p>现在大概已经能够掌握 <strong>shell script</strong> 了。</p>
<p>现在来做个有趣的小东西，今天中午吃啥？要完成这个脚本，首先需要将全部的店家输入到一组数组中，再通过随机数的处理，获得可能的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vim what_to_eat.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义你搜集到的店家信息</span></span><br><span class="line">eat[1]=<span class="string">&quot;卖当当汉堡&quot;</span></span><br><span class="line">eat[2]=<span class="string">&quot;肯爷爷炸鸡&quot;</span></span><br><span class="line">eat[3]=<span class="string">&quot;彩虹日式便当&quot;</span></span><br><span class="line">eat[4]=<span class="string">&quot;越油越好吃打呀&quot;</span></span><br><span class="line">eat[5]=<span class="string">&quot;想不出吃什么&quot;</span></span><br><span class="line">eat[6]=<span class="string">&quot;太师傅便当&quot;</span></span><br><span class="line">eat[7]=<span class="string">&quot;池上便当&quot;</span></span><br><span class="line">eat[8]=<span class="string">&quot;怀恋火车便当&quot;</span></span><br><span class="line">eat[9]=<span class="string">&quot;一起吃泡面&quot;</span></span><br><span class="line">eat[10]=<span class="string">&quot;太上皇&quot;</span></span><br><span class="line">eatnum=10		<span class="comment"># 一共有几家可用的店铺</span></span><br><span class="line"></span><br><span class="line">check=$((<span class="variable">$&#123;RANDOM&#125;</span> * <span class="variable">$&#123;eatnum&#125;</span> / <span class="number">32767</span> + <span class="number">1</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your may eat <span class="variable">$&#123;eat[<span class="variable">$&#123;check&#125;</span>]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br><span class="line">your may eat 太上皇</span><br><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br><span class="line">your may eat 越油越好吃打呀</span><br><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br><span class="line">your may eat 想不出吃什么</span><br><span class="line">[mrcode@study bin]$ ./what_to_eat.sh</span><br></pre></td></tr></table></figure>

<p>继续深入，一次性输出 3 个选择，并且不能重复</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vim what_to_eat-2.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment">#       2020/02/12              mrcode          first relese</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义你搜集到的店家信息</span></span><br><span class="line">eat[1]=<span class="string">&quot;卖当当汉堡&quot;</span></span><br><span class="line">eat[2]=<span class="string">&quot;肯爷爷炸鸡&quot;</span></span><br><span class="line">eat[3]=<span class="string">&quot;彩虹日式便当&quot;</span></span><br><span class="line">eat[4]=<span class="string">&quot;越油越好吃打呀&quot;</span></span><br><span class="line">eat[5]=<span class="string">&quot;想不出吃什么&quot;</span></span><br><span class="line">eat[6]=<span class="string">&quot;太师傅便当&quot;</span></span><br><span class="line">eat[7]=<span class="string">&quot;池上便当&quot;</span></span><br><span class="line">eat[8]=<span class="string">&quot;怀恋火车便当&quot;</span></span><br><span class="line">eat[9]=<span class="string">&quot;一起吃泡面&quot;</span></span><br><span class="line">eat[10]=<span class="string">&quot;太上皇&quot;</span></span><br><span class="line">eatnum=10		<span class="comment"># 一共有几家可用的店铺</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实就是需要轮询出来 3 个不同的索引结果</span></span><br><span class="line"></span><br><span class="line">eated=0	<span class="comment"># 已选中数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;eated&#125;</span>&quot;</span> -lt 3 ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	check=$((<span class="variable">$&#123;RANDOM&#125;</span> * <span class="variable">$&#123;eatnum&#125;</span> / <span class="number">32767</span> + <span class="number">1</span>))</span><br><span class="line">	mycheck=0		<span class="comment"># 当为 0 时，表示不重复</span></span><br><span class="line">	<span class="comment"># 去重检查</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$&#123;eated&#125;</span> -gt 0 ]; <span class="keyword">then</span>			<span class="comment"># 当已选中至少一个店铺的时候，才执行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 <span class="variable">$&#123;eated&#125;</span>)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;eatedcon[$i]&#125;</span>&quot;</span> == <span class="variable">$check</span> ]; <span class="keyword">then</span></span><br><span class="line">        mycheck=1</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$&#123;mycheck&#125;</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;your may eat <span class="variable">$&#123;eat[<span class="variable">$&#123;check&#125;</span>]&#125;</span>&quot;</span></span><br><span class="line">		eated=$(( <span class="variable">$&#123;eated&#125;</span> + <span class="number">1</span> ))</span><br><span class="line">		eatedcon[<span class="variable">$&#123;eated&#125;</span>]=<span class="variable">$&#123;check&#125;</span>		<span class="comment"># 将已选中结果存储起来</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="Shell-Script-的追踪与-debug"><a href="#Shell-Script-的追踪与-debug" class="headerlink" title="Shell Script 的追踪与 debug"></a>Shell Script 的追踪与 debug</h2><p><strong>scripts</strong> 在执行前，最怕出现语法错误问题了，可以通过 <strong>bash</strong> 相关参数来检测</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sh [-nvx] scripts.sh</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-n：不执行 script，仅检查语法问题</span><br><span class="line">-v：执行 script 前，先将 scripts 内容输出到屏幕上</span><br><span class="line">-x：将执行到的 script 内容显示到屏幕上，相当于 debug 了</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：测试 dir_perm.sh 有无语法问题？</span></span><br><span class="line">sh -n dir_perm.sh</span><br><span class="line"><span class="comment"># 如果没有语法问题，则不会显示任何信息</span></span><br><span class="line"><span class="comment"># 笔者实测，貌似语法检测效果并不强大</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将 show_animal.sh 的执行过程全部列出来</span></span><br><span class="line">[mrcode@study bin]$ sh -x show_animal.sh </span><br><span class="line">+ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:/home/mrcode/bin</span><br><span class="line">+ <span class="built_in">export</span> PATH</span><br><span class="line">+ <span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;There are dogs...&#x27;</span></span><br><span class="line">There are dogs...</span><br><span class="line">+ <span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;There are cats...&#x27;</span></span><br><span class="line">There are cats...</span><br><span class="line">+ <span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;There are elephants...&#x27;</span></span><br><span class="line">There are elephants...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是原始脚本，方便对比</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;There are <span class="variable">$&#123;animal&#125;</span>s...&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 可以看到，每次循环执行，都打印出来了关键信息，</span></span><br><span class="line"><span class="comment"># 该功能非常有用，可以当成 debug 来使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>熟悉 <strong>sh</strong> 的用法，可以使你在管理 <strong>Linux</strong> 的过程中得心应手，至于在 <strong>shell script</strong> 的学习方法上，需要多看、多模仿、并加以修改成自己的代码，是最快的学习手段了。网络有上相当多的有用的 <strong>scripts</strong>，你可以将其拿来进行修改成自己的代码</p>
<p>另外，<strong>Linux</strong> 系统本来就有很多的服务启动脚本，如果想要知道每个 <strong>script</strong> 所代表的功能是什么，直接 <strong>vim</strong> 进入该 <strong>script</strong> 查阅下，通常就知道了。比如说之前提到的 <code>/etc/init.d/netconsole</code> 是做什么的？直接查看他的前几行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/netconsole </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># netconsole    This loads the netconsole module with the configured parameters.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: - 50 50</span></span><br><span class="line"><span class="comment"># description: Initializes network console logging</span></span><br><span class="line"><span class="comment"># config: /etc/sysconfig/netconsole</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          netconsole</span></span><br><span class="line"><span class="comment"># Required-Start:    $network</span></span><br><span class="line"><span class="comment"># Short-Description: Initializes network console logging</span></span><br><span class="line"><span class="comment"># Description:       Initializes network console logging of kernel messages.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copyright 2002 Red Hat, Inc.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Based in part on a shell script by</span></span><br><span class="line"><span class="comment"># Andreas Dilger &lt;adilger@turbolinux.com&gt;  Sep 26, 2001</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="进程管理与-SELinux-初探"><a href="#进程管理与-SELinux-初探" class="headerlink" title="进程管理与 SELinux 初探"></a>进程管理与 SELinux 初探</h1><p>一个程序被加载到内存中运行，那么在内存中的那个数据就称为进程（<strong>process</strong>）。</p>
<p>所有系统上跑的数据都会以进程的形态存在，进程有哪些状态？不同的状态会如何影响听的运行？进程之间是否可以互相控管？等等，这些是我们所必须要知道的项目</p>
<p>与进程有关的还有 <strong>SELinux</strong> 加强文件存取安全性的东西</p>
<h2 id="什么是进程（process）"><a href="#什么是进程（process）" class="headerlink" title="什么是进程（process）"></a>什么是进程（process）</h2><p>在 Linux 系统中：<strong>触发任何一个事件事，系统都会将它定义成一个进程，并且给予这个进程一个 ID，称为 PID，同时依据启发这个进程的用户与相关属性关系，给予这个 PID 一组有效的权限设置</strong>。</p>
<h3 id="进程与程序-（process-amp-program）"><a href="#进程与程序-（process-amp-program）" class="headerlink" title="进程与程序 （process &amp; program）"></a>进程与程序 （process &amp; program）</h3><p>执行一个程序或指令，就可以触发一个事件而取得一个 <strong>PID</strong></p>
<p>不同的用户运行程序，程序所拥有的权限也是不同的，概念如下图</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/Linux-pid.png" style="zoom: 67%;" />

<p>系统通过这个 <strong>PID</strong> 来判断该 <strong>process</strong> 是否具有权限进行工作的。</p>
<p>比如我们登陆的 <strong>bash tty</strong>，它是一个程序，登陆之后，系统会根据登陆者的 <strong>UID/GID（/etc/paswd）</strong>来分配一个 <strong>PID</strong>，比如执行了一个 <strong>touch</strong> 的执行，那么由这个进程 <strong>衍生出来的其他进程在一般状态下，也会沿用这个进程的相关权限</strong></p>
<p>程序与进程总结：</p>
<ul>
<li>程序 <strong>program</strong>：通常为 <strong>binary program</strong>，实体文件的形态存在</li>
<li>进程 <strong>process</strong>：程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统并给予这个内存单元一个标识符（<strong>PID</strong>），可以说，进程就是一个正在运行的程序</li>
</ul>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title="子进程与父进程"></a>子进程与父进程</h3><p>上面提到 <strong>衍生出来的进程</strong>，我们登陆到 <strong>bash</strong>，该 <strong>bash</strong> 是一个程序，并有一个 <strong>PID</strong>，在这个 <strong>bash</strong> 上执行指令，触发了相关指令的程序运行，从而得到该程序的 <strong>PID</strong>，这个 <strong>PID</strong> 就是一个子进程，原本的 <strong>bash</strong> 就是一个父进程</p>
<p>下面以一个小练习，来了解什么是子进程/父进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在目前的 bash 环境下，再触发一次 bash，并以 ps -l 指令管擦进程相关的输出信息</span></span><br><span class="line"><span class="comment"># 直接执行 bash 指令，会进入到子进程的环境中</span></span><br><span class="line">[root@study ~]<span class="comment"># bash</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  5713  1923  0  80   0 - 32064 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0  5862  5713  0  80   0 - 29218 do_wai pts/0    00:00:00 bash</span><br><span class="line">4 S     0 10917  5862  0  80   0 -  3184 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 R     0 11193 10917  0  80   0 - 12407 -      pts/0    00:00:00 ps</span><br><span class="line"><span class="comment"># 注意 PID 与 PPID，第 1 行的 PID 与第 2 行的 PPID 是一样的</span></span><br><span class="line"><span class="comment"># 第 2 行的 CMD 是 bash，就是从第一行中执行 bash 产生出来的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你发现，你杀掉了一个进程，不多久又出现了，这样的情况，如果不是 <strong>crontab</strong> 的定时任务产生的，那么就是有一个父进程在产生新的子进程</p>
<h3 id="fork-and-exec：进程呼叫的流程"><a href="#fork-and-exec：进程呼叫的流程" class="headerlink" title="fork and exec：进程呼叫的流程"></a>fork and exec：进程呼叫的流程</h3><p>进程与父进程的关系最为复杂的在于进程相互间的呼叫。</p>
<p>在 <strong>Linux</strong> 的进程呼叫通常称为 <strong>fork-and-exec</strong> 的流程，进程都会借由父进程以复制（<strong>fork</strong>）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 <strong>exec</strong> 的方式来执行时机要进行的程序，最终就成为一个子进程的存在。整个流程类似下图：</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/linux-fork-exec.png" style="zoom:67%;" />

<h3 id="系统或网络服务：常驻在内存的进程"><a href="#系统或网络服务：常驻在内存的进程" class="headerlink" title="系统或网络服务：常驻在内存的进程"></a>系统或网络服务：常驻在内存的进程</h3><p>常驻就是一直在运行的程序，比如 <strong>crond</strong> 程序，每分钟都会扫描 <code>/etc/crontab</code> 以及相关的配置文件，将它启动在背景当中一直持续不断的运行，这就是常驻在内存中的进程</p>
<p>这些进程通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻程序称为 <strong>服务（daemon）</strong>。系统的服务非常多，主要大致分为系统本身所需要的服务，如 <strong>crond</strong>、<strong>atd</strong>、<strong>rsyslogd</strong> 等。还有一些则负责网络联机服务，例如 <strong>Apache</strong>、<strong>named</strong>、<strong>postfix</strong>、<strong>vsftpd</strong> 等，这些网络服务程序被执行后，会启动一个可以负责网络监听的端口 port，以提供外部客户端的联机要求</p>
<div class="note info"><p><strong>TIP</strong></p>
<p><strong>cron</strong> 和 <strong>at</strong> 是他们主要执行的程序名称，但是后面加了一个 <strong>d</strong>，成为 <strong>crond</strong>、<strong>atd</strong> ，是因为这样可以简单的判定为该程序是一个服务 <strong>daemon</strong>，所以一般 <strong>daemon</strong> 类型的程序都会加上 <strong>d</strong> 的文件名，比如服务器篇中会看到的 <strong>httpd</strong>、<strong>vsftpd</strong> 等</p>
</div>

<h3 id="Linux-的多人多任务环境"><a href="#Linux-的多人多任务环境" class="headerlink" title="Linux 的多人多任务环境"></a>Linux 的多人多任务环境</h3><p>了解了进程的知识点后，你可以简单的认为进程的出现，让我们多用户在 <strong>Linux</strong> 都能拥有自己的环境了。</p>
<ul>
<li><p>多人环境</p>
<p><strong>Linux</strong> 最棒的地方就在于它的多人多任务环境。什么是多人多任务？每个账户都有其特殊的权限，除了 <strong>root</strong> 之外，其他人都必须受一些限制，而每个人进入 <strong>Linux</strong> 的环境设置都可以自定义，所以每个人登录后取得的 <strong>shell PI</strong>D 不同，是因为不在同一个进程程序中</p>
</li>
<li><p>多任务行为</p>
<p><strong>CPU</strong> 多在各个进程之间进行切换工作，因此当多人同时登录系统时，你的感觉就像整部主机好像就是你一个人的一样</p>
</li>
<li><p>多重登录环境的七个基本终端窗口</p>
<p>在 <strong>Linux</strong> 中，默认提供了 6 个文字界面登录窗口和一个图形界面，可以使用 <code>alt+F&#123;1-7&#125;</code>来切换不同的终端机界面，每个终端机界面的登录者可以是不同用户</p>
<p>这也是多任务环境下所产生的一个情况，<strong>Linux</strong> 默认会启动 <strong>6</strong> 个终端机登录环境的程序，所以才可以切换，在后续第 19 章开机管理流程中会仔细介绍的。</p>
</li>
<li><p>特殊的进程管理行为</p>
<p>对于宕机情况，在 <strong>Linux</strong> 上，几乎不会出现，因为他可以在任何时候，将某个困住的进程杀掉，然后在重新执行该进程而不用重新启动。</p>
<p>比如在 <strong>Linux</strong> 下以文字界面登录，在屏幕中显示错误信息后就挂了，不能动了。这个时候你可以切换到另外的 6 个终端机接口，以 <code>ps -aux</code> 找出刚刚的错误进程，<strong>kiil</strong> 掉它，再回到刚刚的终端机界面就好了（笔者疑问？<strong>kill</strong> 后会自动重启？有点不太理解）</p>
</li>
<li><p><strong>bash</strong> 环境下的工作管理</p>
<p>当我们登录 <strong>bash</strong> 后，取到了一个 <strong>PID</strong>，那么在这个环境下执行的其他指令，几乎是子进程了，在这个单一的 <strong>bash</strong> 接口中，可以如下进行多个工作，并且是同时进行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述指令串中，<code>&amp;</code> 表示把 <strong>file1</strong> 复制为 <strong>file2</strong>，并放到背景中执行。也就是说，下达完这一串指令后，马上就可以下达其他的指令串了，当着一个指令执行完成后，系统将会在你的终端接口显示完成的消息</p>
</li>
<li><p>多人多任务的系统资源分配问题考虑</p>
<p>当人多的时候，由于是共用计算机资源，所以有可能会导致资源不够用的情况发生，这个时候就需要升级机器了</p>
</li>
</ul>
<hr>
<h2 id="工作管理（job-control）"><a href="#工作管理（job-control）" class="headerlink" title="工作管理（job control）"></a>工作管理（job control）</h2><p>是在 <strong>bash</strong> 环境下的概念，当我们登录系统取得 <strong>bash shell</strong> 后，在单一终端机下同时进行多个工作的行为管理。</p>
<h3 id="什么是工作管理？"><a href="#什么是工作管理？" class="headerlink" title="什么是工作管理？"></a>什么是工作管理？</h3><p>进行工作管理的行为中，其实每个工作都是目前 bash 的子进程，彼此之间是有相关性的。我们<strong>无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash</strong></p>
<p>为什么会有工作管理？系统有多个 tty 使用，这样切换很麻烦，还有之前讲解的 <code>/etc/security/limits.conf(第 13 章)</code>可以设置同时登录的联机数量，假设只允许一个呢？</p>
<p>假设我们只有一个终端机接口，因此在可以出现提示字符让你操作的环境称为 <strong>前景 foreground</strong>，其他工作可以放入 <strong>背景 background</strong> 去暂停或运行。要注意的是：放入背景的工作在运行时，不能与使用者互动。比如 <strong>vim</strong> 不能再背景里面执行（<strong>running</strong>）的，因为你没有输入数据它就不会运行。<strong>而且放入背景的工作是不可以使用 ctrl+c 来终止的</strong></p>
<p>进行 <strong>bash</strong> 的 <strong>job control</strong> 必须要注意的限制是：</p>
<ul>
<li>这些工作所触发的进程必须来自于你的 <strong>shell</strong> 的子进程（只管理自己的 <strong>bash</strong>）</li>
<li>前景 <strong>foreground</strong>：你可以控制与下达指令的环境</li>
<li>背景：可以自动运行的工作，你无法使用 <strong>ctrl + c</strong> 终止它，可以使用 <strong>bg</strong>、<strong>fg</strong> 呼叫该工作</li>
<li>背景中<strong>执行</strong>的进程不能等待 <strong>terminal/shell</strong> 的输入（<strong>input</strong>）</li>
</ul>
<h3 id="job-control-的管理"><a href="#job-control-的管理" class="headerlink" title="job control 的管理"></a>job control 的管理</h3><h4 id="直接将指令丢到背景中-执行-的-amp"><a href="#直接将指令丢到背景中-执行-的-amp" class="headerlink" title="直接将指令丢到背景中 执行 的 &amp;"></a>直接将指令丢到背景中 <em>执行</em> 的 <code>&amp;</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 &amp; 将 /etc/ 整个备份为 /tmp/etc/tar.gz 工作丢到背景中执行</span></span><br><span class="line"><span class="comment"># 原因就是，压缩费时，不想一直就在当前界面看着他完成</span></span><br><span class="line">[root@study ~]<span class="comment"># tar -zpcf /tmp/etc.tar.gz /etc &amp;</span></span><br><span class="line">[1] 19763			<span class="comment"># job number 与 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># tar: Removing leading `/&#x27; from member names</span></span><br><span class="line"><span class="comment"># PID 与 bash 的控制有关，后续出现的数据信息是 tar 执行的数据流</span></span><br><span class="line"><span class="comment"># 由于没有加上数据流重导向，所以会影响画面，不过不会影响前景的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那他什么时候完成呢？当你输入几个指令后，发现出现了这一行</span></span><br><span class="line"><span class="comment"># 那么久表示在背景中的工作已经完成了</span></span><br><span class="line">[1]+  Done                    tar -zpcf /tmp/etc.tar.gz /etc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>[1]+</code> 表示这个工作已经完成（<strong>Done</strong>），后面是具体的指令串。如果有有信息出现，那么你的前景会出现干扰，只需要按下 <strong>enter</strong> 键就会出现提示字符，更下下指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># tar -zpcvf /tmp/etc.tar.gz /etc &amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于输出了信息，<strong>stdout</strong> 和 <strong>stderr</strong> 都会输出到屏幕上，这样就会影响前景终端，所以一般都利用数据流重导向，将输出数据传送至某个文件中，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># tar -zpcvf /tmp/etc.tar.gz /etc  &gt; /tmp/log.txt 2&gt;&amp;1 &amp;</span></span><br><span class="line">[1] 16592</span><br><span class="line">[root@study ~]<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="将-目前-的工作丢到背景中-暂停-：ctrl-z"><a href="#将-目前-的工作丢到背景中-暂停-：ctrl-z" class="headerlink" title="将 目前 的工作丢到背景中_暂停_：ctrl+z"></a>将 <em>目前</em> 的工作丢到背景中_暂停_：ctrl+z</h4><p>考虑这个场景，我正在使用 <strong>vim</strong>，却发现某个文件的路径不记得了，需要到 <strong>bash</strong> 环境下进程搜索，此时不需要结束 <strong>vim</strong>，可以把它丢到背景中等待</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># vim ~/.bashrc </span></span><br><span class="line"><span class="comment"># 在 vim 环境下按 ctrl + z 组合键</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[root@study ~]<span class="comment"># 		# 这就取得了前景</span></span><br><span class="line">[root@study ~]<span class="comment"># find / -print</span></span><br><span class="line"><span class="comment"># 会大量输出信息，我们把这个工作也丢到背景中执行</span></span><br><span class="line">[3]+  Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[root@study ~]<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>[2]+</code> 表示这个是加入到背景中的第二个工作，<strong>Stopped</strong> 是状态，预设情况下，使用 <strong>ctrl+z</strong> 丢到背景中的工作都是暂停状态</p>
<h4 id="观察目前的背景工作状态：jobs"><a href="#观察目前的背景工作状态：jobs" class="headerlink" title="观察目前的背景工作状态：jobs"></a>观察目前的背景工作状态：jobs</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span> [-lrs]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-l：除了列出 job number 与指令之外，同时列出 PID 的号码</span><br><span class="line">	-r：仅列出正在背景 run 的工作</span><br><span class="line">	-s：仅列出正在背景中暂停 stop 的工作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：观察目前的 bash 中，所有工作与队友的 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># jobs -l</span></span><br><span class="line">[2]- 26476 Stopped                 vim ~/.bashrc</span><br><span class="line">[3]+  2207 Stopped                 find / -<span class="built_in">print</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仔细看上面有减号和加号：</p>
<ul>
<li><code>+</code>：表示最近被放到背景的工作；如果只输入 <strong>fg</strong> 指令，那么 <code>[3]</code> 会被拿到前景中来处理</li>
<li><code>-</code>：表示最近最后第二个被放置到背景中的工作。如果超过最后第三个以后的工作，就不会有 <code>-、+</code> 符号了</li>
</ul>
<h4 id="将背景工作拿到前景来处理：fg"><a href="#将背景工作拿到前景来处理：fg" class="headerlink" title="将背景工作拿到前景来处理：fg"></a>将背景工作拿到前景来处理：fg</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> %jobnumber</span><br><span class="line"></span><br><span class="line"><span class="variable">$jobnumber</span>: jobnumber 是工作号码（数字），哪个 % 是可有可无的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：先以 jobs 管擦工作，再将工作取出</span></span><br><span class="line">[root@study ~]<span class="comment"># jobs -l</span></span><br><span class="line">[2]- 26476 Stopped                 vim ~/.bashrc</span><br><span class="line">[3]+  2207 Stopped                 find / -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 取出 + 号的工作，注意会刷屏，马上按下 ctrl + z ，再次放入到背景中</span></span><br><span class="line">[root@study ~]<span class="comment"># fg</span></span><br><span class="line"><span class="comment"># 直接取出 2 的工作，在放到背景中</span></span><br><span class="line">[root@study ~]<span class="comment"># fg %2</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[root@study ~]<span class="comment"># jobs -l</span></span><br><span class="line">[2]+ 26476 Stopped                 vim ~/.bashrc</span><br><span class="line">[3]-  2207 Stopped                 find / -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到， 2 的工作被标记为了 + 号，表示是最近放进去的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="让工作在背景下的状态变成运行中：bg"><a href="#让工作在背景下的状态变成运行中：bg" class="headerlink" title="让工作在背景下的状态变成运行中：bg"></a>让工作在背景下的状态变成运行中：bg</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1： 执行 find / -perm /7000 &gt; /tmp/text.txt，立刻丢到背景去暂停</span></span><br><span class="line">[root@study ~]<span class="comment"># find / -perm /7000 &gt; /tmp/text.txt</span></span><br><span class="line">find: <span class="string">&#x27;/proc/29541/task/29541/fd/5&#x27;</span>: No such file or directory</span><br><span class="line">find: <span class="string">&#x27;/proc/29541/task/29541/fdinfo/5&#x27;</span>: No such file or directory</span><br><span class="line">find: <span class="string">&#x27;/proc/29541/fd/6&#x27;</span>: No such file or directory</span><br><span class="line">find: <span class="string">&#x27;/proc/29541/fdinfo/6&#x27;</span>: No such file or directory</span><br><span class="line">^Z</span><br><span class="line">[4]+  Stopped                 find / -perm /7000 &gt; /tmp/text.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：让该工作在背景下进行，并且观察他</span></span><br><span class="line">[root@study ~]<span class="comment"># jobs ; bg %4; jobs</span></span><br><span class="line">[2]-  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[4]+  Stopped                 find / -perm /7000 &gt; /tmp/text.txt</span><br><span class="line"></span><br><span class="line">[4]+ find / -perm /7000 &gt; /tmp/text.txt &amp;</span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[4]-  Running                 find / -perm /7000 &gt; /tmp/text.txt &amp;</span><br><span class="line"><span class="comment"># 第 4 个由 Stopped 变成了 Running 状态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="管理背景中的工作：kill"><a href="#管理背景中的工作：kill" class="headerlink" title="管理背景中的工作：kill"></a>管理背景中的工作：kill</h4><p>通过 <strong>fg</strong> 拿到前景来，可以通过 <strong>kill</strong> 将该工作直接移除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -signal <span class="variable">$jobnumber</span></span><br><span class="line"><span class="built_in">kill</span> -l</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-l：L 的小写，列出目前 <span class="built_in">kill</span> 能够使用的信号（signal）有哪些？</span><br><span class="line">	signal：给予后续工作什么指示，用 man 7 signal 可知：</span><br><span class="line">		-1：重新读取一次参数的配置文件（类似 reload）</span><br><span class="line">		-2：代表与由键盘输入 ctrl+c 同样的动作</span><br><span class="line">		-9：立刻强制删除一个工作</span><br><span class="line">		-15：已正常的进程方式终止一项工作。与  -9 是不一样的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">范例 1： 找出目前 bash 环境下的背景工作，并将该工作 强制删除</span><br><span class="line">[root@study ~]<span class="comment"># jobs</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Stopped                 find / -<span class="built_in">print</span></span><br><span class="line">[4]-  Exit 1                  find / -perm /7000 &gt; /tmp/text.txt</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># kill -9 %3; jobs</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[3]   Killed                  find / -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 过几秒再运行 jobs 会发现 killed 的不见了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：找出目前 bash 环境下的而背景工作，并将该工作 正常 终止</span></span><br><span class="line">[root@study ~]<span class="comment"># kill -SIGTERM %2</span></span><br><span class="line"></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line">[root@study ~]<span class="comment"># jobs</span></span><br><span class="line">[2]+  Stopped                 vim ~/.bashrc</span><br><span class="line"><span class="comment"># -SIGTERM 与 -15 同效果，可以用哪个 kill -l 来查阅</span></span><br><span class="line"><span class="comment"># 在这个案例中，会发现 vim 的工作无法被结束，无法通过 kill 正常终止</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <strong>vim</strong> 时候，会产生一个 <code>.filename.swp</code> 文件，使用 <strong>-15</strong> 这个 <strong>signal</strong> 时，<strong>vim</strong> 会尝试以正常的步骤来结束掉该 <strong>vi</strong> 的工作，使用 <code>.filename.swp</code> 会主动的被移除，若是使用 <strong>-9</strong>，那么 <strong>swp</strong> 文件不会被移除调用</p>
<p><strong>kill</strong> 需要了解 <strong>1</strong>、9、15 的 signal 的含义，可以用 man 7 signal 查询相关资料，还有一个 killall 也是同样的用法。</p>
<p>kill 后面接的数字，默认是 PID，要管理 bash 的工作控制，需要加上 %数字 的方式</p>
<h3 id="脱机管理问题"><a href="#脱机管理问题" class="headerlink" title="脱机管理问题"></a>脱机管理问题</h3><p><strong>注意</strong>：前面工作管理中的「背景」是指在终端机模式下可以避免「ctrl+c」中断，可以理解为是这个 bash 的背景，并 <strong>不是放到系统的背景</strong> 中去。所以，工作管理的背景依旧与终端机有关</p>
<p>如果你是以远程方式连接到 Linux 主机，并且将工作以 &amp; 的方式放到背景中去，在工作未结束时，你脱机了，该工作不会继续进行，而是会被中断掉</p>
<p>那么可以使用前一章学习的 at 指令，因为它是将工作放置到系统背景，还可以使用 nohup 指令来达到效果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup [指令与参数]		<span class="comment"># 在终端机前景中工作</span></span><br><span class="line">nohup [指令与参数]		<span class="comment"># 在终端机背景中工作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>TIP</strong></p>
<p><strong>nohup</strong> 后面的指令不支持 <strong>bash</strong> 内置指令！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 编辑一个会随眠  500 秒的程序</span></span><br><span class="line">[root@study ~]<span class="comment"># vim sleep500.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/bin/sleep 500s</span><br><span class="line">/bin/<span class="built_in">echo</span> <span class="string">&quot;I have sleep 500 seconds.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 丢到背景中执行</span></span><br><span class="line">[root@study ~]<span class="comment"># chmod a+x sleep500.sh </span></span><br><span class="line">[root@study ~]<span class="comment"># nohup ./sleep500.sh &amp;</span></span><br><span class="line">[3] 14915</span><br><span class="line">[root@study ~]<span class="comment"># nohup: ignoring input and appending output to &#x27;nohup.out&#x27;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>你登出登录后，再次登录系统，使用 <strong>pstree</strong> （这里没有说是什么）去查询你的进程，会发现它还在执行，还输出了一个信息，<strong>nohup</strong> 与终端机无关了，因此整个信息的输出就会被导向 <code>~/nohup.out</code></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>为什么进程管理这么重要？是因为：</p>
<ul>
<li>我们在操作系统时的各项工作都是经过某个 <strong>PID</strong> 来达成的（包括你的 <strong>bash</strong> 环境），因此，能不能进行某项工作，与该进程的权限有关</li>
<li>如果你的 <strong>LInux</strong> 是个很忙碌的系统，当整个系统资源要被使用光的时候，你是否能够找出最耗资源的哪个进程，然后删除该进程，让系统恢复正常？</li>
<li>由于某个程序写的不好，导致产生一个有问题的进程在内存中，如何找出它，将它移除呢？</li>
<li>如果有 5、6 项工作在系统中运行，但其中有一项工作才是最重要的，该如何让那一项重要的工作被最优先执行？</li>
</ul>
<p>以上几点，在系统使用中都是很重要且常见的问题</p>
<h3 id="进程的观察"><a href="#进程的观察" class="headerlink" title="进程的观察"></a>进程的观察</h3><h4 id="ps：将某个时间点的进程运行情况截取下来"><a href="#ps：将某个时间点的进程运行情况截取下来" class="headerlink" title="ps：将某个时间点的进程运行情况截取下来"></a>ps：将某个时间点的进程运行情况截取下来</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ps aux		<span class="comment"># 观察系统所有的进程数据</span></span><br><span class="line">ps -l 		<span class="comment"># 观察与当前终端机相关的进程</span></span><br><span class="line">ps -lA 		<span class="comment"># 观察系统所有的进程数据（显示内容项同 ps -l 的项一样，只不过是系统所有进程）</span></span><br><span class="line">ps axjf		<span class="comment"># 连同部分进程树状态</span></span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：所有的 process 都显示出来，与 -e 具有同样的效果</span><br><span class="line">	-a：不与 terminal 有关的所有 process</span><br><span class="line">	-u：有效使用者（effective user）相关的 process</span><br><span class="line">	x：通常与 a 一起使用，可列出完整信息</span><br><span class="line">输出格式规划：</span><br><span class="line">	l：较长、较详细的将该 PID 的信息列出</span><br><span class="line">	j：工作的格式（<span class="built_in">jobs</span> format）</span><br><span class="line">	-f：做一个更为完整的输出</span><br></pre></td></tr></table></figure>

<p><strong>ps</strong> 指令的 <strong>man page</strong> 不太好查阅，不同的 <strong>Unix</strong> 都使用 <strong>ps</strong> 来查阅进程状态，为了符合不同版本的需求，该 <strong>man page</strong> 写的非常庞大，因此建议你有两个选择：</p>
<ol>
<li>只能查询自己 <strong>bash</strong> 进程的 <code>ps -l</code></li>
<li>可以查询所有系统运行的进程 <code>ps aux</code></li>
</ol>
<h4 id="仅查看自己的-bash-相关进程：ps-l"><a href="#仅查看自己的-bash-相关进程：ps-l" class="headerlink" title="仅查看自己的 bash 相关进程：ps -l"></a>仅查看自己的 bash 相关进程：<code>ps -l</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1： 将目前属于您自己这次登录的 PID 与相关信息列出来（只与自己的 bash 有关）</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0 29260 28796  0  80   0 - 57972 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0 29473 29260  0  80   0 - 29090 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 R     0 30444 29473  0  80   0 - 12407 -      pts/0    00:00:00 ps</span><br><span class="line"><span class="comment"># 前面三项，最初是用了普通账户登录的，使用了 su - 切换到了一个 bash</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里列出的只是与你操作环境 <strong>bash</strong> 有关的进程，没有延伸到 <strong>systemd</strong>（后续交代）：</p>
<ul>
<li><strong>F</strong>：进程旗标（<strong>process flags</strong>），说明这个进程的总结权限，常见的号码有：<ul>
<li><strong>4</strong>：表示此进程的权限为 <strong>root</strong></li>
<li><strong>1</strong>：则表示此子进程仅进行 <strong>复制（fork）而没有实际执行（exec）</strong></li>
</ul>
</li>
<li><strong>S</strong>：进程状态（<strong>STAT</strong>），主要状态有：<ul>
<li><strong>R</strong>（<strong>Running</strong>）：正在运行中</li>
<li><strong>S</strong>（<strong>Sleep</strong>）：该程序目前正在睡眠状态（<strong>idle</strong>），但可以被唤醒（<strong>signal</strong>）</li>
<li><strong>D</strong>：不可被唤醒的睡眠状态，通常该程序可能在等待 <strong>I/O</strong> 的情况</li>
<li><strong>T</strong>：停止状态（<strong>stop</strong>），可能是在工作控制（背景暂停）或除错（<strong>traced</strong>）状态</li>
<li><strong>Z</strong>（<strong>Zombie</strong>）：僵尸状态，进程已终止但却无法被移除至内存外</li>
</ul>
</li>
<li><strong>UUID/PID/PPID</strong>：代表此进程被该 <strong>UID</strong> 所拥有、进程的 <strong>PID</strong> 、此进程的父进程 <strong>PID</strong></li>
<li><strong>C</strong>：代表 <strong>CPU</strong> 使用率，单位为百分比</li>
<li><strong>PRI/NI</strong>：<strong>Priority/Nice</strong> 的缩写，代表此进程被 <strong>CPU</strong> 所执行的优先级，数值越小表示该进程越快被 <strong>CPU</strong> 执行。详细的 <strong>PRI</strong> 与 <strong>NI</strong> 将在下一小节讲解</li>
<li><strong>ADDR/SZ/WCHAN</strong>：都与内存有关<ul>
<li><strong>ADDR</strong>：<strong>kernel function</strong>，该进程在内存的哪个部分，如果是 <strong>running</strong> 的进程，一般会显示 <code>-</code></li>
<li><strong>SZ</strong>：该进程用掉多少内存</li>
<li><strong>WCHAN</strong> 该进程是否运行中，若为 <code>-</code> 表示正在运行中</li>
</ul>
</li>
<li><strong>TTY</strong>：登陆者的终端机位置，若为远程登录则使用动态终端接口（<strong>pts/n</strong>）</li>
<li><strong>TIME</strong>：使用掉的 <strong>CPU</strong> 时间。注意：是此进程实际花费 <strong>CPU</strong> 运行的时间</li>
<li><strong>CMD</strong>：<strong>command</strong> 的缩写，此进程的触发程序指令</li>
</ul>
<p>如上列出的信息表示， <strong>bash</strong> 的程序属于 <strong>UID</strong> 为 0 的使用者，状态是睡眠（<strong>sleep</strong>），他睡眠是因为他触发了 <strong>ps</strong>（状态为 <strong>R</strong>，<strong>run</strong>）的原因，<strong>ps</strong> 的 PID=30444，优先执行顺序为 80，下达 bash 所取得的终端机接口为 pts/0，运行状态为 do_wai</p>
<h4 id="观察系统所有进程：ps-aux"><a href="#观察系统所有进程：ps-aux" class="headerlink" title="观察系统所有进程：ps aux"></a>观察系统所有进程：ps aux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ps aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.5 128372  6988 ?        Ss   21:14   0:01 /usr/lib/systemd/systemd --switched-root --system --deseriali</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    21:14   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        S&lt;   21:14   0:00 [kworker/0:0H]</span><br><span class="line">...</span><br><span class="line">root     27082  0.0  0.1  51752  1716 pts/2    R+   21:41   0:00 ps aux</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会发现 <code>ps -l</code> 与 <code>ps aux</code> 显示的项目也不一样</p>
<ul>
<li><strong>USER</strong>：该 <strong>process</strong> 属于哪个使用者账户</li>
<li><strong>PID</strong>：进程标识符</li>
<li><code>%CPU</code>：该进程使用掉的 <strong>CPU</strong> 资源百分比</li>
<li><code>%MEM</code>：占用的虚拟内存（<strong>KBytes</strong>）</li>
<li><strong>RSS</strong>：占用的固定内存（<strong>KBytes</strong>）</li>
<li><strong>TTY</strong>：在哪个终端机上面运行？<ul>
<li><code>?</code>：与终端机无关</li>
<li><code>tty1-tty6</code>：本机上登录的</li>
<li><code>pts/0</code>等：是由网络连接进入的进程</li>
</ul>
</li>
<li><strong>STAT</strong>：目前的状态，与 <code>ps -l</code> 中的状态相同含义</li>
<li><strong>START</strong>：该进程被触发启动时间（如果太久不会显示具体时间）</li>
<li><strong>TIME</strong>：该进程实际使用 <strong>CPU</strong> 运行的时间</li>
<li><strong>COMMAND</strong>：进程执行的指令</li>
</ul>
<p>一般来说，<strong>ps aux</strong> 会按照 <strong>PID</strong> 的顺序来排序显示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：以范例 1 的显示内容，显示出所有的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0 25710  1956  0  80   0 - 57972 do_wai pts/2    00:00:00 su</span><br><span class="line">4 S     0 25917 25710  0  80   0 - 29090 do_wai pts/2    00:00:00 bash</span><br><span class="line">0 R     0 32189 25917  0  80   0 - 12407 -      pts/2    00:00:00 ps</span><br><span class="line">[root@study ~]<span class="comment"># ps -lA</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0     1     0  0  80   0 - 32093 ep_pol ?        00:00:01 systemd</span><br><span class="line">1 S     0     2     0  0  80   0 -     0 kthrea ?        00:00:00 kthreadd</span><br><span class="line">1 S     0     4     2  0  60 -20 -     0 worker ?        00:00:00 kworker/0:0H</span><br><span class="line">1 S     0     6     2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/0</span><br><span class="line">1 S     0     7     2  0 -40   - -     0 smpboo ?        00:00:00 migration/0</span><br><span class="line">1 S     0     8     2  0  80   0 -     0 rcu_gp ?        00:00:00 rcu_bh</span><br><span class="line">1 R     0     9     2  0  80   0 -     0 -      ?        00:00:01 rcu_sched</span><br><span class="line"><span class="comment"># 会发现，与 ps -l 显示类似，不过显示的是系统的所有进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 4：列出类似进程树的进程显示</span></span><br><span class="line">[root@study ~]<span class="comment"># ps axjf</span></span><br><span class="line"> PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND</span><br><span class="line">    0     2     0     0 ?           -1 S        0   0:00 [kthreadd]</span><br><span class="line">    2     4     0     0 ?           -1 S&lt;       0   0:00  \_ [kworker/0:0H]</span><br><span class="line">    2     6     0     0 ?           -1 S        0   0:00  \_ [ksoftirqd/0]</span><br><span class="line">    1  1269  1269  1269 ?           -1 Ss       0   0:00 /usr/sbin/sshd -D</span><br><span class="line"> 1269  1922  1922  1922 ?           -1 Ss       0   0:01  \_ sshd: mrcode [priv]</span><br><span class="line"> 1922  1932  1922  1922 ?           -1 S     1000   0:09  |   \_ sshd: mrcode@pts/0,pts/1</span><br><span class="line"> 1932  1934  1934  1934 pts/0     1934 Ss+   1000   0:00  |       \_ -bash</span><br><span class="line"> 1932  1939  1939  1939 ?           -1 Ss    1000   0:00  |       \_ /usr/libexec/openssh/sftp-server</span><br><span class="line"> 1932  1941  1941  1941 pts/1     2573 Ss    1000   0:00  |       \_ -bash</span><br><span class="line"> 1941  2573  2573  1941 pts/1     2573 S+    1000   0:04  |       |   \_ top</span><br><span class="line"> 1932  7742  7742  7742 ?           -1 Ss    1000   0:00  |       \_ bash -c <span class="built_in">export</span> LANG=<span class="string">&quot;en_US.UTF-8&quot;</span>;<span class="built_in">export</span> LANGUAGE=<span class="string">&quot;en_US.</span></span><br><span class="line"><span class="string"> 7742  7789  7742  7742 ?           -1 S     1000   0:00  |           \_ sleep 1</span></span><br><span class="line"><span class="string"> 1269  1926  1926  1926 ?           -1 Ss       0   0:01  \_ sshd: mrcode [priv]</span></span><br><span class="line"><span class="string"> 1926  1950  1926  1926 ?           -1 S     1000   0:09      \_ sshd: mrcode@pts/2,pts/3</span></span><br><span class="line"><span class="string"> 1950  1956  1956  1956 pts/2     7790 Ss    1000   0:00          \_ -bash</span></span><br><span class="line"><span class="string"> 1956 25710 25710  1956 pts/2     7790 S        0   0:00          |   \_ su -</span></span><br><span class="line"><span class="string">25710 25917 25917  1956 pts/2     7790 S        0   0:00          |       \_ -bash</span></span><br><span class="line"><span class="string">25917  7790  7790  1956 pts/2     7790 R+       0   0:00          |           \_ ps axjf</span></span><br><span class="line"><span class="string"> 1950  2009  2009  2009 ?           -1 Ss    1000   0:00          \_ /usr/libexec/openssh/sftp-server</span></span><br><span class="line"><span class="string"> 1950  2012  2012  2012 pts/3     2574 Ss    1000   0:00          \_ -bash</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>看上面 <strong>PPID</strong> 为 <strong>1269</strong> 的那一行开始，我这里使用了 <strong>ssh</strong> 远程链接，用的是 <strong>mrcode</strong> 账户，登录成功后，获得了一个 <strong>bash</strong> 环境，后面我使用了 <code>su -</code> 指令切换到了 <strong>root</strong> 的 <strong>bash</strong> 环境，然后执行了刚刚的 <strong>ps axjf</strong> 指令。这样就比较清楚了。</p>
<p>还可以通过 <strong>pstree</strong> 指令来显示进程树，不过貌似没有这么详细</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 5：找出与 cron 和 rsyslog 这两个服务有关的 PID 号码</span></span><br><span class="line">[root@study ~]<span class="comment"># ps aux | egrep &#x27;(cron|rsyslog)&#x27;</span></span><br><span class="line">root      1273  0.0  0.3 215672  3652 ?        Ssl  21:15   0:00 /usr/sbin/rsyslogd -n</span><br><span class="line">root      1285  0.0  0.1 126288  1696 ?        Ss   21:15   0:00 /usr/sbin/crond -n</span><br><span class="line">root      4838  0.0  0.0   9096   932 pts/2    R+   21:58   0:00 grep -E --color=auto (cron|rsyslog)</span><br><span class="line"><span class="comment"># 对于上面为什么要使用 egrep，在第 11 章，延伸正则表示法中有介绍。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="僵尸进程-zombie"><a href="#僵尸进程-zombie" class="headerlink" title="僵尸进程 zombie"></a>僵尸进程 zombie</h4><p>僵尸 <strong>zombie</strong>：该进程以及执行完毕或则是因故应该要终止了，但是该进程的父进程却无法完整的将该进程结束掉，而造成哪个进程一直在内存中。</p>
<p>在进程中它的标识是在 <strong>CMD</strong> 后面有 <code>&lt;defunct&gt;</code> 标识,例如下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache 8683 0.0 0.9 83383 9992 ？Z 14:33 0:00 /usr/sbin/httpd&lt;defunct&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当系统不稳定时，容易造成僵尸进程，可能是因为程序有问题，或则是使用者的操作习惯不良等。</p>
<p>发现有僵尸进程时，应该找出来，分析原因，否则有可能一直产生僵尸进程</p>
<p>事实上，通常僵尸进程都已经无法管控，而直接交给 <strong>systemd</strong> 程序来负责了，偏偏 <strong>systemd</strong> 是系统第一个执行的程序，它是所有程序的父程序，无法杀掉该程序（杀掉它，系统就死了），所以，经过一段时间后，系统无法通过核心非经常性的特殊处理来将该进程删除时，那只有重启机器了</p>
<h3 id="top：动态观察进程的变化"><a href="#top：动态观察进程的变化" class="headerlink" title="top：动态观察进程的变化"></a>top：动态观察进程的变化</h3><p><strong>ps</strong> 可以显示一个时间点的进程状态，而 <strong>top</strong> 则可以持续的侦测进程运行状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">top [-d 数字] | top [-bnp]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-d：后面可以接秒数，整个进程画面更新的秒数，预设是 5 秒更新一次</span><br><span class="line">	-b：以批次的方式执行 top，还有更多的参数可以使用（莫名其妙啊，啥参数？），通常会搭配数据流重导向来将批次的结果输出为文件</span><br><span class="line">	-n：与 -b 搭配，需要进行几次 top 的输出</span><br><span class="line">	-p：指定某些 PID 来进行观察</span><br><span class="line"></span><br><span class="line">在 top 执行过程中可以使用的按键指令：</span><br><span class="line">	？：显示在 top 中可以输入的按键指令</span><br><span class="line">	P：以 CPU 的使用资源排序显示</span><br><span class="line">	M：以 Memory 的使用资源排序显示</span><br><span class="line">	N：以 PID 排序</span><br><span class="line">	T：由该进程使用 CPU 时间累积（TIME+）排序</span><br><span class="line">	k：给予某个 PID 一个信号（signal）</span><br><span class="line">	r：给予某个 PID 重新制定一个 nice 值</span><br><span class="line">	q：离开 top 软件的按键</span><br><span class="line">	E：切换单位显示，比如从 KB 切换为 G 显示</span><br><span class="line">	c：切换 COMMAND 的信息，name/完成指令</span><br></pre></td></tr></table></figure>

<p><strong>top</strong> 的功能太多，可用的按键也很多，可以参考 <strong>man top</strong> 的内部文件说明，上面只是列出常用的选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：每两秒更新一次 top，观察整体信息</span></span><br><span class="line">[root@study ~]<span class="comment"># top -d 2</span></span><br><span class="line">top - 22:20:11 up  1:05,  4 users,  load average: 0.52, 0.53, 0.52</span><br><span class="line">Tasks: 186 total,   2 running, 184 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  7.7 us,  9.7 sy,  0.0 ni, 82.1 id,  0.0 wa,  0.0 hi,  0.5 si,  0.0 st</span><br><span class="line">KiB Mem :  1190952 total,   428928 free,   402624 used,   359400 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.   632160 avail Mem</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; 如果按下 k 或 r 时，有相关的提示在这里出现</span></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                    </span><br><span class="line"> 1699 gdm       20   0 2947388 136736  61224 S  0.5 11.5   0:04.00 gnome-shell                                                </span><br><span class="line"> 1932 mrcode    20   0  161324   3016   1296 S  0.5  0.3   0:17.28 sshd                                                       </span><br><span class="line"> 1950 mrcode    20   0  161324   3028   1296 S  0.5  0.3   0:17.41 sshd                                                       </span><br><span class="line"> 2573 mrcode    20   0  162820   3068   1576 S  0.5  0.3   0:07.43 top                                                        </span><br><span class="line">    1 root      20   0  128372   6988   4196 S  0.0  0.6   0:01.67 systemd</span><br></pre></td></tr></table></figure>

<p><strong>top</strong> 的信息基本上分为两个区域，上面 <strong>6</strong> 行，和下面的列表</p>
<ul>
<li><p>第一行信息：<strong>top</strong> -</p>
<ul>
<li><p>目前开机时间：<strong>22:20:11</strong> 这个</p>
</li>
<li><p>开机到目前为止所经过的时间：<strong>up 1:05</strong> 这个</p>
</li>
<li><p>已经登录系统的用户人数：<strong>4 users</strong></p>
</li>
<li><p>系统在 <strong>1、5、15</strong> 分钟的平均工作负载</p>
<p>在第 <strong>15</strong> 章谈到过 <strong>batch</strong> 工作方式负载小于 <strong>0.8</strong> 就是这里显示的值了。</p>
<p>表示的是，系统平均要负责运行几个进程，这里是三个值，也就是对应平均 1/5/15 分钟</p>
<p>越小达标系统越空闲，若高于 <strong>1</strong> ，那么你的系统进程执行太频繁了</p>
</li>
</ul>
</li>
<li><p>第二行：<strong>tasks</strong></p>
<p>显示的是目前进程的总量与各个状态（<strong>running、sleeping、stopped、zombie</strong>）的进程数量</p>
<p>如果发现有 <strong>zombie</strong> 进程的话，就需要找下是哪个进程变成了僵尸进程了</p>
</li>
<li><p>第三行：<code>$Cpus</code></p>
<p><strong>CPU</strong> 整体负载，每个项目可使用 ？ 查询。</p>
<p>需要特别注意的是 <strong>wa</strong> 项，表示 <strong>I/O wait</strong>，通常系统变慢，都是 <strong>I/O</strong> 产生的问题比较大，需要特别注意该项占用的 <strong>CPU</strong> 资源，如果是多核 <strong>CPU</strong>，可以按下数字键「<strong>1</strong>」来切换成不同 <strong>CPU</strong></p>
</li>
<li><p>第四行和第五行</p>
<p>目前的物理内存与虚拟内存（<strong>Mem/Swap</strong>）的使用情况。要注意的是 <strong>swap</strong> 的使用量要尽量的少，如果 <strong>swap</strong> 被大量使用，表示系统的物理内存不足</p>
</li>
<li><p>第六行：当在 <strong>top</strong> 程序中输入指令时，显示状态的地方</p>
</li>
</ul>
<p>下面的列表部分大部分都见过了，下面再列出含义：</p>
<ul>
<li><strong>PID</strong>：进程 <strong>ID</strong></li>
<li><strong>USER</strong>：进程所属使用者</li>
<li><strong>PR</strong>（<strong>priority</strong>）：进程优先执行顺序，越小越早被执行</li>
<li><strong>NI</strong>（<strong>nice</strong>）：与 <strong>PR</strong> 有关，越小越早被执行</li>
<li><code>%CPU</code>：<strong>CPU</strong> 使用率</li>
<li><code>%MEM</code>：内存使用率</li>
<li><code>TIME+</code> ：<strong>CPU</strong> 使用时间的累加</li>
</ul>
<p><strong>top</strong> 预设使用 <strong>CPU</strong> 使用率 <code>%CPU</code>作为排序的重点，如果想要使用内存使用率排序，可以按下 <strong>M</strong> 键，要离开按下 <strong>q</strong> 键</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：将 top 的信息进行 2 次，然后将结果输出到 /tmp/top.txt</span></span><br><span class="line">[root@study ~]<span class="comment"># top -b -n 2 &gt; /tmp/top.txt</span></span><br><span class="line"><span class="comment"># 这里的结果就是，写入了执行 2 次的结果信息。是追加写入的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于只有一屏显示，所以当你要观察的进程没有排序到最前面的时候，还可以单独观察该线程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：我们自己的 bash PID 可以由 $$ 变量取得，使用 top 持续观察该 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># top -d 2 -p $$</span></span><br><span class="line">top - 22:53:55 up  1:39,  2 users,  load average: 0.59, 0.28, 0.32</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.1 us,  4.6 sy,  0.0 ni, 92.8 id,  0.0 wa,  0.0 hi,  0.5 si,  0.0 st</span><br><span class="line">KiB Mem :  1190952 total,   435612 free,   392456 used,   362884 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.   642448 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                    </span><br><span class="line"> 9051 root      20   0  116472   3172   1780 S  0.0  0.3   0:00.04 bash </span><br></pre></td></tr></table></figure>

<p>就只显示着一个程序给你看了，还可以修改 <strong>NI</strong> 值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 4：上题的 NI 指是 0，把它修改成 10</span></span><br><span class="line"><span class="comment"># 在上题的 top 画面中按下 r 键出现下面的提示</span></span><br><span class="line">PID to renice [default pid = 9051] 5501 		<span class="comment"># 输入要修改的 PID</span></span><br><span class="line">Renice PID 9051 to value 10		<span class="comment"># 输入要修改的 nice 值</span></span><br><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">9051 root      30  10  116472   3172   1780 S  0.0  0.3   0:00.04 bash </span><br><span class="line"></span><br><span class="line"><span class="comment"># 会发现 NI 值已经修改了</span></span><br></pre></td></tr></table></figure>

<h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pstree [-AIU] [-up]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：各进程之间的连接以  ASCII 字符来连接</span><br><span class="line">	-U：各进程之间的连接以万国码的字符来连接。在某些终端机接口下可能会有错误</span><br><span class="line">	-p：并同时列出每个 process 的 PID</span><br><span class="line">	-u：并同时列出每个 process 的所属账户名称</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上所有的进程树的相关性</span></span><br><span class="line">[root@study ~]<span class="comment"># pstree -A</span></span><br><span class="line">systemd-+-ModemManager---2*[&#123;ModemManager&#125;]				<span class="comment"># ModenManager 与其子进程</span></span><br><span class="line">        |-NetworkManager---2*[&#123;NetworkManager&#125;]</span><br><span class="line">        |-2*[abrt-watch-log]</span><br><span class="line">        |-abrtd</span><br><span class="line">        |-accounts-daemon---2*[&#123;accounts-daemon&#125;]</span><br><span class="line">        ....</span><br><span class="line">        |-sshd---sshd---sshd-+-bash---su---bash---pstree		<span class="comment"># 我们指令执行的相依性</span></span><br><span class="line">        |                    |-bash---top</span><br><span class="line">        |                    |-bash</span><br><span class="line">        |                    `-sftp-server</span><br><span class="line"><span class="comment"># 看下这个相依性，差不多就是登陆之后，在 su 切换账户之后，执行的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：同时显示出 PID 与 users</span></span><br><span class="line">[root@study ~]<span class="comment"># pstree -Aup</span></span><br><span class="line">systemd(1)-+-ModemManager(871)-+-&#123;ModemManager&#125;(881)</span><br><span class="line">           |                   `-&#123;ModemManager&#125;(891)</span><br><span class="line">           |-NetworkManager(935)-+-&#123;NetworkManager&#125;(941)</span><br><span class="line">           |                     `-&#123;NetworkManager&#125;(945)</span><br><span class="line">           |-abrt-watch-log(856)</span><br><span class="line">           |-sshd(1269)---sshd(7771)---sshd(7779,mrcode)-+-bash(3239)---sleep(3263)</span><br><span class="line">           |                                             |-bash(7780)---su(8985,root)---bash(9051)---pstree(3264)</span><br><span class="line">           |                                             |-bash(7835)---top(8102)</span><br><span class="line">           |                                             `-sftp-server(7833)</span><br><span class="line"><span class="comment"># 可以看到 sshd 登录的 PID 是 7779 ，用 mrcode 账户登录的。后续用 su 切换到了 root，这个时候新开了一个进程 7780 的 bash</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用 <strong>pstree</strong> 来找相关性，同时使用 <code>-A</code> 来让连线不断开。默认的 <strong>Unicode</strong> 连线有可能出现断线，整体画面显示错位的问题</p>
<p>由 <strong>pstree</strong> 的输出我们可以知道，所有的进程都是依附在 <strong>systemd</strong> 程序下面的，<strong>systemd</strong> 的进程 <strong>ID</strong> 是 1 号，是 <strong>LInux</strong> 核心主动运行的第一个程序</p>
<p>之前讲解遇到僵尸进程为啥要重启，因为 <strong>systemd</strong> 要重启，那么就相当于重启系统了</p>
<h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>进程相互管理是通过一个信号（<strong>signal</strong>）去告知该进程你要它做什么。信号可以通过 <code>man 7 signal</code> 查阅，主要信号代号与名称含义如下：</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>SIGHUP</strong></td>
<td>启动被终止的进程，可让该 PID 重新读取自己的配置文件，类似重新启动</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>SIGINT</strong></td>
<td>相当于用键盘输入 ctrl + c 来终端一个进程的运行</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>SIGKILL</strong></td>
<td>强制终端一个进程的运行，如果该进程进行到一半，那么尚未完成的部分可能会有半成品产生，类似 vim 会有 .filename.swp 保留下来</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td><strong>SIGTERM</strong></td>
<td>以正常的结束进程来终止该进程。由于是正常的终止，所以后续的动作会将他完成。不过，如果该进程已经发生问题，就无法使用正常的方法终止时，输入该 signal 也是没有用的</td>
</tr>
<tr>
<td><strong>19</strong></td>
<td><strong>SIGSTOP</strong></td>
<td>相当于用键盘输入 ctrl-z 来暂停一个进行的运行</td>
</tr>
</tbody></table>
<p>可以使用 <strong>kill</strong> 或 <strong>killall</strong> 把信号传递给进程</p>
<h3 id="kill-signal-PID"><a href="#kill-signal-PID" class="headerlink" title="kill -signal PID"></a>kill -signal PID</h3><p><strong>kill</strong> 可以将信号传递给某个工作（**%jobnumber<strong>） 或某个 **PID</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：以 ps 找出 rsyslogd 这个进程 PID 后，再使用 kill 传递信号，让它可以重新读取配置文件</span></span><br><span class="line">[root@study ~]<span class="comment"># ps aux | grep &#x27;rsyslogd&#x27;</span></span><br><span class="line">root      1273  0.0  0.3 215672  3728 ?        Ssl  21:15   0:00 /usr/sbin/rsyslogd -n</span><br><span class="line">root     18876  0.0  0.0   9096   928 pts/0    RN+  23:30   0:00 grep --color=auto rsyslogd</span><br><span class="line">[root@study ~]<span class="comment"># ps aux | grep &#x27;rsyslogd&#x27; | grep -v &#x27;grep&#x27;</span></span><br><span class="line">root      1273  0.0  0.3 215672  3728 ?        Ssl  21:15   0:00 /usr/sbin/rsyslogd -n</span><br><span class="line">[root@study ~]<span class="comment"># ps aux | grep &#x27;rsyslogd&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">1273</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终的指令是如下的</span></span><br><span class="line">[root@study ~]<span class="comment"># kill -SIGHUP $(ps aux | grep &#x27;rsyslogd&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;) </span></span><br><span class="line"><span class="comment"># 是否重启无法看通过看进程来知道，可以看日志</span></span><br><span class="line">[root@study ~]<span class="comment"># tail -5 /var/log/messages</span></span><br><span class="line">Mar  9 23:20:01 study systemd: Removed slice User Slice of root.</span><br><span class="line">Mar  9 23:30:01 study systemd: Created slice User Slice of root.</span><br><span class="line">Mar  9 23:30:01 study systemd: Started Session 19 of user root.</span><br><span class="line">Mar  9 23:30:01 study systemd: Removed slice User Slice of root.</span><br><span class="line">Mar  9 23:35:20 study rsyslogd: [origin software=<span class="string">&quot;rsyslogd&quot;</span> swVersion=<span class="string">&quot;8.24.0-38.el7&quot;</span> x-pid=<span class="string">&quot;1273&quot;</span> x-info=<span class="string">&quot;http://www.rsyslog.com&quot;</span>] rsyslogd was HUPed</span><br><span class="line"><span class="comment"># 看上面，rsyslogd was HUPed 的字样，表示有重新启动</span></span><br></pre></td></tr></table></figure>

<p>还记得可以查询到登录的 <strong>bash</strong> 的进程吗？也可以使用 <strong>kill -9</strong> 来删除，就意味着，该登陆者被踢下线了</p>
<h3 id="killall-signal-指令名称"><a href="#killall-signal-指令名称" class="headerlink" title="killall -signal 指令名称"></a>killall -signal 指令名称</h3><p>由于 <strong>kill</strong> 后面必须要加上 <strong>PID</strong> （或是 <strong>job number</strong>），所以通常需要配合 <strong>ps</strong>、<strong>pstree</strong> 等指令，还可以使用另外一种方法来达到效果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">killall [-iIe] [<span class="built_in">command</span> name]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-i：interactive ，交互式的，若需要删除时，会出现提示字符给用户确认</span><br><span class="line">	-e：exact，后面接的 <span class="built_in">command</span> name 要一致，但整个完整的指令不能超过 15 个字符</span><br><span class="line">	-I：指令名称（可能含参数）忽略大小写</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：给予 rsyslogd 指令启动的 PID 一个 SIGHUP 的信号</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -1 rsyslogd</span></span><br><span class="line"><span class="comment"># 这里 -1  是信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：强制终止所有以 httpd 启动的进程（其实当前没有该进程启动）</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -9 httpd         </span></span><br><span class="line">httpd: no process found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：依次询问每个 bash 程序是否需要被终止</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -i -9 bash</span></span><br><span class="line">Signal bash(7780) ? (y/N) n</span><br><span class="line">Signal bash(7835) ? (y/N) n</span><br><span class="line">Signal bash(9051) ? (y/N) n</span><br><span class="line">bash: no process found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里都选择了 n，所以提示没有进程被找到，按下 y 就杀掉了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于程序的执行顺序"><a href="#关于程序的执行顺序" class="headerlink" title="关于程序的执行顺序"></a>关于程序的执行顺序</h3><p><strong>CPU</strong> 是切换着执行进程，那么谁先执行？这个就要看进程的优先级 <strong>priority</strong> 与 <strong>CPU</strong> 排程（每个进程被 <strong>CPU</strong> 运行的演算规则）</p>
<h4 id="Priority-与-Nice-值"><a href="#Priority-与-Nice-值" class="headerlink" title="Priority 与 Nice 值"></a>Priority 与 Nice 值</h4><p><strong>CPU</strong> 一秒钟可以运行多达数 <strong>G</strong> 的微指令次数，通过核心的 <strong>CPU</strong> 调度可以让各程序 被 <strong>CPU</strong> 所切换运行， 因此每个程序在一秒钟内或多或少都会被 <strong>CPU</strong> 执行部分的指令码。</p>
<p>如果进程不分优先级顺序的话，那么就是排队执行，如果中间有个进程执行时间很长，其他进程就要等待很长时间</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/linux-queue-priority.jpg"></p>
<p>如上图，有了优先级之后，高优先级的可用被执行两次，低优先级则执行 <strong>1</strong> 次，但是上图仅是示意图，并非高优先级的就会执行两次，<strong>Linux</strong> 给予进程一个优先执行序（<strong>priority PRI</strong>），<strong>PRI</strong> 值越低优先级越高，不过该值是由核心动态调整的，用户无法直接调整 <strong>PRI</strong> 值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 R     0  7183  9051  0  90  10 - 12406 -      pts/0    00:00:00 ps</span><br><span class="line">4 S     0  8985  7780  0  80   0 - 57972 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0  9051  8985  0  90  10 - 29118 do_wai pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure>

<p>由于 <strong>PRI</strong> 是动态调整的，用户无法干涉，但是可以通过 Nice 值来达到一定的优先级调整，<strong>Nice</strong> 就是上述中的 <strong>NI</strong> 值，一般来说 <strong>PRI</strong> 与 <strong>NI</strong> 的相关性 <code>PRI(new)=PRI(old)+nice</code>，虽然可以调整 <strong>nice</strong> 的值，由于 <strong>PRI</strong> 是动态调整的，所以不包装调整完之后，最终的 <strong>PRI</strong> 就会变低，优先级变高的</p>
<p>此外，必须要注意，<strong>nice</strong> 值范围</p>
<ul>
<li><strong>nice</strong> 值范围是 <strong>-20~19</strong></li>
<li><strong>root</strong> 可随意调整自己或他人进程的 <strong>Nice</strong> 值，且范围为 <strong>-20~19</strong></li>
<li>一般使用者仅可调整自己进程的 <strong>Nice</strong> 值，且范围仅为 <strong>0~19</strong>（避免一般用户抢占系统资源）</li>
<li>一般使用者仅可将 <strong>nice</strong> 值越调越高；比如 <strong>nice</strong> 为 <strong>5</strong>，则未来仅能调整到大于 <strong>5</strong>；</li>
</ul>
<p>那么调整 <strong>nice</strong> 值有两种方式：</p>
<ul>
<li>一开始执行程序就立即给予一个特定的 <strong>nice</strong> 值：用 <strong>nice</strong> 指令</li>
<li>调整某个已经存在的 <strong>PID</strong> 的 <strong>nice</strong> 值：用 <strong>renice</strong> 指令</li>
</ul>
<h4 id="nice：新执行的指令给予新的-nice-值"><a href="#nice：新执行的指令给予新的-nice-值" class="headerlink" title="nice：新执行的指令给予新的 nice 值"></a>nice：新执行的指令给予新的 nice 值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nice [-n 数字] <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">-n：后面接一个数值，数值范围 -20~19</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1： 用 root 给一个 nice 值为 -5，用于执行 vim，并观察该进程</span></span><br><span class="line">[root@study ~]<span class="comment"># nice -n -5 vim &amp;</span></span><br><span class="line">[2] 30185</span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  8985  7780  0  80   0 - 57972 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0  9051  8985  0  90  10 - 29118 do_wai pts/0    00:00:00 bash</span><br><span class="line">4 T     0 30185  9051  0  85   5 - 10791 do_sig pts/0    00:00:00 vim</span><br><span class="line">0 R     0 30652  9051  0  90  10 - 12407 -      pts/0    00:00:00 ps</span><br><span class="line"><span class="comment"># 原本的 bash PRI 为 90，所以 vim 预设为 90，这里给予 nice -5，所以最终 PRI 变成了 85</span></span><br><span class="line"><span class="comment"># 要注意：不一定正好变成 85，因为会动态调整的</span></span><br></pre></td></tr></table></figure>

<p>那么通常什么时候需要将 <strong>nice</strong> 值调大呢？比如：系统的背景工作中，某些比较不重要的进程进行时，比如备份工作，由于备份工作相当耗系统资源，这个时候就可以将备份的指令 <strong>nice</strong> 值调大一些，可以使系统的资源分配更公平</p>
<h4 id="renice：已存在进程的-nice-重新调整"><a href="#renice：已存在进程的-nice-重新调整" class="headerlink" title="renice：已存在进程的 nice 重新调整"></a>renice：已存在进程的 nice 重新调整</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renice [number] PID</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：找出自己的 bash PID ,并将该 PID 的 nice 调整到 -5</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  3426  3372  0  80   0 - 58072 do_wai pts/1    00:00:00 su</span><br><span class="line">4 S     0  3443  3426  0  80   0 - 29059 do_wai pts/1    00:00:00 bash</span><br><span class="line">0 R     0  3487  3443  0  80   0 - 12407 -      pts/1    00:00:00 ps</span><br><span class="line">[root@study ~]<span class="comment"># renice -5 3443</span></span><br><span class="line">3443 (process ID) old priority 0, new priority -5</span><br><span class="line">[root@study ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  3426  3372  0  80   0 - 58072 do_wai pts/1    00:00:00 su</span><br><span class="line">4 S     0  3443  3426  0  75  -5 - 29059 do_wai pts/1    00:00:00 bash</span><br><span class="line">0 R     0  3493  3443  0  75  -5 - 12407 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure>

<h3 id="系统资源的观察"><a href="#系统资源的观察" class="headerlink" title="系统资源的观察"></a>系统资源的观察</h3><p><strong>top</strong> 可以看到很多系统的资源使用情况，还有其他工具</p>
<h3 id="free：观察内存使用情况"><a href="#free：观察内存使用情况" class="headerlink" title="free：观察内存使用情况"></a>free：观察内存使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-b：单位参数；默认是用 k，其他单位对应 bytes、Mbytes、Kbytes、Gbytes</span><br><span class="line">	-t: 输出的最终结果，显示物理内存与 swap 的总量</span><br><span class="line">	-s：可以让系统每几秒输出一次，不间断输出；</span><br><span class="line">	-c：与 -s 同时处理，让 free 列出几次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：显示目前系统的内存容量</span></span><br><span class="line">[root@study ~]<span class="comment"># free -m</span></span><br><span class="line"><span class="comment">#			  总内存		已使用		   剩余							  可用</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7631         713        6374          15         542        6671</span><br><span class="line">Swap:          4095           0        4095</span><br></pre></td></tr></table></figure>

<p><code>shared buff/cache</code> 是缓冲区等使用量，<code>available</code> 是可用容量，当系统忙碌时，可以被释放掉，给系统使用</p>
<p>由于系统会把空闲内存拿来做缓冲区之用，所以你系统没有那么繁忙的时候，也会显示内存被用的多的原因，这个是正常的，需要注意的是 <strong>swap</strong>，<strong>swap</strong> 最好不要被使用，而且不要使用超过 <strong>20%</strong> 以上，因为 <strong>swap</strong> 被使用，那么很有可能是物理内存不够用了</p>
<h3 id="uname：查询系统与核心相关信息"><a href="#uname：查询系统与核心相关信息" class="headerlink" title="uname：查询系统与核心相关信息"></a>uname：查询系统与核心相关信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uname [-asrmpi]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：所有系统相关的，都列出来</span><br><span class="line">	-s：系统核心名称</span><br><span class="line">	-r：核心的版本</span><br><span class="line">	-m：本系统的硬件名称，例如 i686 或 x86_64</span><br><span class="line">	-p：CPU 的类型，与 -m 类似</span><br><span class="line">	-i：硬件的平台（ix86）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：输出系统的基本信息</span></span><br><span class="line">[root@study ~]<span class="comment"># uname -a </span></span><br><span class="line"><span class="comment"># 核心名称   主机名			核心版本			  核心建立日期 与 硬件平台</span></span><br><span class="line">Linux study.centos.mrcode 3.10.0-1062.el7.x86_64 <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="uptime：观察系统启动时间与工作负载"><a href="#uptime：观察系统启动时间与工作负载" class="headerlink" title="uptime：观察系统启动时间与工作负载"></a>uptime：观察系统启动时间与工作负载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># uptime </span></span><br><span class="line"> 17:31:46 up 43 min,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line"> <span class="comment"># 当前时间	 已开机多久  几个用户登录	平均负载：1、5、15 分钟的平均负载</span></span><br></pre></td></tr></table></figure>

<h3 id="netstat：追踪网络或插槽文件"><a href="#netstat：追踪网络或插槽文件" class="headerlink" title="netstat：追踪网络或插槽文件"></a>netstat：追踪网络或插槽文件</h3><p>该指令常被用在网络的监控方面；<strong>netstat</strong> 基本上的输出分为两大部分：网络与系统自己的进程相关性部分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -[atunlp]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：将目前系统上所有的联机、监听、Socket 数据都列出来</span><br><span class="line">	-t：列出 tcp 网络封包的数据</span><br><span class="line">	-u：列出 udp 网络封包的数据</span><br><span class="line">	-n：不以进程的服务名称，以端口号来显示</span><br><span class="line">	-l：列出目前正在网络监听的（listen）的服务</span><br><span class="line">	-p：列出该网络服务的进程 PID</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上已经建立的网络连接与 unix socket 状态</span></span><br><span class="line">[root@study ~]<span class="comment"># netstat </span></span><br><span class="line">Active Internet connections (w/o servers)		<span class="comment"># 与网络相关部分</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0     36 study.centos.mrcode:ssh 192.168.4.170:50821     ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)	<span class="comment"># 与本机的进程自己的相关性（非网络）</span></span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    12644    /run/systemd/shutdownd</span><br><span class="line">unix  3      [ ]         DGRAM                    7618     /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    7620     /run/systemd/cgroups-agent</span><br><span class="line">unix  5      [ ]         DGRAM                    7634     /run/systemd/journal/socket</span><br></pre></td></tr></table></figure>

<p>网络联机部分：</p>
<ul>
<li><strong>Proto</strong>：网络封包协议，主要分为 <strong>TCP</strong> 与 <strong>UDP</strong>。</li>
<li><strong>Recv-Q</strong>：非由用户程序连接到此 <strong>socket</strong> 的复制和总 <strong>Bytes</strong> 数</li>
<li><strong>Send-Q</strong>：非由远程主机传送过来的 <strong>acknowledged</strong> 总 <strong>Bytes</strong> 数</li>
<li><strong>Local Address</strong>：本地端的 <strong>Ip:port</strong></li>
<li><strong>Foreign Address</strong>：远程主机的 <strong>IP:port</strong></li>
<li><strong>State</strong>：联机状态，主要有建立（<strong>ESTABLISED</strong>）、监听（<strong>LISTEN</strong>）</li>
</ul>
<p>上面有一条数据，含义是：<strong>192.168.4.170:50821</strong> 通过 <strong>TCP</strong> 封包联机到本机端的 <strong>study.centos.mrcode:ssh</strong>，状态是 <strong>ESTABLISHED</strong>；至于更多的知识点这里不深入，在服务器篇讲解</p>
<p>除了网络上的联机之外，<strong>Linux</strong> 系统上的进程是可以接收不同进程所发来的信息，通过 <strong>socket file</strong> 可以在两个进程之间通信。比如 <strong>X Window</strong> 这种需要通过网络连接的软件，新版 <strong>distribution</strong> 以 <strong>socket</strong> 来进行窗口接口的联机沟通。上表中 <strong>socket file</strong> 的输出字段含义为：</p>
<ul>
<li><strong>Proto</strong>：一般是 <strong>unix</strong></li>
<li><strong>RefCnt</strong>：连接到此 <strong>socket</strong> 的进程数量</li>
<li><strong>Flags</strong>：联机旗标</li>
<li><strong>Type</strong>：<strong>socket</strong> 存取的类型。主要有 <strong>STREAM</strong>：确认联机、<strong>DGRAM</strong>：不需确认 两种</li>
<li><strong>State</strong>：若为 <strong>CONNECTED</strong> 表示多个进程之间已经联机建立</li>
<li><strong>PATH</strong>：连接到此 <strong>socket</strong> 的相关程序路径，或则是相关数据输出的路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：找出目前系统上已在监听的网络联机与 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># netstat -tulnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1380/cupsd          </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1579/master         </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      3765/sshd: mrcode@p </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1973/dnsmasq        </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1379/sshd           </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      1380/cupsd          </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1579/master         </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN      3765/sshd: mrcode@p </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1379/sshd           </span><br><span class="line">udp        0      0 192.168.122.1:53        0.0.0.0:*                           1973/dnsmasq        </span><br><span class="line">udp        0      0 0.0.0.0:67              0.0.0.0:*                           1973/dnsmasq        </span><br><span class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                           1/systemd           </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                           938/chronyd         </span><br><span class="line">udp        0      0 0.0.0.0:41378           0.0.0.0:*                           953/avahi-daemon: r </span><br><span class="line">udp        0      0 0.0.0.0:672             0.0.0.0:*                           927/rpcbind         </span><br><span class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                           953/avahi-daemon: r </span><br><span class="line">udp6       0      0 :::111                  :::*                                1/systemd           </span><br><span class="line">udp6       0      0 ::1:323                 :::*                                938/chronyd         </span><br><span class="line">udp6       0      0 :::672                  :::*                                927/rpcbind</span><br><span class="line"><span class="comment"># 最后一个字段是 PID 与进程的指令名称</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：将上述的 0 0.0.0.0:41378 网络服务关闭</span></span><br><span class="line">[root@study ~]<span class="comment"># kill -9 953</span></span><br><span class="line">[root@study ~]<span class="comment"># killall -9 avahi-daemon</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>对于非正常的关闭服务方法就用暴力的 kill -9，正常的关闭方式，下个章节讲解</p>
<h3 id="dmesg：分析核心产生的信息"><a href="#dmesg：分析核心产生的信息" class="headerlink" title="dmesg：分析核心产生的信息"></a>dmesg：分析核心产生的信息</h3><p>系统在开机的时候，核心会去侦测系统的硬件，那么硬件的检测信息由于开机过程中要么一闪而过，要么没有显示在屏幕上，可以使用 <strong>dmesg</strong> 来查看</p>
<p>从系统开机起，核心产生的信息都会记录到内存中，通过 <strong>dmesg</strong> 可以查询到，信息过多时可以通过 <strong>more</strong> 指令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：输出所有的核心开机时的信息</span></span><br><span class="line">[root@study ~]<span class="comment"># dmesg | more</span></span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuset</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpu</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuacct</span><br><span class="line">[    0.000000] Linux version 3.10.0-1062.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat </span><br><span class="line">4.8.5-36) (GCC) ) <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019</span></span><br><span class="line">[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spect</span><br><span class="line">re_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=zh_CN.UTF-8</span><br><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved</span><br><span class="line">--More--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：找到硬盘相关信息</span></span><br><span class="line">[root@study ~]<span class="comment"># dmesg | grep -i &#x27;sda&#x27;</span></span><br><span class="line">[    2.632630] sd 2:0:0:0: [sda] 85491712 512-byte logical blocks: (43.7 GB/40.7 GiB)</span><br><span class="line">[    2.632651] sd 2:0:0:0: [sda] Write Protect is off</span><br><span class="line">[    2.632653] sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00</span><br><span class="line">[    2.632662] sd 2:0:0:0: [sda] Write cache: enabled, <span class="built_in">read</span> cache: enabled, doesn<span class="string">&#x27;t support DPO or FUA</span></span><br><span class="line"><span class="string">[    2.643988]  sda: sda1 sda2 sda3 sda4 sda5 sda6 sda7 sda8</span></span><br><span class="line"><span class="string">[    2.644394] sd 2:0:0:0: [sda] Attached SCSI disk</span></span><br><span class="line"><span class="string">[    4.616881] XFS (sda2): Mounting V5 Filesystem</span></span><br><span class="line"><span class="string">[    4.636376] XFS (sda2): Ending clean mount</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="vmstat：侦测系统资源变化"><a href="#vmstat：侦测系统资源变化" class="headerlink" title="vmstat：侦测系统资源变化"></a>vmstat：侦测系统资源变化</h3><p><strong>vmstat</strong> 可以侦测 <strong>CPU</strong>、内存、磁盘输入输出状态等信息。比如可以了解一台繁忙的系统到底是哪个环节最耗时间，可以使用 <strong>vmstat</strong> 分析看看，常见选项与参数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vmstat [-a] [延迟 [总计侦测次数]]		<span class="comment"># CPU/内存等信息</span></span><br><span class="line">vmstat [-fs]										 <span class="comment"># 内存相关</span></span><br><span class="line">vmstat [-S 单位]									<span class="comment"># 设置显示数据的单位</span></span><br><span class="line">vmstat [-d]											 <span class="comment"># 与磁盘有关</span></span><br><span class="line">vmstat [-p 分区槽]								 <span class="comment"># 与磁盘有关</span></span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：使用 inactive/active（是否活跃）取代 buffer/cache 的内存输出信息</span><br><span class="line">	-f：开机到目前为止，系统复制（fork）的进程数</span><br><span class="line">	-s：将一些事件（开机到目前为止）导致的内存变化情况列表说明</span><br><span class="line">	-S：后面可以接单位，例如 k、M 等</span><br><span class="line">	-d：列出磁盘的读写总量统计表</span><br><span class="line">	-p：后面列出分区槽，可显示该分区槽的读写总量统计表</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：统计目前主机 CPU 状态，每秒一次，总共 3 次</span></span><br><span class="line">[root@study ~]<span class="comment"># vmstat 1 3</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 2  0      0 450296   2116 346828    0    0   501    36  181  320  2  3 95  0  0</span><br><span class="line"> 0  0      0 450156   2116 346860    0    0     0     0  163  223  2  3 95  0  0</span><br><span class="line"> 0  0      0 450156   2116 346860    0    0     0     0  273  388  3  5 91  0  0</span><br></pre></td></tr></table></figure>

<p>还可以不限制次数，就一直统计字段说明如下：</p>
<ul>
<li><p><strong>procs</strong>：进程</p>
<ul>
<li><strong>r</strong>：等待运行中的进程数量</li>
<li><strong>b</strong>：不可被唤醒的进程数量</li>
</ul>
<p><strong>rb</strong> 越多表示系统越繁忙。因为系统太忙，导致很多进程无法被执行或一直在等待而无法被唤醒</p>
</li>
<li><p><strong>memory</strong>：内存</p>
<ul>
<li><strong>swpd</strong>：虚拟内存被使用的容量</li>
<li><strong>free</strong>：未被使用的内容容量</li>
<li><strong>buff</strong>：用于缓冲存储器</li>
<li><strong>cache</strong>：用于高速缓存</li>
</ul>
<p>这里的含义与 <strong>free</strong> 指令一致</p>
</li>
<li><p><strong>swap</strong>：内存交换空间</p>
<ul>
<li><strong>si</strong>：由磁盘中将进程取出的量</li>
<li><strong>so</strong>：由于内存不足而将没用到的进程写入到磁盘的 swap 的容量</li>
</ul>
<p>如果 <strong>si</strong>、<strong>so</strong> 的数值太大，表示内存的数据常常得在磁盘与主存储器之间传来传去，效率很低</p>
</li>
<li><p><strong>io</strong>：磁盘读写</p>
<ul>
<li><strong>bi</strong>：由磁盘读入的区块数量</li>
<li><strong>bo</strong>：写入到磁盘去的区块数量</li>
</ul>
<p>如果这部分数值越高，代表系统的 <strong>I/O</strong> 非常忙碌</p>
</li>
<li><p><strong>system</strong>：系统</p>
<ul>
<li><strong>in</strong>：每秒被中断的进程次数</li>
<li><strong>cs</strong>：每秒钟进行的事件切换次数</li>
</ul>
<p>这两个值越大，代表系统与接口设备的沟通非常频繁，接口设备包括磁盘、网卡、时钟等</p>
</li>
<li><p><strong>CPU</strong>：</p>
<ul>
<li><strong>us</strong>：非核心层的 <strong>CPU</strong> 使用状态</li>
<li><strong>sy</strong>：核心层所使用的 <strong>CPU</strong> 状态</li>
<li><strong>id</strong>：闲置的状态</li>
<li><strong>wa</strong>：等待 <strong>I/O</strong> 所耗费的 <strong>CPU</strong> 状态</li>
<li><strong>st</strong>：被虚拟机（<strong>virtual machine</strong>）所盗用的 <strong>CPU</strong> 使用状态（<strong>2.6.11</strong>）</li>
</ul>
</li>
</ul>
<p>练习机上看不到忙碌的数据，如果有一天，你的系统非常忙碌，可以使用该指令来分析是哪里出现了问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：系统上面所有的磁盘读写状态</span></span><br><span class="line">[root@study ~]<span class="comment"># vmstat -d</span></span><br><span class="line">disk- ------------reads------------ ------------writes----------- -----IO------</span><br><span class="line">       total merged sectors      ms  total merged sectors      ms    cur    sec</span><br><span class="line">sda     7640      1  709893    6377   2486    351   54323    8478      0      5</span><br><span class="line">sdb      116      0    5384      27      0      0       0       0      0      0</span><br><span class="line">sr0        0      0       0       0      0      0       0       0      0      0</span><br><span class="line">dm-0    7072      0  661717    6054   2611      0   45902   10871      0      5</span><br><span class="line">dm-1      88      0    4408      21      0      0       0       0      0      0</span><br><span class="line">dm-2     103      0   10834      58     23      0    4325      56      0      0</span><br></pre></td></tr></table></figure>

<p>至于上面的字段含义，可以通过 <strong>man vmstat</strong> 查阅</p>
<h2 id="特殊文件与进程"><a href="#特殊文件与进程" class="headerlink" title="特殊文件与进程"></a>特殊文件与进程</h2><p>在第 6 章中讲到特殊权限 <strong>SUID</strong>、<strong>SGID</strong>、<strong>SBIT</strong>，那么这些权限对于你的 <strong>进程</strong> 是如何影响的？进程用到的系统资源，比如硬盘资源，使用 <strong>umount</strong> 硬盘时，出现提示 「<strong>device is busy</strong>」的提示是怎么回事？</p>
<h3 id="具有-SUID、SGID-权限的指令执行状态"><a href="#具有-SUID、SGID-权限的指令执行状态" class="headerlink" title="具有 SUID、SGID 权限的指令执行状态"></a>具有 SUID、SGID 权限的指令执行状态</h3><p><strong>SUID</strong> 的权限与进程的相关性非常大，<strong>SUID</strong> 的程序是如何被一般用户执行，具有什么特色？</p>
<ul>
<li><strong>SUID</strong> 权限仅对二进制程序（<strong>binary program</strong>）有效</li>
<li>执行者对于该进程需要具有 <strong>x</strong> 的可执行权限</li>
<li>本权限仅在执行程序的过程中有效（<strong>run-time</strong>）</li>
<li>执行者将具有该程序拥有者（<strong>owner</strong>）的权限</li>
</ul>
<p>所以，整个 <strong>SUID</strong> 的权限会生效是由于<strong>具有该权限的程序被触发</strong>，一个进程表示一个程序的运行，所以执行者可以具有程序拥有者的权限就是在该程序变成进程的时候</p>
<p>比如执行了 <strong>passwd</strong> 后你就具有 <strong>root</strong> 的权限？是因为你再触发 <strong>passwd</strong> 后，会取得一个新的进程与 <strong>PID</strong>，该 <strong>PID</strong> 产生时通过 <strong>SUID</strong> 来给予该 <strong>PID</strong> 特殊的权限设置</p>
<p>下面使用 <strong>mrcode</strong> 登录系统并执行 <strong>passwd</strong> 后，通过工作控制来理解</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">export</span> LANG=C</span><br><span class="line">[mrcode@study ~]$ passwd</span><br><span class="line">Changing password <span class="keyword">for</span> user mrcode.</span><br><span class="line">Changing password <span class="keyword">for</span> mrcode.</span><br><span class="line">(current) UNIX password: 		<span class="comment"># 这里按下 ctrl + z，并按下 enter 键</span></span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 passwd</span><br><span class="line">[mrcode@study ~]$ pstree -uA</span><br><span class="line">systemd-+-ModemManager---2*[&#123;ModemManager&#125;]</span><br><span class="line">        |-sshd-+-sshd---sshd(mrcode)-+-bash---su(root)---bash</span><br><span class="line">        |      |                     |-bash---top</span><br><span class="line">        |      |                     |-bash---sleep</span><br><span class="line">        |      |                     `-sftp-server</span><br><span class="line">        |      `-sshd---sshd(mrcode)-+-bash-+-passwd(root)</span><br><span class="line">        |                            |      `-pstree</span><br><span class="line">        |                            |-bash---top</span><br><span class="line">        |                            |-bash---sleep</span><br><span class="line">        |                            `-sftp-server</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的进程来看，在执行 <strong>passwd</strong> 前是 <strong>mrcode</strong> 的权限，<strong>passwd</strong> 则是 <strong>root</strong> 权限，<strong>passwd</strong> 是由 <strong>bash</strong> 衍生出来的，但是权限不一样，这样一来就能理解为什么不同程序所产生的权限不同了，是由于 <strong>SUID</strong> 程序运行过程中产生的进程的关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ <span class="built_in">type</span> passwd</span><br><span class="line">passwd is hashed (/usr/bin/passwd)</span><br><span class="line">[mrcode@study ~]$ ll /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27856 Aug  9  2019 /usr/bin/passwd</span><br><span class="line"><span class="comment">#可以看到，的确该指令也有 s 权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以通过以下指令查找 SUID/SGID 的文件</span></span><br><span class="line">find / -perm /6000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="proc-代表的意义"><a href="#proc-代表的意义" class="headerlink" title="/proc/* 代表的意义"></a><code>/proc/*</code> 代表的意义</h3><p>进程在内存中，内存中的数据都是写入到 <code>/proc/*</code> 目录下的，可以直接查看该目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mrcode@study ~]$ ll /proc/</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x.  9 root           root                         0 Mar 15 20:13 1</span><br><span class="line">dr-xr-xr-x.  9 root           root                         0 Mar 15 20:13 10</span><br><span class="line">dr-xr-xr-x.  9 root           root                         0 Mar 15 20:13 11</span><br><span class="line">...</span><br><span class="line">dr-xr-xr-x.  2 root           root                         0 Mar 15 20:54 sysvipc</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 timer_list</span><br><span class="line">-rw-r--r--.  1 root           root                         0 Mar 15 20:54 timer_stats</span><br><span class="line">dr-xr-xr-x.  4 root           root                         0 Mar 15 20:54 tty</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:16 uptime</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 version</span><br><span class="line">-r--------.  1 root           root                         0 Mar 15 20:54 vmallocinfo</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 vmstat</span><br><span class="line">-r--r--r--.  1 root           root                         0 Mar 15 20:54 zoneinfo</span><br></pre></td></tr></table></figure>

<p>基本上，目前主机上面的各个进程的 PID 都是以目录的形态存在该目录中。如第 <strong>1</strong> 行的 <strong>PID</strong> 为 <strong>1</strong>，它是开机执行的第一个程序 <strong>systemd</strong>，该 <strong>PID</strong> 的所有相关信息都写入在 <code>/proc/1/*</code> 下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ll /proc/1</span></span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x. 2 root root 0 Mar 15 20:48 attr</span><br><span class="line">-rw-r--r--. 1 root root 0 Mar 15 20:53 autogroup</span><br><span class="line">-r--------. 1 root root 0 Mar 15 20:53 auxv</span><br><span class="line">-r--r--r--. 1 root root 0 Mar 15 20:13 cgroup</span><br><span class="line">-r--r--r--. 1 root root 0 Mar 15 20:13 cmdline			<span class="comment"># 指令串</span></span><br><span class="line">-r--------. 1 root root 0 Mar 15 20:13 environ			<span class="comment"># 一些环节变量</span></span><br><span class="line">lrwxrwxrwx. 1 root root 0 Mar 15 20:13 exe -&gt; /usr/lib/systemd/systemd</span><br></pre></td></tr></table></figure>

<p>里面数据很多，可以查询下 <strong>cmdline</strong> 的内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># cat /proc/1/cmdline</span></span><br><span class="line">/usr/lib/systemd/systemd--switched-root--system--deserialize22</span><br></pre></td></tr></table></figure>

<p>上面指令显示了是以什么参数启动的 <strong>systemd</strong> 指令，这个是针对 <strong>PID</strong> 有关的内容，下面是针对整个 <strong>Linux</strong> 系统相关的参数，对应与 <strong>/proc</strong> 目录下的文件如下</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>/proc/cmdline</code></td>
<td>加载 kernel 时所下达的相关指令与参数，查询此文件，可了解指令是如何启动的</td>
</tr>
<tr>
<td><code>/proc/cpuinfo</code></td>
<td>本机的 CPU 相关信息，包含频率、类型与计算功能等</td>
</tr>
<tr>
<td><code>/proc/devices</code></td>
<td>系统各个主要装置的主要装置代号，与 mknod 有关</td>
</tr>
<tr>
<td><code>/proc/filesystems</code></td>
<td>目前系统已经加载的文件系统</td>
</tr>
<tr>
<td><code>/proc/interrupts</code></td>
<td>目前系统上 IRQ 分配状态</td>
</tr>
<tr>
<td><code>/proc/ioports</code></td>
<td>目前系统上各个装置所配置的 I/O 地址</td>
</tr>
<tr>
<td><code>/proc/kcore</code></td>
<td>内存大小，很大？不要读取该文件</td>
</tr>
<tr>
<td><code>/proc/loadavg</code></td>
<td>top 以及 uptime 的三个平均数值就是记录在这里的</td>
</tr>
<tr>
<td><code>/proc/meminfo</code></td>
<td>使用 free 列出的内存信息，在这里也可以查询到</td>
</tr>
<tr>
<td><code>/proc/modules</code></td>
<td>目前我们 LInux 已经加载的模块列表，可以看成是驱动程序</td>
</tr>
<tr>
<td><code>/proc/mounts</code></td>
<td>系统已经挂载的数据，就是用 mount 指令查询出来的数据</td>
</tr>
<tr>
<td><code>/proc/swaps</code></td>
<td>系统挂载的内存在哪里？使用掉的 partition 记录在这里</td>
</tr>
<tr>
<td><code>/proc/partitions</code></td>
<td>使用 fsidk -l 会出现目前所有的 partition，在该文件中也有记录</td>
</tr>
<tr>
<td><code>/proc/uptime</code></td>
<td>使用 uptime 出现的信息</td>
</tr>
<tr>
<td><code>/proc/version</code></td>
<td>核心的版本，使用 uname -a 显示的信息</td>
</tr>
<tr>
<td><code>/proc/bus/*</code></td>
<td>一些总线的装置，还有 USB 的装置也记录在这里</td>
</tr>
</tbody></table>
<p>这些文件内容建议使用 <strong>cat</strong> 去查阅看看，不必深入了解，如果未来你要写某些工具软件，那么这个目录下相关文件可能会对你有点帮助</p>
<h3 id="查询已开启文件或已执行进程开启之文件"><a href="#查询已开启文件或已执行进程开启之文件" class="headerlink" title="查询已开启文件或已执行进程开启之文件"></a>查询已开启文件或已执行进程开启之文件</h3><p>还有一些与进程相关的指令可以参考与应用</p>
<h4 id="fuser：由文件（或文件系统）找出正在使用该文件的进程"><a href="#fuser：由文件（或文件系统）找出正在使用该文件的进程" class="headerlink" title="fuser：由文件（或文件系统）找出正在使用该文件的进程"></a>fuser：由文件（或文件系统）找出正在使用该文件的进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fuser [-umv] [-k [i] [signal]] file/dir</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-u：除了进程的 PID 之外，同时列出该进程的拥有者</span><br><span class="line">	-m：后面接的文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效</span><br><span class="line">	-v：可以列出每个文件与进程还有指令的完整相关性</span><br><span class="line">	-k：找出使用该文件/目录的 PID，并试图以 SIGKILL 这个信号给予该 PID</span><br><span class="line">	-i：必须与 -k 配合使用，在删除 PID 之前会先询问使用者</span><br><span class="line">	-signal：例如 -1 -15 等，若不加的话，预设是 -9：SIGKILL</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：找出目前所在目录的使用 PID、所属账户、权限</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -uv .</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/root:               root       2604 ..c.. (root)bash</span><br></pre></td></tr></table></figure>

<p>有一个进程属于 <strong>root</strong>，而 <strong>ACCESS</strong> 项则略为复杂一点：</p>
<ul>
<li><strong>c</strong>：此进程在当前的目录下（非次目录）</li>
<li><strong>e</strong>：可被触发为执行状态</li>
<li><strong>f</strong>：是一个被开启的文件</li>
<li><strong>r</strong>：代表顶层目录（<strong>root directory</strong>）</li>
<li><strong>F</strong>：该文件被开启了，不过在等待回应中</li>
<li><strong>m</strong>：可能为分享的动态函数库</li>
</ul>
<p>如果想知道某个文件系统下又多少进程正在占用该文件系统时，可以使用 <code>-m</code> 选项</p>
<p>下面做几个简单测试，包括实体文件系统挂载与 /proc 虚拟文件系统的内容，看看有多少的进程对这些挂载点或其他目录的使用状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 2：找到所有使用到 /proc 这个文件系统的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -uv /proc/</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/proc:               root     kernel mount (root)/proc</span><br><span class="line">                     rtkit       834 .rc.. (rtkit)rtkit-daemon</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># fuser -muv /proc/</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/proc:               root     kernel mount (root)/proc</span><br><span class="line">                     root          1 f.... (root)systemd</span><br><span class="line">                     root        589 f.... (root)systemd-journal</span><br><span class="line">                     rtkit       834 .rc.. (rtkit)rtkit-daemon</span><br><span class="line">                     root        844 f.... (root)udisksd</span><br><span class="line">                     root        929 f.... (root)NetworkManager</span><br><span class="line">                     root       1277 F.... (root)libvirtd</span><br><span class="line">                     root       1638 F.... (root)X</span><br><span class="line">                     gdm        1693 f.... (gdm)gnome-shell</span><br><span class="line">                     root       1759 f.... (root)packagekitd</span><br><span class="line">                     mrcode     2280 f.... (mrcode)top</span><br><span class="line">                     mrcode     7722 f.... (mrcode)top</span><br><span class="line"><span class="comment"># 这就能看到有几个程序在对该目录进行存取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：找到所有使用到 /home 这个文件系统的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># echo $$</span></span><br><span class="line">2604				<span class="comment"># 先确定下自己的 bash 的进程 PID</span></span><br><span class="line">[root@study ~]<span class="comment">#  cd /home/</span></span><br><span class="line">[root@study home]<span class="comment"># fuser -muv .</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/home:               root     kernel mount (root)/home</span><br><span class="line">                     mrcode     1346 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     1371 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     1378 ..c.. (mrcode)sleep</span><br><span class="line">                     mrcode     1399 ..c.. (mrcode)sleep</span><br><span class="line">                     mrcode     1958 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     1991 ..c.. (mrcode)sftp-server</span><br><span class="line">                     mrcode     1992 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     2280 ..c.. (mrcode)top</span><br><span class="line">                     root       2604 ..c.. (root)bash			<span class="comment"># 看这里，自己的 bash 存在列表中</span></span><br><span class="line">                     mrcode     7294 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     7358 ..c.. (mrcode)sftp-server</span><br><span class="line">                     mrcode     7362 ..c.. (mrcode)bash</span><br><span class="line">                     mrcode     7722 ..c.. (mrcode)top</span><br><span class="line">                     root       8884 ..c.. (root)passwd</span><br><span class="line"></span><br><span class="line">[root@study home]<span class="comment"># cd ~</span></span><br><span class="line">[root@study ~]<span class="comment"># umount /home/</span></span><br><span class="line">umount: /home: target is busy.</span><br><span class="line">        (In some cases useful info about processes that use</span><br><span class="line">         the device is found by lsof(8) or fuser(1))</span><br><span class="line"><span class="comment"># 通过 fuser 知道有好几个进程在该目录下运行，可以通过如下的方式一个一个删除</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -mki /home/</span></span><br><span class="line">/home:                7294c  7358c  7362c  7722c  8884c 19238c 19289c 19291c 19601c 25650c 25674c 25685c 25746c</span><br><span class="line">Kill process 7294 ? (y/N)</span><br><span class="line"><span class="comment"># 以上指令有一个问题，颇为棘手，就是很容易杀到自己 bash 的进程，那么久直接把直接踢掉了</span></span><br><span class="line"><span class="comment"># 不知道这个这么排除掉是出方便的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面可以针对整个文件系统，其实也可以针对单一文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 4：找到 /run 下属于 FIFO 类型的文件，并找出存取该文件的进程</span></span><br><span class="line">[root@study ~]<span class="comment"># find /run -type p</span></span><br><span class="line">/run/dmeventd-client</span><br><span class="line">/run/dmeventd-server</span><br><span class="line">/run/systemd/inhibit/7.ref</span><br><span class="line">/run/systemd/inhibit/6.ref</span><br><span class="line">/run/systemd/inhibit/5.ref</span><br><span class="line">/run/systemd/inhibit/4.ref</span><br><span class="line">/run/systemd/inhibit/2.ref</span><br><span class="line">/run/systemd/inhibit/1.ref</span><br><span class="line">/run/systemd/sessions/13.ref</span><br><span class="line">/run/systemd/sessions/5.ref</span><br><span class="line">/run/systemd/sessions/c1.ref</span><br><span class="line">/run/systemd/initctl/fifo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随便找到文件测试</span></span><br><span class="line">[root@study ~]<span class="comment"># fuser -uv /run/systemd/sessions/c1.ref</span></span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/run/systemd/sessions/c1.ref:</span><br><span class="line">                     root        842 f.... (root)systemd-logind</span><br><span class="line">                     root       1649 F.... (root)gdm-session-wor</span><br><span class="line"><span class="comment"># 通常系统的 FIFO 文件都会放置到 /run 下，通过该方式来追踪该文件存取的 process</span></span><br><span class="line"><span class="comment"># 同样也能够看到系统有多忙碌（进程多当然就忙碌）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>fuser</strong> 的重点是可以让我们了解到某个文件系统或文件目前正在被哪些进程所使用</p>
<h4 id="lsof：列出被进程所开启的文件名"><a href="#lsof：列出被进程所开启的文件名" class="headerlink" title="lsof：列出被进程所开启的文件名"></a>lsof：列出被进程所开启的文件名</h4><p>fuser 是通过文件或则装置名去找使用它的进程，而 lsof 则是通过某个进程去找它开启或使用的文件与装置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lsof [-aUu] [+d]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：多想数据需要同时成立才显示出结果时</span><br><span class="line">	-U：仅列出 Unix like 系统的 socket 文件类型</span><br><span class="line">	-u：后面接 username，列出该使用者相关进程所开启的文件</span><br><span class="line">	+d：后面接目录，找出某个目录下已经被开启的文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上所有已经被开启的文件与装置</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof</span></span><br><span class="line">libvirtd   1277 1318           root  mem       REG              253,0     53848    9645351 /usr/lib64/libavahi-common.so.3.5.3</span><br><span class="line">libvirtd   1277 1318           root  mem       REG              253,0    155784    8569818 /usr/lib64/libselinux.so.1</span><br><span class="line">libvirtd   1277 1318           root  mem       REG              253,0     37056    8655202 /usr/lib64/libacl.so.1.1.0</span><br><span class="line"><span class="comment"># 文件很多很多，直接刷屏了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：仅列出关于 root 的所有进程开启的 socket 文件</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof -u root -a -U</span></span><br><span class="line">COMMAND     PID USER   FD   TYPE             DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">systemd       1 root   12u  unix 0xffff8922437ed800      0t0  12513 /run/systemd/private</span><br><span class="line">systemd       1 root   13u  unix 0xffff892243dc2c00      0t0  25917 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   15u  unix 0xffff892243e71800      0t0  25941 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   16u  unix 0xffff892243e8fc00      0t0  25942 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   17u  unix 0xffff892243e6ec00      0t0  26002 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   18u  unix 0xffff892243e6dc00      0t0  26009 /run/systemd/journal/stdout</span><br><span class="line">systemd       1 root   23u  unix 0xffff89224359a800      0t0   7620 /run/systemd/notify</span><br><span class="line"><span class="comment"># 注意 -a 参数，分别执行 lsof -u root 及 lsof -U 信息都不同</span></span><br><span class="line"><span class="comment"># -a 取他们的交集结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：列出目前系统上所有被启动的周边装置</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof +d /dev/</span></span><br><span class="line">COMMAND     PID           USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">systemd       1           root    0u   CHR                1,3      0t0 5342 /dev/null</span><br><span class="line">systemd       1           root    1u   CHR                1,3      0t0 5342 /dev/null</span><br><span class="line">systemd       1           root    2u   CHR                1,3      0t0 5342 /dev/null</span><br><span class="line">systemd       1           root   27r   CHR             10,235      0t0 7250 /dev/autofs</span><br><span class="line">systemd       1           root   30u  unix 0xffff8922436ce000      0t0 7645 /dev/<span class="built_in">log</span></span><br><span class="line">kdevtmpfs    13           root  cwd    DIR                0,5     3340    3 /dev</span><br><span class="line"><span class="comment"># 因为都在目录中，所以搜索目录即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 4：列出 root 的 bash 程序开启的文件</span></span><br><span class="line">[root@study ~]<span class="comment"># lsof -u root | grep bash</span></span><br><span class="line">ksmtuned    921 root  txt       REG              253,0    964600     309027 /usr/bin/bash</span><br><span class="line">bash      20030 root  cwd       DIR              253,0      4096   25165889 /root</span><br><span class="line">bash      20030 root  rtd       DIR              253,0       251         64 /</span><br><span class="line">bash      20030 root  txt       REG              253,0    964600     309027 /usr/bin/bash</span><br><span class="line">bash      20030 root  mem       REG              253,0 106075056     309022 /usr/lib/locale/locale-archive</span><br><span class="line">bash      20030 root  mem       REG              253,0     61624    8548289 /usr/lib64/libnss_files-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0   2156160    8532847 /usr/lib64/libc-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0     19288    8532853 /usr/lib64/libdl-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0    174576    8548350 /usr/lib64/libtinfo.so.5.9</span><br><span class="line">bash      20030 root  mem       REG              253,0    163400    8532840 /usr/lib64/ld-2.17.so</span><br><span class="line">bash      20030 root  mem       REG              253,0     26254   16946906 /usr/lib64/gconv/gconv-modules.cache</span><br><span class="line">bash      20030 root    0u      CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash      20030 root    1u      CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash      20030 root    2u      CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash      20030 root  255u      CHR              136,0       0t0          3 /dev/pts/0</span><br></pre></td></tr></table></figure>

<p>可以通过范例 4 找出某个进程是否有启用哪些信息</p>
<h3 id="pidof：找出某个正在运行的程序的-PID"><a href="#pidof：找出某个正在运行的程序的-PID" class="headerlink" title="pidof：找出某个正在运行的程序的 PID"></a>pidof：找出某个正在运行的程序的 PID</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pidof [-sx] program_name</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-s：仅列出一个 PID 而不列出所有的 PID</span><br><span class="line">	-x：同时列出该程序可能的 PPID 那个进程的 PID</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前系统上 systemd 以及 rsyslogd 这两个程序的 PID</span></span><br><span class="line">[root@study ~]<span class="comment"># pidof systemd rsyslogd</span></span><br><span class="line">1 1265</span><br><span class="line"><span class="comment"># 结果显示的是两个 PID</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>pidof</strong> 指令较简单，可配合 <strong>pas aux</strong> 与正则表示法，就可以很轻易的找到你想要的进程内容了。如果要找的是 <strong>bash</strong>，那就 <strong>pidof bash</strong> ，就列出一堆 <strong>PID</strong> 号码了</p>
<h2 id="SELinux-初探"><a href="#SELinux-初探" class="headerlink" title="SELinux 初探"></a>SELinux 初探</h2><p><strong>CentOS 5.x</strong> 之后，<strong>SELinux</strong> 已经是个非常完备的核心模块了，尤其是 <strong>CentOS</strong> 提供了很多管理 <strong>SELinux</strong> 的指令与机制，因此在整理架构上面是单纯且容易操作管理的，所以在没有自行开发网络服务软件以及使用其他第三方协力软件的情况下，也就是全部使用 <strong>CentOS</strong> 官方提供的软件来使用我们服务器的情况下，建议不要关闭 <strong>SELinux</strong></p>
<h3 id="什么是-SELinux"><a href="#什么是-SELinux" class="headerlink" title="什么是 SELinux"></a>什么是 SELinux</h3><p><strong>Security Enhanced Linux</strong> 的缩写 <strong>SELinux</strong>，字面意思是安全强化的 <strong>LInux</strong>。至于强化的是哪个部分？下面来了解下</p>
<h3 id="当初设计的目标：避免资源的误用"><a href="#当初设计的目标：避免资源的误用" class="headerlink" title="当初设计的目标：避免资源的误用"></a>当初设计的目标：避免资源的误用</h3><p><strong>SELinux</strong> 是由美国国家安全局（<strong>NSA</strong>）开发的，需求来源于内部员工资源误用导致系统出现问题；</p>
<p>资源误用：将一个 <code>/var/www/html/</code> 目录权限设置成 <strong>777</strong>，那么当启动 <strong>www</strong> 服务器软件，就意味着这个软件触发的进程拥有对该目录写入的权限，只要通过该进程服务器对目录大量写入，就会导致系统硬盘资源被爆破</p>
<p><strong>SELinux</strong> 是在进行进程、文件等西部权限设置依据的一个核心模块，由于启动网络服务的也是进程，因此刚好也能够控制网络服务是否能存取系统资源的一道关卡</p>
<p>在讲解 <strong>SELinux</strong> 之前，先回顾一下之前讲到的：系统文件权限与用户之间的关系</p>
<h3 id="传统的文件权限与账户关系：自主式访问控制-DAC"><a href="#传统的文件权限与账户关系：自主式访问控制-DAC" class="headerlink" title="传统的文件权限与账户关系：自主式访问控制 DAC"></a>传统的文件权限与账户关系：自主式访问控制 DAC</h3><p>第 <strong>13</strong> 章中讲到：系统账户主要分为系统管理员（<strong>root</strong>）与一般用户，他们能否使用系统上的文件资源与 <strong>rwx</strong> 权限设置有关。（各种权限设置对 <strong>root</strong> 无效）。当某个进程想要对文件进行存取时，系统会根据该进程的拥有者、群组，并比对文件的权限，若通过权限检查，就可以存取该文件</p>
<p>这种存取文件的方式被称为 <strong>自主式访问控制 Discretionary Access Controller 简称 DAC</strong>，基本上就是依据进程的拥有者与文件资源的 <strong>rwx</strong> 权限来决定有无存取的能力。<strong>DAC</strong> 有如下困扰：</p>
<ul>
<li><strong>root</strong> 具有最高的权限：只要取得属于 <strong>root</strong> 的进程，那么就很危险</li>
<li>使用者可以取得进程来变更文件资源的访问权限：如果将某个目录权限不小心设置为 <strong>777</strong>，由于对任何人的权限会变成 <strong>rwx</strong>，因此该目录就会被任何人所任意存取</li>
</ul>
<h3 id="以政策规则规定特定进程读取特定文件：委任式访问控制-MAC"><a href="#以政策规则规定特定进程读取特定文件：委任式访问控制-MAC" class="headerlink" title="以政策规则规定特定进程读取特定文件：委任式访问控制 MAC"></a>以政策规则规定特定进程读取特定文件：委任式访问控制 MAC</h3><p>为了避免 <strong>DAC</strong> 的困扰，<strong>SELinux</strong> 导入了委任式访问控制 <strong>Mandatory Access Control</strong> 简称 <strong>MAC</strong></p>
<p><strong>MAC</strong> 可以针对特定的进程与特定的文件资源来进行权限的控制。即使你是 <strong>root</strong>，那么在使用不同的进程时，你所能取得的权限并不一定是 <strong>root</strong>，而需要看当时该进程的设置。如此一来针对控制的「主体」变成了「进程」而不是使用者，但是真个系统进程很多、文件也很多，一项一项控制太麻烦，所以 <strong>SELinux</strong> 也提供一些预设的政策 <strong>Policy</strong> ，并在该政策内提供多个规则 <strong>rule</strong>，让你可以选择是否启用该控制规则</p>
<p>在该种模式下，进程能够活动的空变小了。比如：<strong>www</strong> 服务器软件达成进程为 <strong>httpd</strong> 这个程序，默认情况下， <strong>httpd</strong> 仅能在 <code>/var/www</code> 目录下存取文件，如果 httpd 进程要去其他目录存储数据时，除了规则设置要开放外，目标目录也要设置成 <strong>httpd</strong> 可读取的模式 <strong>type</strong> 才行，限制非常多，所以，即使 <strong>httpd</strong> 这个进程被黑客取得了控制权限，它也无权限浏览其他的目录文件</p>
<p>简单说，针对 <strong>Apache</strong> 这个 <strong>www</strong> 网络服务使用 <strong>DAC</strong> 或 <strong>MAC</strong> 的结果来说，两者的关系可用下图来说明</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/selinux.png"></p>
<p>传统的进程与文件的 <strong>rwx</strong> 方式，在这中间增加了 <strong>SELinux</strong>  安全性本文 <em>规则</em> ，通过了这些规则之后，才和传统的进程与文件的 <strong>rwx</strong> 方式一致。</p>
<p>笔者理解为是通过拦截器的方式，出台了 <strong>SELinux</strong> ，前面通过 <strong>SElinux</strong> 拦截细化权限，符合要求的再去到传统的方式，这样一来就对传统的加强了。</p>
<h3 id="安全性本文-Security-Context"><a href="#安全性本文-Security-Context" class="headerlink" title="安全性本文 Security Context"></a>安全性本文 Security Context</h3><p><strong>CentOS 7.x</strong> 的 <strong>target</strong> 政策提供了非常多的规则，只需要如何开启关闭某项规则即可。</p>
<p>安全性本文则非常麻烦，可能需要自行配置它，比如你常常设置文件的 <strong>rwx</strong> 权限，那么这个安全性本文就类似，可以看成是 <strong>SELinux</strong> 中的 <strong>rwx</strong></p>
<p>安全性本文存在于主体进程中与目标文件资源中，物理位置是放在文件的 <strong>inode</strong> 中，因此主体进程想要读取目标文件资源时，同样需要读取 <strong>inode</strong>，这就可以对比安全性本文一级 <strong>rwx</strong> 等权限是否正确了。</p>
<p>观察安全性本文可使用 <code>ls -Z</code> ，但是前提是需要启动 <strong>SELinux</strong> 才行，下个小节会介绍如何启动 <strong>SELinux</strong>，这里先介绍知识点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ls -Z</span></span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 accountadd.sh</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 accountadd.txt</span><br><span class="line">-rwxr--r--+ root root unconfined_u:object_r:admin_home_t:s0 acl_test1</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 addaccount2.sh</span><br><span class="line">-rw-------. root root system_u:object_r:admin_home_t:s0 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--. root root system_u:object_r:admin_home_t:s0 initial-setup-ks.cfg</span><br><span class="line"><span class="comment"># 上述字段很长的那一栏就是安全性本文了</span></span><br></pre></td></tr></table></figure>

<p>安全性本文主要用冒号分割为三个字段，含义如下：</p>
<ul>
<li><p><strong>identify</strong>：身份</p>
<p>相当于账户方面的身份识别，常见有几下几种类型</p>
<ul>
<li><p><strong>unconfined_u</strong>：不受限的用户</p>
<p>该文件来自不受限的进程所产生的，一般来说，可以使用可登录账号来取得 <strong>bash</strong>，预设的 <strong>bash</strong> 环境是不受 <strong>SELinux</strong> 管制的，因为 <strong>bash</strong> 并不是什么特别的网络服务，因此在该 <strong>bash</strong> 进程所产生的文件，其身份识别大多就是该类型了</p>
</li>
<li><p><strong>system_u</strong>：系统用户</p>
<p>基本上，如果是系统会软件本身所提供的文件，大多就是该类型，如果是用户通过 <strong>bash</strong> 自己建立的文件，大多则是不受限的 <strong>unconfined_u</strong> 身份，如果是网络服务所产生的文件，或则是系统服务运行过程中所产生的文件，则大部分是 <strong>system_u</strong></p>
</li>
</ul>
</li>
<li><p><strong>role</strong>：角色</p>
<p>通过该字段，可以知道这个资料是属于进程、文件资源还是代表使用者，一般的角色有：</p>
<ul>
<li><strong>object_r</strong>：代表的是文件或目录等文件资源</li>
<li><strong>system_r</strong>：代表的是进程，不过一般使用者也会被指定为 system_r</li>
</ul>
</li>
<li><p><strong>type</strong>：类型，最重要</p>
<p>在预设的 <strong>targeted</strong> 政策中， <strong>identify</strong> 与 <strong>role</strong> 字段基本上是不重要的，而 <strong>type</strong> 是最重要的，基本上，一个主体进程能不能读取到这个文件资源，与类型字段有关，而类型字段在文件与进程的定义不相同：</p>
<ul>
<li><strong>type</strong>：在文件资源（<strong>object</strong>）上面称为类型（<strong>type</strong>）</li>
<li><strong>domain</strong>：在主体进程（<strong>subject</strong>）则称为领域（<strong>domain</strong>）</li>
</ul>
<p><strong>domain</strong> 需要与 <strong>type</strong> 搭配，则该进程才能够顺利的读取文件资源</p>
</li>
</ul>
<h3 id="进程与文件-SELinux-type-字段的相关性"><a href="#进程与文件-SELinux-type-字段的相关性" class="headerlink" title="进程与文件 SELinux type 字段的相关性"></a>进程与文件 SELinux type 字段的相关性</h3><p>通过身份识别与角色字段的定义，我们可以大概某个进程所代表的意义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察下系统 进程的 SELinux 相关信息</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -eZ</span></span><br><span class="line">LABEL                             PID TTY          TIME CMD</span><br><span class="line">system_u:system_r:init_t:s0         1 ?        00:00:01 systemd</span><br><span class="line">system_u:system_r:kernel_t:s0       2 ?        00:00:00 kthreadd</span><br><span class="line">system_u:system_r:kernel_t:s0       4 ?        00:00:00 kworker/0:0H</span><br><span class="line">system_u:system_r:kernel_t:s0       5 ?        00:00:00 kworker/u2:0</span><br><span class="line">...</span><br><span class="line">system_u:system_r:sshd_t:s0-s0:c0.c1023 2344 ? 00:00:00 sshd</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2350 ? 00:00:00 sshd</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2353 pts/0 00:00:00 bash</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2415 pts/0 00:00:00 su</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2424 pts/0 00:00:00 bash</span><br><span class="line">system_u:system_r:kernel_t:s0    2726 ?        00:00:00 kworker/u2:2</span><br><span class="line">system_u:system_r:kernel_t:s0    2778 ?        00:00:00 kworker/0:1</span><br><span class="line">system_u:system_r:kernel_t:s0    2836 ?        00:00:00 kworker/0:3</span><br><span class="line">system_u:system_r:kernel_t:s0    2877 ?        00:00:00 kworker/0:0</span><br><span class="line">system_u:system_r:ksmtuned_t:s0  2885 ?        00:00:00 sleep</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2886 pts/0 00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本上进程主要分为两大类，</span></span><br><span class="line"><span class="comment"># 一种是系统有受限的 system_u:system_r，</span></span><br><span class="line"><span class="comment"># 另一种可能是用户自己的，比较不受限的进程（通常是本机用户自己执行的程序 ） unconfined_u:unconfined_r</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2424 pts/0 00:00:00 bash</span></span><br><span class="line"><span class="comment"># 比如上面这个进程，就是我们自己执行命令所在的 bash</span></span><br></pre></td></tr></table></figure>

<p>基本上，这些对于资料在 <strong>targeted</strong> 政策下的对应对下</p>
<table>
<thead>
<tr>
<th>身份识别</th>
<th>角色</th>
<th>对应在 targeted 的意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>unconfined_u</strong></td>
<td><strong>unconfined_r</strong></td>
<td>一般可登陆使用者的进程，比较没有受限的进程。大多数都是用户已经顺利登陆系统（不论是网络还是本机登陆来取得可用的 <strong>shell</strong>）后，所用来操作系统的进程，如 <strong>bash x window</strong> 相关富安居等</td>
</tr>
<tr>
<td><strong>system_u</strong></td>
<td><strong>system_r</strong></td>
<td>由于为系统账户，因此是非交谈式的系统运行进程，大多数的系统进程均是这种类型</td>
</tr>
</tbody></table>
<p>如上所述，在预设的 <strong>target</strong> 政策下，最重要的是 <strong>type</strong> 字段，主体与目标之间是否具有可读写的权限，与进程的 <strong>domain</strong> 与文件的 <strong>type</strong> 有关。这两者的关系可以使用 <strong>crond</strong> 以及他的配置文件来说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先看看 crond 这个进程的安全本文内容</span></span><br><span class="line">[root@study ~]<span class="comment"># ps -eZ | grep cron</span></span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 1398 ? 00:00:00 atd</span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 1400 ? 00:00:00 crond</span><br><span class="line"><span class="comment"># 这个安全本文的类型名称为 crond_t 格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 看看 /usr/ssbin/crond 、 /etc/cron.d、/etc/cron.d 文件的安全本文内容</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Zd /usr/sbin/crond /etc/crontab /etc/cron.d</span></span><br><span class="line">drwxr-xr-x. root root system_u:object_r:system_cron_spool_t:s0 /etc/cron.d</span><br><span class="line">-rw-r--r--. root root system_u:object_r:system_cron_spool_t:s0 /etc/crontab</span><br><span class="line">-rwxr-xr-x. root root system_u:object_r:crond_exec_t:s0 /usr/sbin/crond</span><br></pre></td></tr></table></figure>

<p>执行 <code>/usr/ssbin/crond</code> 后，该程序编程的进程 <strong>domain</strong> 类似是 <strong>crond_t</strong>，它能够读取的配置文件是 <code>system_cron_spool_t</code> 类型。因此无论 <code>/etc/crontab</code>与 <code>/etc/cron.d</code> 以及 <code>/var/spool/cron</code> 都会是相关的 SELinux 类型（<code>/var/spool/cron</code> 为 <code>user_cron_spool_t</code> 类型）。下面图示说明</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/crond-domain.png" style="zoom:67%;" />

<ol>
<li><strong>crond</strong> 执行后，具有 <strong>crond_exec_t</strong> 类型</li>
<li>该文件类型会造成主体进程 <strong>Subject</strong> 具有 <strong>crond</strong> 这个领域 <strong>domain</strong>，政策针对这个领域有许多规则，其中就包括可以读取的目标资源类型</li>
<li>由于 <strong>crond domain</strong> 被设置为可以读取 <strong>system_cron_spool_t</strong> 类型的目标文件 <strong>object</strong>，因此你的配置文件放到 <code>/etc/cron.d/</code> 目录下，就能够被 <strong>crond</strong> 进程读取了</li>
<li>但是最终能不能读到正确的资料，还需要看传统的 <strong>rwx</strong> 是否符合 <strong>Linux</strong> 的权限规范</li>
</ol>
<p>下面来测试上述说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 假设你因为不熟悉的缘故，因此是在 root 家目录建立一个如下的 cron 设置</span></span><br><span class="line">[root@study ~]<span class="comment"># vim checktime</span></span><br><span class="line">10 * * * * root sleep 60s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 发现文件放错目录了，又不想要保留副本，因此使用 mv 移动到正确的目录</span></span><br><span class="line">[root@study ~]<span class="comment"># mv checktime /etc/cron.d/</span></span><br><span class="line">[root@study ~]<span class="comment"># ll /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. 1 root root 26 Mar 17 13:12 /etc/cron.d/checktime</span><br><span class="line"><span class="comment"># 权限是 644，任何进程都可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 强制重新启动 crond，然后查看登录日志</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart crond          </span></span><br><span class="line">[root@study ~]<span class="comment"># tail /var/log/cron</span></span><br><span class="line">Mar 17 13:01:01 study run-parts(/etc/cron.hourly)[3889]: finished mcelog.cron</span><br><span class="line">Mar 17 13:10:01 study CROND[3972]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">Mar 17 13:14:01 study crond[1400]: ((null)) Unauthorized SELinux context=system_u:system_r:system_cronjob_t:s0-s0:c0.c1023 file_context=unconfined_u:object_r:admin_home_t:s0 (/etc/cron.d/checktime)</span><br><span class="line">Mar 17 13:14:01 study crond[1400]: (root) FAILED (loading cron table)</span><br><span class="line">Mar 17 13:15:08 study crond[1400]: (CRON) INFO (Shutting down)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 13% <span class="keyword">if</span> used.)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: ((null)) Unauthorized SELinux context=system_u:system_r:system_cronjob_t:s0-s0:c0.c1023 file_context=unconfined_u:object_r:admin_home_t:s0 (/etc/cron.d/checktime)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (root) FAILED (loading cron table)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (CRON) INFO (running with inotify support)</span><br><span class="line">Mar 17 13:15:08 study crond[4073]: (CRON) INFO (@reboot <span class="built_in">jobs</span> will be run at computer<span class="string">&#x27;s startup.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 上述日志中有 Unauthorized 的信息，表示有错误，因为原本的安全本文与文件的实际安全本文无法搭配的缘故，</span></span><br><span class="line"><span class="string"># 信息还列出了 SELinux context 与 file_context 的信息，表示的确不匹配</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="SELinux-三种模式的启动、关闭与观察"><a href="#SELinux-三种模式的启动、关闭与观察" class="headerlink" title="SELinux 三种模式的启动、关闭与观察"></a>SELinux 三种模式的启动、关闭与观察</h3><p>并非所有的 <strong>Linux distribution</strong> 都支持 <strong>SELinux</strong>，<strong>CentOS 7.x</strong> 本身就有支持 <strong>SELinux</strong>，所以你不需要自行编译 <strong>SELinux</strong> 到你的 <strong>Linux</strong> 核心中。目前 <strong>SELinux</strong> 是否启动有三种模式：</p>
<ul>
<li><strong>enforcing</strong>：强制模式，表示 <strong>SELinux</strong> 运行中，且已经正确的开始限制 <strong>domain/type</strong> 了</li>
<li><strong>permissive</strong>：宽容模式，表示 <strong>SELinux</strong> 运行中，不过仅有警告进行并不会实际限制 <strong>domain/type</strong> 的存取。这种模式可以用来 <strong>debug SELinux</strong> 的配置</li>
<li><strong>disabled：SELinux</strong> 关闭中</li>
</ul>
<p>三种模式的示意图如下：</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/2024/linux/selinux-three-pattern.png" style="zoom:50%;" />

<p>注意：并非有所的进程都受 <strong>SELinux</strong> 的管控，注意是有 <strong>受限的进程主体</strong>，可以通过 <code>ps -eZ</code> 来观察该进程是否有受限（<strong>confined</strong>）。下面来观察 <strong>crond</strong> 与 <strong>bash</strong> 程序是否有被限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># ps -eZ | grep -E &#x27;cron|bash&#x27;</span></span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 1398 ? 00:00:00 atd</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2353 pts/0 00:00:00 bash</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 2424 pts/0 00:00:00 bash</span><br><span class="line">system_u:system_r:crond_t:s0-s0:c0.c1023 4073 ? 00:00:00 crond</span><br></pre></td></tr></table></figure>

<p>因为目前 <strong>target</strong> 这个政策下，只有第 <strong>3</strong> 个字段 <strong>type</strong> 会有影响，因此可以看到 <strong>crond</strong> 有 <code>crond_t</code> 类型，是受限的，而 <strong>bash</strong> 是 <code>unconfined_t</code> 类型，是不受限的，也就是说 <strong>bash</strong> 不会经过上图的流程，而直接去判定 <strong>rwx</strong></p>
<p>可以通过以下方式获取当前的 <strong>SELinux</strong> 模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># getenforce </span></span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>

<p>查询当前 <strong>SELinux</strong> 的政策（<strong>Policy</strong>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sestatus [-vb]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-v：检查 /etc/sestatus.conf 内的文件与进程的安全性本文内容</span><br><span class="line">	-b：将目前政策的规则布尔值列出，即某些规则 rule 是否要启动（0/1）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出目前 SELinux 使用的哪个政策 Policy</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sestatus   		</span></span><br><span class="line">SELinux status:                 enabled				<span class="comment"># SELinux 是否启动</span></span><br><span class="line">SELinuxfs mount:                /sys/fs/selinux		<span class="comment"># SELinux 的相关文件数据挂载点</span></span><br><span class="line">SELinux root directory:         /etc/selinux		<span class="comment"># SELinux 的根目录所在</span></span><br><span class="line">Loaded policy name:             targeted			<span class="comment"># 当前的政策</span></span><br><span class="line">Current mode:                   enforcing			<span class="comment"># 当前模式</span></span><br><span class="line">Mode from config file:          enforcing			<span class="comment"># 目前配置文件内规范的 SELinux 模式</span></span><br><span class="line">Policy MLS status:              enabled				<span class="comment"># 是否含有 MLS 的模式机制</span></span><br><span class="line">Policy deny_unknown status:     allowed				<span class="comment"># 是否预设抵挡未知的主体进程</span></span><br><span class="line">Max kernel policy version:      31</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述信息科知道，<strong>SELinux</strong> 目前的政策是 <strong>targeted</strong> ，可通过如下方式修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># vim /etc/selinux/config </span></span><br><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=enforcing		 	<span class="comment"># 可选择为上述 3 个</span></span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of three values:</span></span><br><span class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected. </span></span><br><span class="line"><span class="comment">#     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted		<span class="comment"># 可选值为上述 3 个</span></span><br></pre></td></tr></table></figure>

<h3 id="SElinux-的启动与关闭"><a href="#SElinux-的启动与关闭" class="headerlink" title="SElinux 的启动与关闭"></a>SElinux 的启动与关闭</h3><p>由于 <strong>SElinux</strong> 是整合到核心中去的，因此修改上述配置文件之后，需要重新启动。</p>
<p>注意：如果从 <strong>disable</strong> 转到启动 <strong>SELinux</strong> 的模式时，由于系统必须要针对文件写入安全性本文信息，因此开机过程需要耗费不少时间等待重新写入 <strong>SELinux</strong> 安全性本文（有时也称为<strong>SELinux Label</strong>），而且在写完之后还需要重新启动一次，启动成功之后，再使用 <code>getenforce 和 sestatus</code> 来观察是否有成功启动到 <strong>Enforcing</strong> 模式</p>
<p>如果当前已经是 <strong>Enforcing</strong> 模式，可能由于一些设置问题大道至 <strong>SELinux</strong> 让某些服务无法正常的运行，此时可将模式修改为宽容模式（<strong>permissive</strong>），让 <strong>SELinux</strong> 只发出警告信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenforce [0|1]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	0：转成 permissive 宽容模式</span><br><span class="line">	1：转成 Enforcing 强制模式</span><br><span class="line">注意：无法在 Disabled 模式下进程模式的切换	</span><br></pre></td></tr></table></figure>

<p>某些时候从 <strong>Disabled</strong> 换成 <strong>Enforcing</strong> 之后，有部分服务可能无法顺利启动，可能会报错 <code>/lib/xxx</code> 数据没有权限读取的错误信息。这大多数是由于重新写入 <strong>Selinux type</strong>（<strong>Relabel</strong>）出错的原因，使用 <strong>Permissive</strong> 模式就没有该错误。最简单的办法是在 <strong>Permissive</strong> 模式下使用指令 <code>restorecon -Rv /</code> 重新还原所有 <strong>SELinux</strong> 的类型。</p>
<h3 id="SELinux-政策内的规则管理"><a href="#SELinux-政策内的规则管理" class="headerlink" title="SELinux 政策内的规则管理"></a>SELinux 政策内的规则管理</h3><h4 id="SELinux-各个规则的布尔值查询：getsebool"><a href="#SELinux-各个规则的布尔值查询：getsebool" class="headerlink" title="SELinux 各个规则的布尔值查询：getsebool"></a>SELinux 各个规则的布尔值查询：getsebool</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getsebool [-a] [规则名称]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：列出目前系统上所有 SELinux 规则的布尔值为开启或关闭（on/off）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询所有的布尔值设置</span></span><br><span class="line">[root@study ~]<span class="comment"># getsebool -a</span></span><br><span class="line">abrt_anon_write --&gt; off</span><br><span class="line">abrt_handle_event --&gt; off</span><br><span class="line">abrt_upload_watch_anon_write --&gt; on</span><br><span class="line">...</span><br><span class="line">cron_can_relabel --&gt; off		<span class="comment"># 这个与 cron 有关</span></span><br><span class="line">cron_system_cronjob_use_shares --&gt; off</span><br><span class="line">cron_userdomain_transition --&gt; on</span><br><span class="line">...</span><br><span class="line">httpd_anon_write --&gt; off		<span class="comment"># 与网页 http 有关</span></span><br><span class="line">httpd_builtin_scripting --&gt; on</span><br><span class="line">httpd_can_check_spam --&gt; off</span><br><span class="line"><span class="comment"># 每一行都是一个规则</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SELinux-各个规则规范的主体进程能够读取的文件-SELinux-type-查询-seinfo、sesearch"><a href="#SELinux-各个规则规范的主体进程能够读取的文件-SELinux-type-查询-seinfo、sesearch" class="headerlink" title="SELinux 各个规则规范的主体进程能够读取的文件 SELinux type 查询 seinfo、sesearch"></a>SELinux 各个规则规范的主体进程能够读取的文件 SELinux type 查询 seinfo、sesearch</h4><p>上述指令知道了所有的规则开启情况，可以通过 <strong>seinfo</strong>、<strong>sesearch</strong> 等工具来查看每个规则具体在限制什么。</p>
<p>上述工具并未预装，<a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/07/03.html#%E6%8C%82%E8%BD%BD-cd-%E6%88%96-dvd-%E5%85%89%E7%9B%98">请拿出安装光盘挂载到 /mnt 目录下</a>，安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># blkid </span></span><br><span class="line">/dev/sr0: UUID=<span class="string">&quot;2019-09-11-18-50-31-00&quot;</span> LABEL=<span class="string">&quot;CentOS 7 x86_64&quot;</span> TYPE=<span class="string">&quot;iso9660&quot;</span> PTTYPE=<span class="string">&quot;dos&quot;</span> </span><br><span class="line">/dev/sda1: UUID=<span class="string">&quot;e9d54afb-2afe-42de-87fe-9f55d747fcd9&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> </span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;CNUXwS-J3Lh-0nDA-TssW-l1vT-90us-MHYnT1&quot;</span> TYPE=<span class="string">&quot;LVM2_member&quot;</span> </span><br><span class="line">/dev/mapper/centos_study-root: UUID=<span class="string">&quot;d7e09bb4-2f04-4ed4-b377-91a22fe85ce7&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> </span><br><span class="line">/dev/mapper/centos_study-swap: UUID=<span class="string">&quot;684eebc0-3f70-4fc1-9a5d-d683f6a07cd0&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span> </span><br><span class="line">[root@study ~]<span class="comment"># mount /dev/sr0 /mnt/</span></span><br><span class="line">mount: /dev/sr0 is write-protected, mounting read-only</span><br><span class="line">[root@study ~]<span class="comment"># yum install /mnt/Packages/setools-console-*                               </span></span><br><span class="line">...</span><br><span class="line">Complete!</span><br><span class="line">[root@study ~]<span class="comment"># umount /mnt/  # 卸载光盘</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seinfo [-Atrub]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：列出 SELinux 的状态、规则布尔值、身份识别、角色、类型等所有信息</span><br><span class="line">	-u：列出 SELinux 的所有身份识别 user 种类</span><br><span class="line">	-r：列出 SELinux 的所有角色 role 种类</span><br><span class="line">	-t：列出 SELinux 的所有类型 <span class="built_in">type</span> 种类</span><br><span class="line">	-b：列出所有规则的种类（布尔值）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：列出 SELinux 在此政策下的统计状态</span></span><br><span class="line">[root@study ~]<span class="comment"># seinfo </span></span><br><span class="line"></span><br><span class="line">Statistics <span class="keyword">for</span> policy file: /sys/fs/selinux/policy</span><br><span class="line">Policy Version &amp; Type: v.31 (binary, mls)</span><br><span class="line"></span><br><span class="line">   Classes:           130    Permissions:       272</span><br><span class="line">   Sensitivities:       1    Categories:       1024</span><br><span class="line">   Types:            4792    Attributes:        253</span><br><span class="line">   Users:               8    Roles:              14</span><br><span class="line">   Booleans:          316    Cond. Expr.:       362</span><br><span class="line">   Allow:          107360    Neverallow:          0</span><br><span class="line">   Auditallow:        157    Dontaudit:       10020</span><br><span class="line">   Type_trans:      18129    Type_change:        74</span><br><span class="line">   Type_member:        35    Role allow:         39</span><br><span class="line">   Role_trans:        416    Range_trans:      5899</span><br><span class="line">   Constraints:       143    Validatetrans:       0</span><br><span class="line">   Initial SIDs:       27    Fs_use:             32</span><br><span class="line">   Genfscon:          103    Portcon:           614</span><br><span class="line">   Netifcon:            0    Nodecon:             0</span><br><span class="line">   Permissives:         0    Polcap:              5</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 当前政策是 targeted ？ （哪里显示的？），此政策下的 Types 类型有 4792 个</span></span><br><span class="line"><span class="comment"># SELinux 的规则（Booleans）有 316 条</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在前面讲到过几个身份识别 <strong>user</strong> 与 角色 <strong>role</strong>，<strong>seinfo</strong> 可以查询到所有的种类，可自行查询</p>
<p>在前面讲到 <code>/etc/cron.d/checktime</code> 的 <strong>SElinux type</strong> 类型不太对，我们知道 <strong>crond</strong> 进程的 <strong>type</strong> 是 <code>crond_t</code>，那么查找下 <code>crond_t</code> 能够读取的文件 <strong>SELinux type</strong> 有哪些</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sesearch [-A] [-s 主体类别] [-t 目标类别] [-b 布尔值]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：列出后面数据中，允许「读取或放行」的相关数据</span><br><span class="line">	-t：后面还要接 <span class="built_in">type</span>、例如 -t httpd_t</span><br><span class="line">	-b：后面接 SELinux 的规则，例如 -b httpd_enable_ftp_server</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：找出 crond_t 主体进程能够读取的文件 SELinux type</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sesearch -A -s crond_t | grep spool</span></span><br><span class="line">   allow crond_t var_spool_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow crond_t system_cron_spool_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow crond_t system_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow crond_t var_spool_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow crond_t cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow daemon user_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write getattr lock append &#125; ; </span><br><span class="line">   allow crond_t cron_spool_t : dir &#123; ioctl <span class="built_in">read</span> write getattr lock add_name remove_name search open &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : dir &#123; ioctl <span class="built_in">read</span> write getattr lock add_name remove_name search open &#125; ; </span><br><span class="line">   allow crond_t user_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ; </span><br><span class="line">   allow crond_t system_cron_spool_t : file &#123; ioctl <span class="built_in">read</span> write create getattr setattr lock append unlink link rename open &#125; ;</span><br><span class="line">   </span><br><span class="line"><span class="comment"># allow 后面是主体进程以及文件的 SELinux type，上面数据是截取出来的</span></span><br><span class="line"><span class="comment"># crond_t 可以读取 system_cron_spool_t 的文件/目录类型等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：找出 crond_t 是否能读取 /etc/cron.d/checktime 这个我们自定义的配置文件？</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 /etc/cron.d/checktime</span><br><span class="line"><span class="comment"># 两个重点：SELinux type 为 admin_home_t，一个是文件（file）</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sesearch -A -s crond_t | grep admin_home_t</span></span><br><span class="line">   allow domain admin_home_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow crond_t admin_home_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow userdom_filetrans_type admin_home_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow userdom_filetrans_type admin_home_t : dir &#123; ioctl <span class="built_in">read</span> write getattr lock add_name remove_name search open &#125; ; </span><br><span class="line">   allow domain admin_home_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow crond_t admin_home_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ;</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 发现有 crond_t admin_home_t 存在，不过这个是总体的信息</span></span><br><span class="line"><span class="comment"># 没有针对某些规则的查询，所以不能确定 checktime 能否被读取，但是基本上就是 SELinux type 出现问题，才无法读取的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在知道了 <code>/etc/cron.d/checktime</code> 是 <strong>SELinux type</strong> 错误导致无法读取的。看来在 <code>getsebool -a</code> 中看到的 <code>httpd_enable_homedirs</code> 是什么？又是规范了哪些主体进程能够读取的 <strong>SELinux type</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># semanage boolean -l | grep httpd_enable_homedirs</span></span><br><span class="line">httpd_enable_homedirs          (off  ,  off)  Allow httpd to <span class="built_in">enable</span> homedirs</span><br><span class="line"><span class="comment"># httpd_enable_homedirs 的功能是允许 httpd 进程读取用户家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 3：列出该规则中，主体进程能够读取的文件  SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># sesearch -A -b httpd_enable_homedirs</span></span><br><span class="line">Found 77 semantic av rules:</span><br><span class="line">   allow httpd_t user_home_type : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_suexec_t user_home_type : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_suexec_t user_home_dir_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_t nfs_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t cifs_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_user_script_t user_home_type : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ; </span><br><span class="line">   allow httpd_user_script_t user_home_type : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_t cifs_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t nfs_t : dir &#123; ioctl <span class="built_in">read</span> getattr lock search open &#125; ; </span><br><span class="line">   allow httpd_t user_home_dir_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t cifs_t : file &#123; ioctl <span class="built_in">read</span> getattr lock open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t user_home_dir_t : dir &#123; getattr search open &#125; ; </span><br><span class="line">   allow httpd_sys_script_t user_home_dir_t : lnk_file &#123; <span class="built_in">read</span> getattr &#125; ;</span><br><span class="line">   xxx</span><br><span class="line"> <span class="comment"># 从上面的数据才可以理解，主要是放行 httpd_t 能否读取用户家目录的文件 （笔者这里是懵逼的没有看出来）</span></span><br><span class="line"> <span class="comment"># 所以，如果该规则没有启动，基本上 httpd_t 这种进程就无法读取用户家目录下的文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="修改-SELinux-规则的布尔值-setsebool"><a href="#修改-SELinux-规则的布尔值-setsebool" class="headerlink" title="修改 SELinux 规则的布尔值 setsebool"></a>修改 SELinux 规则的布尔值 setsebool</h4><p>查询到某个 <strong>SELinux rule</strong> ，并且以 <strong>seaserch</strong> 知道该规则的用途后，可以通过下面的方式来管理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setsebool [-p] [规则名称][0|1]</span><br><span class="line"></span><br><span class="line">-P：直接将设置值写入配置文件，该设置数据未来会生效</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询 httpd_enable_homedirs 这个规则的状态，并且修改这个规则为不同的布尔值</span></span><br><span class="line">[root@study ~]<span class="comment"># getsebool httpd_enable_homedirs</span></span><br><span class="line">httpd_enable_homedirs --&gt; off			<span class="comment"># 关闭状态</span></span><br><span class="line">[root@study ~]<span class="comment"># setsebool -P httpd_enable_homedirs 1		# 开启它</span></span><br><span class="line">[root@study ~]<span class="comment"># getsebool httpd_enable_homedirs</span></span><br><span class="line">httpd_enable_homedirs --&gt; on</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SELinux-安全本文的修改"><a href="#SELinux-安全本文的修改" class="headerlink" title="SELinux 安全本文的修改"></a>SELinux 安全本文的修改</h3><p><strong>SELinux</strong> 对受限的主体进程没有影响：</p>
<ol>
<li>考虑 <strong>SELinux</strong> 的三种类型</li>
<li>考虑 <strong>SELinux</strong>的政策规则是否放行</li>
<li>比对 <strong>SELinux type</strong> 关系</li>
</ol>
<p>上面讲解过可以通过 <strong>sesearch</strong> 来找到主体进程与文件的 <strong>SELinux type</strong> 关系，那么怎么修改文件的 <strong>SELinux type</strong>，能让主体进程读到呢？</p>
<h4 id="使用-chcon-手动修改文件的-SELinux-type"><a href="#使用-chcon-手动修改文件的-SELinux-type" class="headerlink" title="使用 chcon 手动修改文件的 SELinux type"></a><strong>使用 chcon 手动修改文件的 SELinux type</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chcon [-R] [-t <span class="built_in">type</span>] [-u user] [-r role] 文件</span><br><span class="line">chcon [-R] --reference=范例文件 文件</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-R：连同该目录下的次目录也同时修改</span><br><span class="line">	-t：后面接安全性本文的类型字段，例如 httpd_sys_content_t</span><br><span class="line">	-u：后面接身份识别，例如 system_u (不重要)</span><br><span class="line">	-r：后面接角色，例如 system_r （不重要）</span><br><span class="line">	-v：若有变化成功，将变动的结果列出来</span><br><span class="line">	--reference=文件：拿某个文件档范例来修改后续接的文件的类型</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询 /etc/hosts 的 SELinux type，并将该类型套用到 /etc/cron.d/checktime 上</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/hosts</span></span><br><span class="line">-rw-r--r--. root root system_u:object_r:net_conf_t:s0  /etc/hosts</span><br><span class="line"><span class="comment"># net_conf_t 是上面文件中的类型</span></span><br><span class="line">[root@study ~]<span class="comment"># chcon -v -t net_conf_t /etc/cron.d/checktime </span></span><br><span class="line">changing security context of <span class="string">&#x27;/etc/cron.d/checktime&#x27;</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:net_conf_t:s0 /etc/cron.d/checktime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 2：直接以 /etc/shadow 的 type 套用</span></span><br><span class="line">[root@study ~]<span class="comment"># chcon -v --reference=/etc/shadow /etc/cron.d/checktime</span></span><br><span class="line">changing security context of <span class="string">&#x27;/etc/cron.d/checktime&#x27;</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -Z /etc/shadow /etc/cron.d/checktime </span></span><br><span class="line">-rw-r--r--. root root system_u:object_r:shadow_t:s0    /etc/cron.d/checktime</span><br><span class="line">----------. root root system_u:object_r:shadow_t:s0    /etc/shadow</span><br></pre></td></tr></table></figure>

<p>上面的示例并不能解决 <strong>crond</strong> 不能读取 <code>/etc/cron.d/checktime</code> 的问题，因为需要改成 <code>/etc/cron.d</code> 下的标准 <strong>type</strong> 才行。可以使用 <strong>restorecon</strong> 来让 <strong>SELinux</strong> 自己默认解决目录下的 <strong>type</strong> 问题</p>
<h4 id="使用-restorecon-让文件恢复正确的-SELinux-type"><a href="#使用-restorecon-让文件恢复正确的-SELinux-type" class="headerlink" title="使用 restorecon 让文件恢复正确的 SELinux type"></a>使用 restorecon 让文件恢复正确的 SELinux type</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">restorecon [-Rv] 文件或目录</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-R：连同次目录一起修改</span><br><span class="line">	-v：将过程显示到屏幕上</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 3：将 /etc/cron.d/ 下的文件都恢复成预设的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /etc/cron.d/</span></span><br><span class="line">restorecon reset /etc/cron.d/checktime context system_u:object_r:shadow_t:s0-&gt;system_u:object_r:system_cron_spool_t:s0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面将  shadow_t 改成了 system_cron_spool_t 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例 4：重新启动 crond 看看有没有正确启动 checktime</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart crond          </span></span><br><span class="line">[root@study ~]<span class="comment"># tail /var/log/cron</span></span><br><span class="line">Mar 17 16:01:01 study CROND[5886]: (root) CMD (run-parts /etc/cron.hourly)</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5886]: starting 0anacron</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5898]: finished 0anacron</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5886]: starting mcelog.cron</span><br><span class="line">Mar 17 16:01:01 study run-parts(/etc/cron.hourly)[5904]: finished mcelog.cron</span><br><span class="line">Mar 17 16:10:01 study CROND[5989]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">Mar 17 16:12:48 study crond[4073]: (CRON) INFO (Shutting down)</span><br><span class="line">Mar 17 16:12:48 study crond[6068]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 62% <span class="keyword">if</span> used.)</span><br><span class="line">Mar 17 16:12:49 study crond[6068]: (CRON) INFO (running with inotify support)</span><br><span class="line">Mar 17 16:12:49 study crond[6068]: (CRON) INFO (@reboot <span class="built_in">jobs</span> will be run at computer<span class="string">&#x27;s startup.)</span></span><br><span class="line"><span class="string"># 没有报错信息</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>从这里看来 <strong>restorecon</strong> 很方便，<strong>chcon</strong> 还是比较麻烦的</p>
<h4 id="semanage-默认目录的安全性本文查询与修改"><a href="#semanage-默认目录的安全性本文查询与修改" class="headerlink" title="semanage 默认目录的安全性本文查询与修改"></a>semanage 默认目录的安全性本文查询与修改</h4><p>为什么 <strong>restorecon</strong> 可以恢复原本的 <strong>SELinux type</strong> 呢？那一定是有个地方在记录每个文件/目录的 <strong>SELinux</strong> 默认类型</p>
<ol>
<li>如何查询预设的 <strong>SELinux type</strong></li>
<li>如何增加、修改、删除 预设的 <strong>SELinux type</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semanage &#123;login|user|port|interface|fcontext|translation&#125; -l</span><br><span class="line">semanage fcontext -&#123;a|d|m&#125; [-frst] file_spec</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	fcontext：主要用在安全性本文方面的用途， -l 为查询</span><br><span class="line">	-a：增加；可以增加一些目录的默认安全性本文类型设置</span><br><span class="line">	-m：修改</span><br><span class="line">	-d：删除</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例 1：查询 /etc/   /etc/cron.d/ 的预设 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -l | grep -E &#x27;^/etc |^/etc/cron&#x27;</span></span><br><span class="line">/etc/cron.daily(/.*)?                              all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.weekly(/.*)?                             all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.hourly(/.*)?                             all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.monthly(/.*)?                            all files          system_u:object_r:bin_t:s0 </span><br><span class="line">/etc/cron.minutely/openshift-facts                 regular file       system_u:object_r:openshift_cron_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|monthly)/acct                    regular file       system_u:object_r:acct_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/sysklogd                 regular file       system_u:object_r:logrotate_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|monthly)/mailman                 regular file       system_u:object_r:mailman_queue_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/man-db.*                 regular file       system_u:object_r:mandb_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|monthly)/radiusd                 regular file       system_u:object_r:radiusd_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/ntp-simple               regular file       system_u:object_r:ntpd_exec_t:s0 </span><br><span class="line">/etc/cron\.(daily|weekly)/ntp-server               regular file       system_u:object_r:ntpd_exec_t:s0 </span><br><span class="line">/etc/cron\.((daily)|(weekly)|(monthly))/freeradius regular file       system_u:object_r:radiusd_exec_t:s0 </span><br><span class="line">/etc/cron\.d(/.*)?                                 all files          system_u:object_r:system_cron_spool_t:s0 </span><br><span class="line">/etc/cron\.daily/[sm]locate                        regular file       system_u:object_r:locate_exec_t:s0 </span><br><span class="line">/etc/cron\.weekly/(c)?fingerd                      regular file       system_u:object_r:fingerd_exec_t:s0 </span><br><span class="line">/etc                                               all files          system_u:object_r:etc_t:s0 </span><br><span class="line">/etc/crontab                                       regular file       system_u:object_r:system_cron_spool_t:s0 </span><br><span class="line">/etc/cron\.daily/prelink                           regular file       system_u:object_r:prelink_cron_system_exec_t:s0 </span><br><span class="line">/etc/cron\.daily/calamaris                         regular file       system_u:object_r:calamaris_exec_t:s0 </span><br><span class="line">/etc/cron\.daily/certwatch                         regular file       system_u:object_r:certwatch_exec_t:s0 </span><br><span class="line">/etc/cron\.monthly/proftpd                         regular file       system_u:object_r:ftpd_exec_t:s0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看 <code>/etc/cron\.d(/.*)? all files system_u:object_r:system_cron_spool_t:s0</code> 这一行，这也是为什么直接使用 vim 在 <code>/etc/cron.d</code> 下新建文件时，预设 SELinux type 是正确的。</p>
<p>练习：下面要建立一个 <code>/srv/mycron</code> 目录，默认也是需要变成 <code>system_cron_spool_t</code> 时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先建立 mycron 目录，再放入配置文件，观察 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># mkdir /srv/mycron</span></span><br><span class="line">[root@study ~]<span class="comment"># cp /etc/cron.d/checktime /srv/mycron/</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -dZ /srv/mycron/ /srv/mycron/checktime </span></span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:var_t:s0   /srv/mycron/</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:var_t:s0   /srv/mycron/checktime</span><br><span class="line"><span class="comment"># 发现变成了 var_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 观察上层 /srv 的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -l | grep &#x27;^/srv&#x27;</span></span><br><span class="line">/srv/.*                                            all files          system_u:object_r:var_t:s0 </span><br><span class="line">/srv/([^/]*/)?www(/.*)?                            all files          system_u:object_r:httpd_sys_content_t:s0 </span><br><span class="line">/srv/([^/]*/)?ftp(/.*)?                            all files          system_u:object_r:public_content_t:s0 </span><br><span class="line">/srv/([^/]*/)?rsync(/.*)?                          all files          system_u:object_r:public_content_t:s0 </span><br><span class="line">/srv/([^/]*/)?www/logs(/.*)?                       all files          system_u:object_r:httpd_log_t:s0 </span><br><span class="line">/srv/node(/.*)?                                    all files          system_u:object_r:swift_data_t:s0 </span><br><span class="line">/srv/gallery2(/.*)?                                all files          system_u:object_r:httpd_sys_content_t:s0 </span><br><span class="line">/srv/lib/gitosis(/.*)?                             all files          system_u:object_r:gitosis_var_lib_t:s0 </span><br><span class="line">/srv/gallery2/smarty(/.*)?                         all files          system_u:object_r:httpd_sys_rw_content_t:s0 </span><br><span class="line">/srv/loopback-device(/.*)?                         all files          system_u:object_r:swift_data_t:s0 </span><br><span class="line">/srv                                               all files          system_u:object_r:var_t:s0</span><br><span class="line"><span class="comment"># 可以看到这里默认就是  var_t 类型的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将 mycron 默认值改为 system_cron_spool_t</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -a -t system_cron_spool_t &quot;/srv/mycron(/.*)?&quot;</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -l | grep &#x27;^/srv/mycron&#x27;</span></span><br><span class="line">/srv/mycron(/.*)?                                  all files          system_u:object_r:system_cron_spool_t:s0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 回复 /srv/mycron 以及子目录相关的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /srv/mycron/</span></span><br><span class="line">restorecon reset /srv/mycron context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:system_cron_spool_t:s0</span><br><span class="line">restorecon reset /srv/mycron/checktime context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:system_cron_spool_t:s0</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>通过这个例子来看，<strong>restorecon</strong> 的确是很方便 ，学会这些基础的工具，对于 <strong>SELinux</strong> 来说基本上也够用了</p>
<hr>
<h2 id="一个网络服务案例及登录文件协助"><a href="#一个网络服务案例及登录文件协助" class="headerlink" title="一个网络服务案例及登录文件协助"></a>一个网络服务案例及登录文件协助</h2><p>本章在 <strong>SELinux</strong> 小节中介绍到的各个指令，尤其是 <strong>setsebool</strong>、<strong>chcon</strong>、<strong>restorecon</strong> 等都是为了当你的某些网络服务无法正常提供相关功能时，才需要进行修改的一些指令动作。</p>
<p>可以通过主动检查的方式来检查是否有 <strong>SELinux</strong> 产生的错误。而不是等客户端联机失败来反馈</p>
<h3 id="setroubleshoot：错误信息写入-var-log-messages"><a href="#setroubleshoot：错误信息写入-var-log-messages" class="headerlink" title="setroubleshoot：错误信息写入 /var/log/messages"></a>setroubleshoot：错误信息写入 <code>/var/log/messages</code></h3><p>几乎所有 <strong>SELinux</strong> 相关的程序都是以 <strong>se</strong> 开头，该服务时错误克服，启动后，会将关于 <strong>SELinux</strong> 的错误信息与克服方法记录到 <code>/var/log/messages</code> 与 <code>/var/log/setroubleshoot/*</code> 中</p>
<p>需要安装：<strong>setroubleshoot</strong> 与 <strong>setroubleshoot-server</strong>。原本 <strong>SELinux</strong> 信息是两个服务来记录的，分别是 <strong>auditd</strong> 与 <strong>setroubleshoot</strong>。在 <strong>CentOS 6.x</strong> 起整合成 <strong>auditd</strong> 了。所以安装好 <strong>setroubleshoot-server</strong> 后，需要重新启动 <strong>auditd</strong> 服务，否则 <strong>setroubleshoot</strong> 功能不会被启动</p>
<p>实际上。CentOS 7.x 对 <strong>setroubleshoot</strong> 的运行方式是：先由 <strong>auditd</strong> 去呼叫 <strong>audispd</strong> 服务，然后 <strong>audispd</strong> 服务启动 <strong>sedispatch</strong> 程序， <strong>sedispatch</strong> 再将原本的 <strong>auditd</strong> 信息转成 <strong>setroubleshoot</strong> 的信息，存储下来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># rpm -qa | grep setroubleshoot</span></span><br><span class="line">setroubleshoot-3.2.30-7.el7.x86_64</span><br><span class="line">setroubleshoot-plugins-3.0.67-4.el7.noarch</span><br><span class="line">setroubleshoot-server-3.2.30-7.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>在预设的情况下 <strong>setroubleshoot</strong> 被安装了，记得刚安装 <strong>setroubleshoot</strong> 的话，需要重新启动 <strong>auditd</strong> 服务的、</p>
<p>目前我们没有任何受限的网络服务主体进程在运行，下面使用一个简单的 <strong>FTP</strong> 服务器软件示例，来了解上面讲到的许多重点应用</p>
<h3 id="实例说明：通过-vsftpd-这个-FTP-服务器来存取系统上的文件"><a href="#实例说明：通过-vsftpd-这个-FTP-服务器来存取系统上的文件" class="headerlink" title="实例说明：通过 vsftpd 这个 FTP 服务器来存取系统上的文件"></a>实例说明：通过 vsftpd 这个 FTP 服务器来存取系统上的文件</h3><p>在 <strong>CentOS 7.x</strong> 环境下， <strong>FTP</strong> 的默认服务器软件主要是 <strong>vsftpd</strong></p>
<p>详细的 FTP 协议在服务器篇讲解，这里简单利用 <strong>vsftpd</strong> 与 <strong>FTP</strong> 的协议来讲解 <strong>SELinux</strong> 的问题与错误克服。</p>
<p>下面只接受一些简单的 <strong>FTP</strong> 知识：客户端需要使用 <strong>FTP</strong> 账户登录 <strong>FTP</strong> 服务器，有一个称为「匿名 （<strong>anonymous</strong>）」的账户可以登录系统，但是这个匿名的账户登录后，只能存取一个特定的目录，而无法脱离该目录</p>
<p>在 <strong>vsftpd</strong> 中，一般用户与匿名者的家目录说明如下：</p>
<ul>
<li>匿名者：如果使用浏览器来联机到 <strong>FTP</strong> 服务器，那预设就是使用匿名者登录系统。匿名者的家目录默认是在 <code>/var/ftp</code> 中，同时，匿名者在家目录下只能下载数据，不能上传数据到 <strong>FTP</strong> 服务器，同时匿名者无法离开 FTP 服务器的 <code>/var/ftp</code> 目录</li>
<li>一般 <strong>FTP</strong> 账户：在预设情况下，所有 <strong>UID</strong> 大于 <strong>1000</strong> 的账户，都可以使用 <strong>FTP</strong> 来登录系统，登录系统后，所有的账户都能够取得自己家目录下的文件数据，预设也可以上传、下载文件的</li>
</ul>
<p>为了避免与之前章节的用户产生误解情况，创建一个名为 <strong>ftptest</strong> 的账户，且账户密码为 <strong>myftp123</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># useradd -s /sbin/nologin ftptest</span></span><br><span class="line">[root@study ~]<span class="comment"># echo &quot;myftp123&quot; | passwd --stdin ftptest</span></span><br><span class="line">Changing password <span class="keyword">for</span> user ftptest.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>

<p>下面来安装 <strong>vsftp</strong> 服务器软件（还是在光盘中安装，前面挂载那样）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># yum install /mnt/Packages/vsftpd-3*                    </span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># systemctl start vsftpd		# 启动 vsftpd 服务</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl enable vsftpd		# 设置为开机启动</span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.</span><br><span class="line">[root@study ~]<span class="comment"># netstat -tlnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1374/cupsd          </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1578/master         </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1975/dnsmasq        </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      1374/cupsd          </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1578/master         </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           </span><br><span class="line">tcp6       0      0 :::21                   :::*                    LISTEN      6656/vsftpd         </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到   6656/vsftpd 这行数据，代表已经启动了</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名者无法下载的问题"><a href="#匿名者无法下载的问题" class="headerlink" title="匿名者无法下载的问题"></a>匿名者无法下载的问题</h3><p>模拟一些 <strong>FTP</strong> 的常用状态，假设将 <code>/etc/securetty</code> 以及主要的 <code>/etc/sysctl.conf</code> 放置给所有人下载，那么可以能会这样做</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># cp -a /etc/securetty /etc/sysctl.conf /var/ftp/pub</span></span><br><span class="line">[root@study ~]<span class="comment"># ll /var/ftp/pub/</span></span><br><span class="line">total 8</span><br><span class="line">-rw-------. 1 root root 221 Oct 31  2018 securetty</span><br><span class="line">-rw-r--r--. 1 root root 449 Aug  9  2019 sysctl.conf</span><br></pre></td></tr></table></figure>

<p>一般来说，默认要给用户下载的 <strong>FTP</strong> 文件会放在 <code>/var/ftp/pub</code> 目录中。下面使用简单的终端机浏览器 <strong>curl</strong> 来观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看 FTP 根目录下有哪些内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost</span></span><br><span class="line">drwxr-xr-x    2 0        0              42 Mar 17 09:03 pub</span><br><span class="line"><span class="comment"># 确实看到了 pub 目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看 pub 目录内的内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub</span></span><br><span class="line">curl: (78) RETR response: 550</span><br><span class="line"><span class="comment"># 无法访问，是因为 pub 是一个目录需要后缀 / 结尾</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/</span></span><br><span class="line">-rw-------    1 0        0             221 Oct 30  2018 securetty</span><br><span class="line">-rw-r--r--    1 0        0             449 Aug 08  2019 sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看里面的文件内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/sysctl.conf</span></span><br><span class="line"><span class="comment"># sysctl settings are defined through files in</span></span><br><span class="line"><span class="comment"># /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Vendors settings live in /usr/lib/sysctl.d/.</span></span><br><span class="line"><span class="comment"># To override a whole file, create a new file with the same in</span></span><br><span class="line"><span class="comment"># /etc/sysctl.d/ and put new settings there. To override</span></span><br><span class="line"><span class="comment"># only specific settings, add a file with a lexically later</span></span><br><span class="line"><span class="comment"># name in /etc/sysctl.d/ and put new settings there.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, see sysctl.conf(5) and sysctl.d(5).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面不是错误信息，是哪个文件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 继续查看下一个文件内容</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/securetty  </span></span><br><span class="line">curl: (78) RETR response: 550</span><br><span class="line"><span class="comment"># 这里看不到了，但是 securetty 的确是一个文件而不是一个目录，基本原因应该是权限问题</span></span><br><span class="line"><span class="comment"># 因为 vsftpd 默认放在 /var/ftp/pub 内的资料，无论什么 SELinux type 几乎都可以被读取才对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 修正权限后，再观察一次 securetty 文件</span></span><br><span class="line">[root@study ~]<span class="comment"># ll /var/ftp/pub/</span></span><br><span class="line">total 8</span><br><span class="line">-rw-------. 1 root root 221 Oct 31  2018 securetty</span><br><span class="line">-rw-r--r--. 1 root root 449 Aug  9  2019 sysctl.conf</span><br><span class="line"><span class="comment"># 可以看到 securetty 的其他人权限没有。改变成其他人也可以读取</span></span><br><span class="line">[root@study ~]<span class="comment"># chmod a+r /var/ftp/pub/securetty </span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost/pub/securetty</span></span><br><span class="line">console</span><br><span class="line">vc/1</span><br><span class="line">vc/2</span><br><span class="line">vc/3</span><br><span class="line"><span class="comment"># 此时已经能看到文件内容了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 修正 SELinux type 的内容（非必须）</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /var/ftp/</span></span><br><span class="line">restorecon reset /var/ftp/pub/securetty context system_u:object_r:etc_runtime_t:s0-&gt;system_u:object_r:public_content_t:s0</span><br><span class="line">restorecon reset /var/ftp/pub/sysctl.conf context system_u:object_r:system_conf_t:s0-&gt;system_u:object_r:public_content_t:s0</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>上述列子告诉我们，要先从权限角度来检查，如果无法被读取 ，可能是因为没有 <strong>r</strong> 或则没有 <strong>rx</strong> 权限，并不一定是 <strong>SELinux</strong> 引起的。下面看看用一般账户登录</p>
<h3 id="无法从家目录下载文件的问题分析与解决"><a href="#无法从家目录下载文件的问题分析与解决" class="headerlink" title="无法从家目录下载文件的问题分析与解决"></a>无法从家目录下载文件的问题分析与解决</h3><p>由于通过一般账户，前面建立的 <strong>ftptest</strong> 账户登录的话，文字型的 FTP 客户端软件，默认会将用户引导在根目录，而不是家目录，因此，访问的 <strong>URL</strong> 需要更改一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0. 在 ftptest 家目录下创建一些数据</span></span><br><span class="line">[root@study ~]<span class="comment"># echo  ~ftptest/</span></span><br><span class="line">/home/ftptest/</span><br><span class="line">[root@study ~]<span class="comment"># echo &quot;testing&quot; &gt;  ~ftptest/test.txt</span></span><br><span class="line">[root@study ~]<span class="comment"># cp -a /etc/hosts /etc/sysctl.conf ~ftptest/</span></span><br><span class="line">[root@study ~]<span class="comment"># ll ~ftptest/</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r--r--. 1 root root 158 Jun  7  2013 hosts</span><br><span class="line">-rw-r--r--. 1 root root 449 Aug  9  2019 sysctl.conf</span><br><span class="line">-rw-r--r--. 1 root root   8 Mar 17 17:23 test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 一般账户直接登录 FTP 服务器，同时变换目录到家目录</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/</span></span><br><span class="line">curl: (67) Access denied: 530			<span class="comment"># 这里报错了</span></span><br><span class="line"><span class="comment"># 注意：书上在增加 ftptest 用户的时候，使用的是 /sbin/nologin，就无法访问 ftp，这里修改下，就可以了</span></span><br><span class="line">[root@study ~]<span class="comment"># usermod -s  /bin/bash ftptest</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/</span></span><br><span class="line">-rw-r--r--    1 0        0             158 Jun 07  2013 hosts</span><br><span class="line">-rw-r--r--    1 0        0             449 Aug 08  2019 sysctl.conf</span><br><span class="line">-rw-r--r--    1 0        0               8 Mar 17 09:23 test.txt</span><br><span class="line"><span class="comment"># 看左边的权限也是没有问题的</span></span><br><span class="line"><span class="comment"># 从这里开始，笔者的实验和书上的结果对不上了，下面只记录书上的操作指令</span></span><br><span class="line"><span class="comment"># 就是因为上面修改用户的 bash 后，虽然可以访问了，但是下面的却可以下载文件，无法达到和书上的效果一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 下载上面可以阅读的权限文件</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/test.txt</span></span><br><span class="line">curl:(78) RETR response:550</span><br><span class="line"><span class="comment"># 无法访下载，是否是 SELinux 造成的？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将 SELinux 从 Enforce 转成 Permissive </span></span><br><span class="line">[root@study ~]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/test.txt</span></span><br><span class="line">testing</span><br><span class="line">[root@study ~]<span class="comment"># setenforce 1	# 确定是 SELinux 权限问题后，改回来</span></span><br><span class="line"><span class="comment"># 需要该规则还是该 type？现在不知道</span></span><br><span class="line"><span class="comment"># 所以先查询下登录日志有没有相关的信息提供给我们处理</span></span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># vim /var/log/messages</span></span><br><span class="line">Aug 9 02:55:58 station3-39 setroubleshoot:SELinux is preventing /usr/sbin/vsftpd</span><br><span class="line">	from lock access on the file /home/ftptest/test.txt. For complete SELinux messages.</span><br><span class="line">	run sealert -l 3axxxxxxxx</span><br><span class="line"><span class="comment"># 之类的字样，关键词就是 sealert ，执行这条命令</span></span><br><span class="line">[root@study ~]<span class="comment"># sealert -l 3axxxxxxxx</span></span><br><span class="line">SELinux is preventing /usr/sbin/vsftpd from lock access on the file /home/ftptest/<span class="built_in">test</span>/txt.</span><br><span class="line"><span class="comment"># 下面说有 47.5% 的几率是由于这个原因所发生，并且可以使用 setsebool 去解决的意思</span></span><br><span class="line">******* Plugin catchall_boolean(47.5 confidence) suggests ********</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> you want to allow ftp to home dir</span><br><span class="line">...</span><br><span class="line">Do</span><br><span class="line">setsebool -P ftp_home_dir 1</span><br><span class="line"></span><br><span class="line">******* Plugin catchall(6.38confidence) suggests ********</span><br><span class="line">DO</span><br><span class="line"><span class="comment"># grep vsftpd /var/log/audit/audit.log | audit2allow -M mypol</span></span><br><span class="line"><span class="comment"># semodule -i mypol.pp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面就重要了，是整个问题发生的主要原因</span></span><br><span class="line">Additional Information:</span><br><span class="line">Source Context	system_u:system_r:ftpd_t:s0-s0:c0.c1023</span><br><span class="line">Target Context	unconfined_u:object_r:user_home_t:s0</span><br><span class="line">Target Objects	/home/ftptest/<span class="built_in">test</span>/txt [ file ]</span><br></pre></td></tr></table></figure>

<p>通过上面的测试，知道主要的问题发生在 <strong>SElinux</strong> 的 <strong>type</strong> 不是 <strong>vsftpd_t</strong> 所能读取的原因，上面 <strong>47.5</strong> 的概率问题，<strong>ftp_home_dir</strong> 是 <strong>SELinux rules</strong> 的配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 确认下 SELinux 的模式，并且无法访问</span></span><br><span class="line">[root@study ~]<span class="comment"># getenforce </span></span><br><span class="line">Enforcing</span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost/~/test.txt</span></span><br><span class="line">curl:(78) RETR response:550</span><br><span class="line">[root@study ~]<span class="comment"># setsebool -P ftp_home_dir 1</span></span><br><span class="line">Boolean ftp_home_dir is not defined</span><br><span class="line"><span class="comment"># 可惜笔者这里提示没有被定义，与书上对不上啊</span></span><br></pre></td></tr></table></figure>

<h3 id="一般账户用户从非正规目录上传-下载文件"><a href="#一般账户用户从非正规目录上传-下载文件" class="headerlink" title="一般账户用户从非正规目录上传/下载文件"></a>一般账户用户从非正规目录上传/下载文件</h3><p>提供 <code>/srv/gogogo</code> 目录给 <strong>ftptest</strong> 用户使用，该如何处理？假设不考虑 <strong>SELiunx</strong> 的话，就是如下方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 处理好所需要的目录数据</span></span><br><span class="line">[root@study ~]<span class="comment"># mkdir /srv/gogogo</span></span><br><span class="line">[root@study ~]<span class="comment"># chgrp ftptest /srv/gogogo/</span></span><br><span class="line"><span class="comment"># 把用户组改成 ftptest 这个组</span></span><br><span class="line">[root@study ~]<span class="comment"># ll -d /srv/gogogo/</span></span><br><span class="line">drwxr-xr-x. 2 root ftptest 22 3月  17 22:43 /srv/gogogo/</span><br><span class="line">[root@study ~]<span class="comment"># echo &quot;test&quot; &gt; /srv/gogogo/test.txt</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost//srv/gogogo/test.txt</span></span><br><span class="line">curl: (78) RETR response: 550</span><br><span class="line"><span class="comment"># 访问不了，查看日志</span></span><br><span class="line">[root@study ~]<span class="comment"># grep sealert /var/log/messages | tail</span></span><br><span class="line">Mar 17 22:46:35 study setroubleshoot: SELinux is preventing /usr/sbin/vsftpd from <span class="built_in">read</span> access on the file test.txt. For complete SELinux messages run: sealert -l 88f08c09-c510-4518-bbcc-58bcee06ffb0</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sealert -l 88f08c09-c510-4518-bbcc-58bcee06ffb0</span></span><br><span class="line">SELinux is preventing /usr/sbin/vsftpd from <span class="built_in">read</span> access on the file test.txt.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然这个可信度很高，不过，因为会全部方向 FTP，所以不考虑</span></span><br><span class="line">*****  Plugin catchall_boolean (57.6 confidence) suggests   ******************</span><br><span class="line"></span><br><span class="line">If you want to allow ftpd to full access</span><br><span class="line">Then you must tell SELinux about this by enabling the <span class="string">&#x27;ftpd_full_access&#x27;</span> boolean.</span><br><span class="line"></span><br><span class="line">Do</span><br><span class="line">setsebool -P ftpd_full_access 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为是非正规目录的使用，所以这边加上预设 SELinux type 恐怕能解决</span></span><br><span class="line">*****  Plugin catchall_labels (36.2 confidence) suggests   *******************</span><br><span class="line"></span><br><span class="line">If you want to allow vsftpd to have <span class="built_in">read</span> access on the test.txt file</span><br><span class="line">Then you need to change the label on test.txt</span><br><span class="line">Do</span><br><span class="line"><span class="comment"># 下面这一条数据</span></span><br><span class="line"><span class="comment"># semanage fcontext -a -t FILE_TYPE &#x27;test.txt&#x27;</span></span><br><span class="line">.... 很多数据</span><br><span class="line">Then execute:</span><br><span class="line">restorecon -v <span class="string">&#x27;test.txt&#x27;</span>		<span class="comment"># 还有这一条数据，都是要参考的解决方案</span></span><br><span class="line"></span><br><span class="line">*****  Plugin catchall (7.64 confidence) suggests   **************************</span><br><span class="line"></span><br><span class="line">If you believe that vsftpd should be allowed <span class="built_in">read</span> access on the test.txt file by default.</span><br><span class="line">Then you should report this as a bug.</span><br><span class="line">You can generate a <span class="built_in">local</span> policy module to allow this access.</span><br><span class="line">Do</span><br><span class="line">allow this access <span class="keyword">for</span> now by executing:</span><br><span class="line"><span class="comment"># ausearch -c &#x27;vsftpd&#x27; --raw | audit2allow -M my-vsftpd</span></span><br><span class="line"><span class="comment"># semodule -i my-vsftpd.pp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Additional Information:</span><br><span class="line">Source Context                system_u:system_r:ftpd_t:s0-s0:c0.c1023</span><br><span class="line">Target Context                unconfined_u:object_r:var_t:s0</span><br><span class="line">Target Objects                test.txt [ file ]</span><br><span class="line">Source                        vsftpd</span><br><span class="line">Source Path                   /usr/sbin/vsftpd</span><br><span class="line">Port                          &lt;Unknown&gt;</span><br><span class="line">Host                          study.centos.mrcode</span><br><span class="line">Source RPM Packages           </span><br><span class="line">Target RPM Packages           </span><br><span class="line">Policy RPM                    selinux-policy-3.13.1-252.el7.noarch</span><br><span class="line">Selinux Enabled               True</span><br><span class="line">Policy Type                   targeted</span><br><span class="line">Enforcing Mode                Enforcing</span><br><span class="line">Host Name                     study.centos.mrcode</span><br><span class="line">Platform                      Linux study.centos.mrcode 3.10.0-1062.el7.x86_64</span><br><span class="line">                              <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64</span></span><br><span class="line">Alert Count                   2</span><br><span class="line">First Seen                    2020-03-17 22:46:17 CST</span><br><span class="line">Last Seen                     2020-03-17 22:46:32 CST</span><br><span class="line">Local ID                      88f08c09-c510-4518-bbcc-58bcee06ffb0</span><br><span class="line"></span><br><span class="line">Raw Audit Messages</span><br><span class="line"><span class="built_in">type</span>=AVC msg=audit(1584456392.386:979): avc:  denied  &#123; <span class="built_in">read</span> &#125; <span class="keyword">for</span>  pid=10979 comm=<span class="string">&quot;vsftpd&quot;</span> name=<span class="string">&quot;test.txt&quot;</span> dev=<span class="string">&quot;dm-0&quot;</span> ino=35108539 scontext=system_u:system_r:ftpd_t:s0-s0:c0.c1023 tcontext=unconfined_u:object_r:var_t:s0 tclass=file permissive=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hash: vsftpd,ftpd_t,var_t,file,<span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看 /var/ftp 的 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment">#  ll -Zd /var/ftp/</span></span><br><span class="line">drwxr-xr-x. root root system_u:object_r:public_content_t:s0 /var/ftp/</span><br><span class="line">[root@study ~]<span class="comment">#  ll -Zd /srv/gogogo/</span></span><br><span class="line">drwxr-xr-x. root ftptest unconfined_u:object_r:var_t:s0   /srv/gogogo/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 以 sealert 建议的方法来处理好 SELinux type</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage fcontext -a -t public_content_t &#x27;/srv/gogogo(/.*)?&#x27;</span></span><br><span class="line">[root@study ~]<span class="comment"># restorecon -Rv /srv/gogogo</span></span><br><span class="line">restorecon reset /srv/gogogo context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:public_content_t:s0</span><br><span class="line">restorecon reset /srv/gogogo/test.txt context unconfined_u:object_r:var_t:s0-&gt;unconfined_u:object_r:public_content_t:s0</span><br><span class="line"><span class="comment"># 再次访问就可以了</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://ftptest:myftp123@localhost//srv/gogogo/test.txt</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>在这个范例中，修改的是 <strong>type</strong>，前一个范例中修改的是 <strong>rule</strong>，不太一样的</p>
<h3 id="无法变更-FTP-联机端口问题分析解决"><a href="#无法变更-FTP-联机端口问题分析解决" class="headerlink" title="无法变更 FTP 联机端口问题分析解决"></a>无法变更 FTP 联机端口问题分析解决</h3><p>比如你想要改变 FTP 默认的启动端口 21 改成 555，基本上，既然 SELinux 的主体进程大多是被受限的网络服务，很有可能连端口也限制了，下面尝试修改端口，来查看是怎么解决问题的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先处理 vsftpd 的配置文件，加入 port 的端口参数</span></span><br><span class="line">[root@study ~]<span class="comment"># vim /etc/vsftpd/vsftpd.conf </span></span><br><span class="line">listen_port=555</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重启服务，并查看日志</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart vsftpd</span></span><br><span class="line">Job <span class="keyword">for</span> vsftpd.service failed because the control process exited with error code. See <span class="string">&quot;systemctl status vsftpd.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">[root@study ~]<span class="comment"># grep sealert /var/log/messages</span></span><br><span class="line">Mar 17 23:03:23 study setroubleshoot: SELinux is preventing /usr/sbin/vsftpd from name_bind access on the tcp_socket port 555. For complete SELinux messages run: sealert -l e3e3dee0-83eb-4cb8-b894-8be590fee082</span><br><span class="line"></span><br><span class="line">[root@study ~]<span class="comment"># sealert -l e3e3dee0-83eb-4cb8-b894-8be590fee082</span></span><br><span class="line">SELinux is preventing /usr/sbin/vsftpd from name_bind access on the tcp_socket port 555.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个 92.2 的概率，基本上就是这个了</span></span><br><span class="line">*****  Plugin bind_ports (92.2 confidence) suggests   ************************</span><br><span class="line"></span><br><span class="line">If you want to allow /usr/sbin/vsftpd to <span class="built_in">bind</span> to network port 555</span><br><span class="line">Then you need to modify the port <span class="built_in">type</span>.</span><br><span class="line">Do</span><br><span class="line"><span class="comment"># semanage port -a -t PORT_TYPE -p tcp 555</span></span><br><span class="line">    <span class="built_in">where</span> PORT_TYPE is one of the following: certmaster_port_t, cluster_port_t, ephemeral_port_t, ftp_data_port_t, ftp_port_t, hadoop_datanode_port_t, hplip_port_t, isns_port_t, port_t, postgrey_port_t, unreserved_port_t.</span><br><span class="line"></span><br><span class="line">*****  Plugin catchall_boolean (7.83 confidence) suggests   ******************</span><br><span class="line"></span><br><span class="line">If you want to allow nis to enabled</span><br><span class="line">Then you must tell SELinux about this by enabling the <span class="string">&#x27;nis_enabled&#x27;</span> boolean.</span><br><span class="line"></span><br><span class="line">Do</span><br><span class="line">setsebool -P nis_enabled 1</span><br><span class="line"></span><br><span class="line">*****  Plugin catchall (1.41 confidence) suggests   **************************</span><br><span class="line"></span><br><span class="line">If you believe that vsftpd should be allowed name_bind access on the port 555 tcp_socket by default.</span><br><span class="line">Then you should report this as a bug.</span><br><span class="line">You can generate a <span class="built_in">local</span> policy module to allow this access.</span><br><span class="line">Do</span><br><span class="line">allow this access <span class="keyword">for</span> now by executing:</span><br><span class="line"><span class="comment"># ausearch -c &#x27;vsftpd&#x27; --raw | audit2allow -M my-vsftpd</span></span><br><span class="line"><span class="comment"># semodule -i my-vsftpd.pp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Additional Information:</span><br><span class="line">Source Context                system_u:system_r:ftpd_t:s0-s0:c0.c1023</span><br><span class="line">Target Context                system_u:object_r:hi_reserved_port_t:s0</span><br><span class="line">Target Objects                port 555 [ tcp_socket ]</span><br><span class="line">Source                        vsftpd</span><br><span class="line">Source Path                   /usr/sbin/vsftpd</span><br><span class="line">Port                          555</span><br><span class="line">Host                          study.centos.mrcode</span><br><span class="line">Source RPM Packages           vsftpd-3.0.2-25.el7.x86_64</span><br><span class="line">Target RPM Packages           </span><br><span class="line">Policy RPM                    selinux-policy-3.13.1-252.el7.noarch</span><br><span class="line">Selinux Enabled               True</span><br><span class="line">Policy Type                   targeted</span><br><span class="line">Enforcing Mode                Enforcing</span><br><span class="line">Host Name                     study.centos.mrcode</span><br><span class="line">Platform                      Linux study.centos.mrcode 3.10.0-1062.el7.x86_64</span><br><span class="line">                              <span class="comment">#1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64</span></span><br><span class="line">Alert Count                   1</span><br><span class="line">First Seen                    2020-03-17 23:03:20 CST</span><br><span class="line">Last Seen                     2020-03-17 23:03:20 CST</span><br><span class="line">Local ID                      e3e3dee0-83eb-4cb8-b894-8be590fee082</span><br><span class="line"></span><br><span class="line">Raw Audit Messages</span><br><span class="line"><span class="built_in">type</span>=AVC msg=audit(1584457400.225:1008): avc:  denied  &#123; name_bind &#125; <span class="keyword">for</span>  pid=11443 comm=<span class="string">&quot;vsftpd&quot;</span> src=555 scontext=system_u:system_r:ftpd_t:s0-s0:c0.c1023 tcontext=system_u:object_r:hi_reserved_port_t:s0 tclass=tcp_socket permissive=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>=SYSCALL msg=audit(1584457400.225:1008): arch=x86_64 syscall=<span class="built_in">bind</span> success=no <span class="built_in">exit</span>=EACCES a0=4 a1=55e9e4d4e800 a2=1c a3=3 items=0 ppid=11440 pid=11443 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm=vsftpd exe=/usr/sbin/vsftpd subj=system_u:system_r:ftpd_t:s0-s0:c0.c1023 key=(null)</span><br><span class="line"></span><br><span class="line">Hash: vsftpd,ftpd_t,hi_reserved_port_t,tcp_socket,name_bind</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 根据建议解决执行指令, 92% 哪个指令下面 PORT_TYPE 下面又可选的 ftp_port_t</span></span><br><span class="line"><span class="comment"># 但是笔者还是懵逼的，不知道为什么那么多里面就选这个了</span></span><br><span class="line">[root@study ~]<span class="comment"># semanage port -a -t ftp_port_t -p tcp 555</span></span><br><span class="line">[root@study ~]<span class="comment"># systemctl restart vsftpd</span></span><br><span class="line">[root@study ~]<span class="comment"># netstat -tlnp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1374/cupsd          </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1578/master         </span><br><span class="line">tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN      10579/sshd: root@pt </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1975/dnsmasq        </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      1374/cupsd          </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1578/master         </span><br><span class="line">tcp6       0      0 ::1:6010                :::*                    LISTEN      2350/sshd: mrcode@p </span><br><span class="line">tcp6       0      0 ::1:6011                :::*                    LISTEN      10579/sshd: root@pt </span><br><span class="line">tcp6       0      0 :::555                  :::*                    LISTEN      11573/vsftpd        </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd     </span><br><span class="line"><span class="comment"># 可以看到 vsftpd 的端口变成了 555 了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 实验看看该 port 是否可用</span></span><br><span class="line">[root@study ~]<span class="comment"># curl ftp://localhost:555</span></span><br><span class="line">drwxr-xr-x    2 0        0              42 Mar 17 09:03 pub</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wotzc</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/wotzc" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
