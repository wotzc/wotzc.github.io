<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="真正的大师永远都怀着一颗学徒的心">
<meta property="og:type" content="website">
<meta property="og:title" content="Cai">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Cai">
<meta property="og:description" content="真正的大师永远都怀着一颗学徒的心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wotzc">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Cai</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  
  <a target="_blank" rel="noopener" href="https://github.com/wotzc" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cai</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wotzc"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">wotzc</p>
  <div class="site-description" itemprop="description">真正的大师永远都怀着一颗学徒的心</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">MySQL数据库基础(一)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-20 17:16:23" itemprop="dateCreated datePublished" datetime="2021-11-20T17:16:23+08:00">2021-11-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-25 17:08:12" itemprop="dateModified" datetime="2021-12-25T17:08:12+08:00">2021-12-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h1><h2 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h2><p>SQL语言在功能上主要分为如下3大类:</p>
<p><span style="color: #730002"><strong>DDL(Data Definition Languages、数据定义语言)</strong></span>，这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p>
<p>主要的语句关键字包括 <strong><span style="color: #e15307">CREATE</span></strong> 、 <strong><span style="color: #e15307">DROP</span></strong> 、 <strong><span style="color: #e15307">ALTER</span></strong> 等。<br><span style="color: #730002"><strong>DML(Data Manipulation Language、数据操作语言)</strong></span>，用于添加、删除、更新和查询数据库记 录，并检查数据完整性。</p>
<p>主要的语句关键字包括 <strong><span style="color: #e15307">INSERT</span></strong> 、 <strong><span style="color: #e15307">DELETE</span></strong> 、 <strong><span style="color: #e15307">UPDATE</span></strong> 、 <strong><span style="color: #e15307">SELECT</span></strong> 等。</p>
<p><strong><span style="color: red">SELECT是SQL语言的基础，最为重要。</span></strong><br>**<span style="color: #730002">DCL(Data Control Language、数据控制语言)</span>**，用于定义数据库、表、字段、用户的访问权限和 安全级别。</p>
<p>主要的语句关键字包括 <strong><span style="color: #e15307">GRANT</span></strong> 、 <strong><span style="color: #e15307">REVOKE</span></strong> 、 <strong><span style="color: #e15307">COMMIT</span></strong> 、 <strong><span style="color: #e15307">ROLLBACK</span></strong> 、 <strong><span style="color: #e15307">SAVEPOINT</span></strong> 等。</p>
<hr>
<p><strong><span style="color: #730002">DCL(Data Control Language、数据控制语言)</span></strong></p>
<p><strong><span style="color: #e15307">注意：</span></strong></p>
<p><strong><span style="color: red">SELECT是SQL语言的基础，最为重要。</span></strong></p>
<hr>
<h2 id="SQL大小写规范-建议遵守"><a href="#SQL大小写规范-建议遵守" class="headerlink" title="SQL大小写规范 (建议遵守)"></a>SQL<strong>大小写规范 (建议遵守)</strong></h2><ul>
<li><p><strong><span style="color: red">MySQL 在Windows 环境下是大小写不敏感的</span></strong></p>
</li>
<li><p><strong><span style="color: red">MySQL 在Linux 环境下是大小写敏感的</span></strong></p>
<p>​    数据库名、表名、表的别名、变量名是严格区分大小写的</p>
</li>
</ul>
<p>​           关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</p>
<ul>
<li> <strong><span style="color: red">推荐采用统一的书写规范:</span></strong></li>
</ul>
<p>​            数据库名、表名、表别名、字段名、字段别名等都小写 SQL 关键字、函数名、绑定变量等都大写</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><p>可以使用如下格式的注释结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释: <span class="comment">#注释文字(MySQL特有的方式) </span></span><br><span class="line">单行注释: <span class="comment">-- 注释文字(--后面必须包含一个空格。) </span></span><br><span class="line">多行注释: <span class="comment">/* 注释文字 */</span></span><br></pre></td></tr></table></figure>

<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a><strong>命名规则</strong></h2><ul>
<li>数据库、表名不得超过30个字符，变量名限制为29个</li>
<li> 必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格 </li>
<li>同一个MySQL软件中，数据库不能同名;同一个库中，表不能重名;同一个表中，字段不能重名 </li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`(着重号)引起来 </li>
<li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以下两句是一样的，不区分大小写 show databases;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="comment">#创建表格</span></span><br><span class="line"><span class="comment">#create table student info(...); #表名错误，因为表名有空格 create table student_info(...);</span></span><br><span class="line"><span class="comment">#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><h3 id="SELECT语句一般格式："><a href="#SELECT语句一般格式：" class="headerlink" title="SELECT语句一般格式："></a>SELECT语句一般格式：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] &lt; 目标列表达式 &gt; [,&lt; 目标列表达式 &gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt; 表名或试图名 &gt; [,&lt; 表名或试图名 &gt;]...</span><br><span class="line">[ <span class="keyword">WHERE</span> &lt; 条件表达式 &gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt; 列名<span class="number">1</span> &gt; [ <span class="keyword">HAVING</span> &lt; 条件表达式 &gt; ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt; 列名<span class="number">2</span> &gt; [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ]];</span><br></pre></td></tr></table></figure>

<h3 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a>列的别名</h3><p>方式一</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name lname</span><br><span class="line"><span class="keyword">FROM</span>   employees;</span><br></pre></td></tr></table></figure>

<p>方式二</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> lname</span><br><span class="line"><span class="keyword">FROM</span>   employees;</span><br></pre></td></tr></table></figure>

<p>方式三 </p>
<p>列的别名可以使用一对””引起来，不要使用’’</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="string">&quot;lname&quot;</span></span><br><span class="line"><span class="keyword">FROM</span>   employees;</span><br></pre></td></tr></table></figure>

<h3 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure>

<h3 id="查询经过计算的值"><a href="#查询经过计算的值" class="headerlink" title="查询经过计算的值"></a>查询经过计算的值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">NAME</span>,<span class="number">2021</span>-Sage BIRTHDAY</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>

<h3 id="查询时添加常量列"><a href="#查询时添加常量列" class="headerlink" title="查询时添加常量列"></a>查询时添加常量列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, <span class="string">&#x27;湖北&#x27;</span> <span class="keyword">AS</span> province</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h3><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> employees;</span><br><span class="line">或</span><br><span class="line">DESC employees;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/basicComputer.png" style="zoom:67%;" />

<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。</p>
<p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/compareCpmputer.png" style="zoom:67%;" />

<h3 id="安全等于运算符"><a href="#安全等于运算符" class="headerlink" title="安全等于运算符"></a>安全等于运算符</h3><p>安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，<code>唯一的区别</code>是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。</p>
<p>此外，还有非符号类型的运算符：</p>
<h3 id="非符号类型的运算符"><a href="#非符号类型的运算符" class="headerlink" title="非符号类型的运算符"></a>非符号类型的运算符</h3><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/notSymbol1.png" style="zoom:67%;" />

<hr>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。</p>
<p>MySQL中支持4种逻辑运算符如下：</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/logicSymbol.png" style="zoom:67%;" />

<h3 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a>逻辑非运算符</h3><p>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。</p>
<h3 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a>逻辑与运算符</h3><p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。</p>
<h3 id="逻辑或运算符"><a href="#逻辑或运算符" class="headerlink" title="逻辑或运算符"></a>逻辑或运算符</h3><p>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p>
<blockquote>
<p><strong><span style="color: #e15307">注意：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</span></strong></p>
</blockquote>
<h3 id="逻辑异或运算符"><a href="#逻辑异或运算符" class="headerlink" title="逻辑异或运算符"></a>逻辑异或运算符</h3><p>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p>
<p>MySQL支持的位运算符如下：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/bitwise.png"></p>
<ol>
<li><p><strong>按位与运算符</strong> 按位与(&amp;)运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二 进制位的数值都为1时，则该位返回1，否则返回0。</p>
<p>例子：</p>
<p>​    1的二进制数为0001，10的二进制数为1010，所以1 &amp; 10的结果为0000，对应的十进制数为0。20的二进制 数为10100，30的二进制数为11110，所以20 &amp; 30的结果为10100，对应的十进制数为20。</p>
</li>
<li><p><strong>按位或运算符</strong> 按位或(|)运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的 二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。</p>
<p>例子：</p>
<p>​    1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进 制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。</p>
</li>
<li><p><strong>按位异或运算符</strong>“^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</p>
<p>例子：</p>
<p>​    </p>
</li>
<li><p><strong>按位取反运算符</strong> 按位取反(~)运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变 为1。</p>
</li>
<li><p><strong>按位右移运算符</strong> 按位右移(&gt;&gt;)运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的 位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</p>
<p>例子：</p>
<p>​    1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2 位为0000 0001，对应的十进制数为1。</p>
</li>
<li><p><strong>按位左移运算符</strong> 按位左移(&lt;&lt;)运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的 位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</p>
<p>例子：</p>
<p>​    1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移 两位为0001 0000，对应的十进制数为16。</p>
</li>
</ol>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/priority.png" style="zoom: 50%;" />

<p>数字编号越大，优先级越高，优先级高的运算符先进行计算。</p>
<hr>
<h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用 ORDER BY 子句排序</p>
<ul>
<li><span style="color: #730002">ASC(ascend)</span>: <strong>升序</strong></li>
<li><span style="color: #730002">DESC**(<strong>descend</strong>)<strong></span>:**降序<br>** ORDER BY **子句在</strong>SELECT<strong>语句的结尾。</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   last_name, job_id, department_id, hire_date</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure>

<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页原理 所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。 MySQL<strong>中使用</strong> LIMIT **实现分页<br>** 格式:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT [位置偏移量,] 行数</span><br></pre></td></tr></table></figure>

<ul>
<li>分页显式公式*<em>：（当前页数-1）</em>每页条数，每页条数**</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table </span><br><span class="line">LIMIT(PageNo - 1)*PageSize,PageSize;</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">--前10条记录:</span></span><br><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">10</span>; 或者</span><br><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--第11至20条记录:</span></span><br><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--第21至30条记录:</span></span><br><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">20</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:**LIMIT **子句必须放在整个</strong>SELECT<strong>语句的最后!</strong></p>
</blockquote>
<p>“LIMIT条目数”等价于”LIMIT  0, 条目数”</p>
<p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p>
<p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p>
<p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p>
<p>SQL92中，笛卡尔积也称为<code>交叉连接</code>，英文是 <code>CROSS JOIN</code>。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询员工姓名和所在部门名称</span><br><span class="line">SELECT last_name,department_name FROM employees,departments;</span><br><span class="line">SELECT last_name,department_name FROM employees CROSS JOIN departments;</span><br><span class="line">SELECT last_name,department_name FROM employees INNER JOIN departments;</span><br><span class="line">SELECT last_name,department_name FROM employees JOIN departments;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>笛卡尔积的错误会在下面条件下产生</strong>：</p>
<ul>
<li>省略多个表的连接条件（或关联条件）</li>
<li>连接条件（或关联条件）无效</li>
<li>所有表中的所有行互相连接</li>
</ul>
</li>
<li><p>为了避免笛卡尔积， 可以<strong>在 WHERE 加入有效的连接条件。</strong></p>
</li>
<li><p>加入连接条件后，查询语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT	table1.column, table2.column</span><br><span class="line">FROM	table1, table2</span><br><span class="line">WHERE	table1.column1 &#x3D; table2.column2;  #连接条件</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在 WHERE子句中写入连接条件。</strong></li>
</ul>
</li>
<li><p>正确写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line">SELECT last_name, department_name</span><br><span class="line">FROM employees, departments</span><br><span class="line">WHERE employees.department_id &#x3D; departments.department_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在表中有相同列时，在列名之前加上表名前缀。</strong></p>
</li>
</ul>
<h3 id="等值连接与非等值连接"><a href="#等值连接与非等值连接" class="headerlink" title="等值连接与非等值连接"></a>等值连接与非等值连接</h3><p>非等值连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.salary, j.grade_level</span><br><span class="line"><span class="keyword">FROM</span>   employees e, job_grades j</span><br><span class="line"><span class="keyword">WHERE</span>  e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal;</span><br></pre></td></tr></table></figure>



<h3 id="自连接与非自连接"><a href="#自连接与非自连接" class="headerlink" title="自连接与非自连接"></a>自连接与非自连接</h3><p>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIRST.Cno, SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno = SECOND.Cno</span><br></pre></td></tr></table></figure>

<h3 id="内连接与外连接"><a href="#内连接与外连接" class="headerlink" title="内连接与外连接"></a>内连接与外连接</h3><ul>
<li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></p>
</li>
<li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行</strong> <strong>，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)。</p>
</li>
<li><p>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code>。</p>
<p>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code>。</p>
</li>
</ul>
<h4 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接(INNER JOIN)"></a>内连接(INNER JOIN)</h4><ul>
<li>语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 INNER JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.employee_id, e.last_name, e.department_id, </span><br><span class="line">       d.department_id, d.location_id</span><br><span class="line">FROM   employees e JOIN departments d</span><br><span class="line">ON     (e.department_id &#x3D; d.department_id);</span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/innerjoin.png"></p>
<h4 id="外连接-OUTER-JOIN-的实现"><a href="#外连接-OUTER-JOIN-的实现" class="headerlink" title="外连接(OUTER JOIN)的实现"></a>外连接(OUTER JOIN)的实现</h4><h5 id="左外连接-LEFT-OUTER-JOIN"><a href="#左外连接-LEFT-OUTER-JOIN" class="headerlink" title="左外连接(LEFT OUTER JOIN)"></a>左外连接(LEFT OUTER JOIN)</h5><p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/leftjoin.png"></p>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 LEFT JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.department_id, d.department_name</span><br><span class="line">FROM   employees e</span><br><span class="line">LEFT OUTER JOIN departments d</span><br><span class="line">ON   (e.department_id &#x3D; d.department_id) ;</span><br></pre></td></tr></table></figure>

<h5 id="右外连接-RIGHT-OUTER-JOIN"><a href="#右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="右外连接(RIGHT OUTER JOIN)"></a>右外连接(RIGHT OUTER JOIN)</h5><p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/rightjoin.png"></p>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是B</span><br><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 RIGHT JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.department_id, d.department_name</span><br><span class="line">FROM   employees e</span><br><span class="line">RIGHT OUTER JOIN departments d</span><br><span class="line">ON    (e.department_id &#x3D; d.department_id) ;</span><br></pre></td></tr></table></figure>

<h5 id="满外连接-FULL-OUTER-JOIN"><a href="#满外连接-FULL-OUTER-JOIN" class="headerlink" title="满外连接(FULL OUTER JOIN)"></a>满外连接(FULL OUTER JOIN)</h5><ul>
<li>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li>
<li>SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</li>
<li>需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN <strong>UNION</strong> RIGHT join代替。</li>
</ul>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mysql%E5%9F%BA%E7%A1%80/fulljoin.png"></p>
<h3 id="UNION的使用"><a href="#UNION的使用" class="headerlink" title="UNION的使用"></a>UNION的使用</h3><p><strong>合并查询结果</strong><br>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。</p>
<p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column,... FROM table1</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT column,... FROM table2</span><br></pre></td></tr></table></figure>

<p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p>
<p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p>
<blockquote>
<p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
</blockquote>
<h3 id="SQL99语法新特性"><a href="#SQL99语法新特性" class="headerlink" title="SQL99语法新特性"></a>SQL99语法新特性</h3><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <code>NATURAL JOIN</code> 用来表示自然连接。</p>
<p>我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中<code>所有相同的字段</code>，然后进行<code>等值连接</code>。</p>
<p>在SQL92标准中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;</span><br><span class="line">AND e.&#96;manager_id&#96; &#x3D; d.&#96;manager_id&#96;;</span><br></pre></td></tr></table></figure>

<p>在 SQL99 中你可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e NATURAL JOIN departments d;</span><br></pre></td></tr></table></figure>

<h3 id="USING连接"><a href="#USING连接" class="headerlink" title="USING连接"></a>USING连接</h3><p>当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的<code>同名字段</code>进行等值连接。但是只能配合JOIN一起使用。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">USING (department_id);</span><br></pre></td></tr></table></figure>

<p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 <code>JOIN...USING</code> 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e ,departments d</span><br><span class="line">WHERE e.department_id &#x3D; d.department_id;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h1><h2 id="MySQL的内置函数及分类"><a href="#MySQL的内置函数及分类" class="headerlink" title="MySQL的内置函数及分类"></a>MySQL的内置函数及分类</h2><p>MySQL提供的内置函数从<code>实现的功能角度</code>可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：<code>单行函数</code>、<code>聚合函数（或分组函数）</code>。</p>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>SIGN(X)</td>
<td>返回X的符号。正数返回1，负数返回-1，0返回0</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率的值</td>
</tr>
<tr>
<td>CEIL(x)，CEILING(x)</td>
<td>返回大于或等于某个值的最小整数</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>返回小于或等于某个值的最大整数</td>
</tr>
<tr>
<td>LEAST(e1,e2,e3…)</td>
<td>返回列表中的最小值</td>
</tr>
<tr>
<td>GREATEST(e1,e2,e3…)</td>
<td>返回列表中的最大值</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回X除以Y后的余数</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1的随机值</td>
</tr>
<tr>
<td>RAND(x)</td>
<td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数</td>
</tr>
<tr>
<td>ROUND(x)</td>
<td>返回一个对x的值进行四舍五入后，最接近于X的整数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td>
</tr>
<tr>
<td>TRUNCATE(x,y)</td>
<td>返回数字x截断为y位小数的结果</td>
</tr>
<tr>
<td>SQRT(x)</td>
<td>返回x的平方根。当X的值为负数时，返回NULL</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),</span><br><span class="line">FLOOR(-43.23),MOD(12,5)</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="角度与弧度互换函数"><a href="#角度与弧度互换函数" class="headerlink" title="角度与弧度互换函数"></a>角度与弧度互换函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>RADIANS(x)</td>
<td>将角度转化为弧度，其中，参数x为角度值</td>
</tr>
<tr>
<td>DEGREES(x)</td>
<td>将弧度转化为角度，其中，参数x为弧度值</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>SIN(x)</td>
<td>返回x的正弦值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ASIN(x)</td>
<td>返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL</td>
</tr>
<tr>
<td>COS(x)</td>
<td>返回x的余弦值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ACOS(x)</td>
<td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td>
</tr>
<tr>
<td>TAN(x)</td>
<td>返回x的正切值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ATAN(x)</td>
<td>返回x的反正切值，即返回正切值为x的值</td>
</tr>
<tr>
<td>ATAN2(m,n)</td>
<td>返回两个参数的反正切值</td>
</tr>
<tr>
<td>COT(x)</td>
<td>返回x的余切值，其中，X为弧度值</td>
</tr>
</tbody></table>
<p>举例：</p>
<p>ATAN2(M,N)函数返回两个参数的反正切值。<br>与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而ATAN2(M,N)函数则仍然可以计算。</p>
<p>ATAN2(M,N)函数的使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1))</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="指数与对数"><a href="#指数与对数" class="headerlink" title="指数与对数"></a>指数与对数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>POW(x,y)，POWER(X,Y)</td>
<td>返回x的y次方</td>
</tr>
<tr>
<td>EXP(X)</td>
<td>返回e的X次方，其中e是一个常数，2.718281828459045</td>
</tr>
<tr>
<td>LN(X)，LOG(X)</td>
<td>返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG10(X)</td>
<td>返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG2(X)</td>
<td>返回以2为底的X的对数，当X &lt;= 0 时，返回NULL</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4)</span><br><span class="line">    -&gt; FROM DUAL;</span><br><span class="line">+----------+------------+------------------+-------------------+-----------+---------+</span><br><span class="line">| POW(2,5) | POWER(2,4) | EXP(2)           | LN(10)            | LOG10(10) | LOG2(4) |</span><br><span class="line">+----------+------------+------------------+-------------------+-----------+---------+</span><br><span class="line">|       32 |         16 | 7.38905609893065 | 2.302585092994046 |         1 |       2 |</span><br><span class="line">+----------+------------+------------------+-------------------+-----------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="进制间的转换"><a href="#进制间的转换" class="headerlink" title="进制间的转换"></a>进制间的转换</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>BIN(x)</td>
<td>返回x的二进制编码</td>
</tr>
<tr>
<td>HEX(x)</td>
<td>返回x的十六进制编码</td>
</tr>
<tr>
<td>OCT(x)</td>
<td>返回x的八进制编码</td>
</tr>
<tr>
<td>CONV(x,f1,f2)</td>
<td>返回f1进制数变成f2进制数</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8)</span><br><span class="line">    -&gt; FROM DUAL;</span><br><span class="line">+---------+---------+---------+--------------+</span><br><span class="line">| BIN(10) | HEX(10) | OCT(10) | CONV(10,2,8) |</span><br><span class="line">+---------+---------+---------+--------------+</span><br><span class="line">| 1010    | A       | 12      | 2            |</span><br><span class="line">+---------+---------+---------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII(S)</td>
<td>返回字符串S中的第一个字符的ASCII码值</td>
</tr>
<tr>
<td>CHAR_LENGTH(s)</td>
<td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td>
</tr>
<tr>
<td>LENGTH(s)</td>
<td>返回字符串s的字节数，和字符集有关</td>
</tr>
<tr>
<td>CONCAT(s1,s2,……,sn)</td>
<td>连接s1,s2,……,sn为一个字符串</td>
</tr>
<tr>
<td>CONCAT_WS(x, s1,s2,……,sn)</td>
<td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td>
</tr>
<tr>
<td>INSERT(str, idx, len, replacestr)</td>
<td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td>
</tr>
<tr>
<td>REPLACE(str, a, b)</td>
<td>用字符串b替换字符串str中所有出现的字符串a</td>
</tr>
<tr>
<td>UPPER(s) 或 UCASE(s)</td>
<td>将字符串s的所有字母转成大写字母</td>
</tr>
<tr>
<td>LOWER(s)  或LCASE(s)</td>
<td>将字符串s的所有字母转成小写字母</td>
</tr>
<tr>
<td>LEFT(str,n)</td>
<td>返回字符串str最左边的n个字符</td>
</tr>
<tr>
<td>RIGHT(str,n)</td>
<td>返回字符串str最右边的n个字符</td>
</tr>
<tr>
<td>LPAD(str, len, pad)</td>
<td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td>
</tr>
<tr>
<td>RPAD(str ,len, pad)</td>
<td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td>
</tr>
<tr>
<td>LTRIM(s)</td>
<td>去掉字符串s左侧的空格</td>
</tr>
<tr>
<td>RTRIM(s)</td>
<td>去掉字符串s右侧的空格</td>
</tr>
<tr>
<td>TRIM(s)</td>
<td>去掉字符串s开始与结尾的空格</td>
</tr>
<tr>
<td>TRIM(s1 FROM s)</td>
<td>去掉字符串s开始与结尾的s1</td>
</tr>
<tr>
<td>TRIM(LEADING s1 FROM s)</td>
<td>去掉字符串s开始处的s1</td>
</tr>
<tr>
<td>TRIM(TRAILING s1 FROM s)</td>
<td>去掉字符串s结尾处的s1</td>
</tr>
<tr>
<td>REPEAT(str, n)</td>
<td>返回str重复n次的结果</td>
</tr>
<tr>
<td>SPACE(n)</td>
<td>返回n个空格</td>
</tr>
<tr>
<td>STRCMP(s1,s2)</td>
<td>比较字符串s1,s2的ASCII码值的大小</td>
</tr>
<tr>
<td>SUBSTR(s,index,len)</td>
<td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同</td>
</tr>
<tr>
<td>LOCATE(substr,str)</td>
<td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td>
</tr>
<tr>
<td>ELT(m,s1,s2,…,sn)</td>
<td>返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn</td>
</tr>
<tr>
<td>FIELD(s,s1,s2,…,sn)</td>
<td>返回字符串s在字符串列表中第一次出现的位置</td>
</tr>
<tr>
<td>FIND_IN_SET(s1,s2)</td>
<td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td>
</tr>
<tr>
<td>REVERSE(s)</td>
<td>返回s反转后的字符串</td>
</tr>
<tr>
<td>NULLIF(value1,value2)</td>
<td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：MySQL中，字符串的位置是从1开始的。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT FIELD(&#39;mm&#39;,&#39;hello&#39;,&#39;msm&#39;,&#39;amma&#39;),FIND_IN_SET(&#39;mm&#39;,&#39;hello,mm,amma&#39;)</span><br><span class="line">    -&gt; FROM DUAL;</span><br><span class="line">+----------------------------------+-----------------------------------+</span><br><span class="line">| FIELD(&#39;mm&#39;,&#39;hello&#39;,&#39;msm&#39;,&#39;amma&#39;) | FIND_IN_SET(&#39;mm&#39;,&#39;hello,mm,amma&#39;) |</span><br><span class="line">+----------------------------------+-----------------------------------+</span><br><span class="line">|                                0 |                                 2 |</span><br><span class="line">+----------------------------------+-----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NULLIF(&#39;mysql&#39;,&#39;mysql&#39;),NULLIF(&#39;mysql&#39;, &#39;&#39;);</span><br><span class="line">+-------------------------+---------------------+</span><br><span class="line">| NULLIF(&#39;mysql&#39;,&#39;mysql&#39;) | NULLIF(&#39;mysql&#39;, &#39;&#39;) |</span><br><span class="line">+-------------------------+---------------------+</span><br><span class="line">| NULL                    | mysql               |</span><br><span class="line">+-------------------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="日期与时间戳的转换"><a href="#日期与时间戳的转换" class="headerlink" title="日期与时间戳的转换"></a>日期与时间戳的转换</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>UNIX_TIMESTAMP()</td>
<td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884</td>
</tr>
<tr>
<td>UNIX_TIMESTAMP(date)</td>
<td>将时间date以UNIX时间戳的形式返回。</td>
</tr>
<tr>
<td>FROM_UNIXTIME(timestamp)</td>
<td>将UNIX时间戳的时间转换为普通格式的时间</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(now());</span><br><span class="line">+-----------------------+</span><br><span class="line">| UNIX_TIMESTAMP(now()) |</span><br><span class="line">+-----------------------+</span><br><span class="line">|            1576380910 |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(CURDATE());</span><br><span class="line">+---------------------------+</span><br><span class="line">| UNIX_TIMESTAMP(CURDATE()) |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                1576339200 |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(CURTIME());</span><br><span class="line">+---------------------------+</span><br><span class="line">| UNIX_TIMESTAMP(CURTIME()) |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                1576380969 |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(&#39;2011-11-11 11:11:11&#39;)</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| UNIX_TIMESTAMP(&#39;2011-11-11 11:11:11&#39;) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                            1320981071 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT FROM_UNIXTIME(1576380910);</span><br><span class="line">+---------------------------+</span><br><span class="line">| FROM_UNIXTIME(1576380910) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| 2019-12-15 11:35:10       |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="获取月份、星期、星期数、天数等函数"><a href="#获取月份、星期、星期数、天数等函数" class="headerlink" title="获取月份、星期、星期数、天数等函数"></a>获取月份、星期、星期数、天数等函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR(date) / MONTH(date) / DAY(date)</td>
<td>返回具体的日期值</td>
</tr>
<tr>
<td>HOUR(time) / MINUTE(time) / SECOND(time)</td>
<td>返回具体的时间值</td>
</tr>
<tr>
<td>MONTHNAME(date)</td>
<td>返回月份：January，…</td>
</tr>
<tr>
<td>DAYNAME(date)</td>
<td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td>
</tr>
<tr>
<td>WEEKDAY(date)</td>
<td>返回周几，注意，周1是0，周2是1，。。。周日是6</td>
</tr>
<tr>
<td>QUARTER(date)</td>
<td>返回日期对应的季度，范围为1～4</td>
</tr>
<tr>
<td>WEEK(date) ， WEEKOFYEAR(date)</td>
<td>返回一年中的第几周</td>
</tr>
<tr>
<td>DAYOFYEAR(date)</td>
<td>返回日期是一年中的第几天</td>
</tr>
<tr>
<td>DAYOFMONTH(date)</td>
<td>返回日期位于所在月份的第几天</td>
</tr>
<tr>
<td>DAYOFWEEK(date)</td>
<td>返回周几，注意：周日是1，周一是2，。。。周六是7</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),</span><br><span class="line">HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE())</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="日期的操作函数"><a href="#日期的操作函数" class="headerlink" title="日期的操作函数"></a>日期的操作函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>EXTRACT(type FROM date)</td>
<td>返回指定日期中特定的部分，type指定返回的值</td>
</tr>
</tbody></table>
<p>EXTRACT(type FROM date)函数中type的取值与含义：</p>
<table>
<thead>
<tr>
<th>type取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MICROSECOND</td>
<td>返回毫秒数</td>
</tr>
<tr>
<td>SECOND</td>
<td>返回秒数</td>
</tr>
<tr>
<td>MINUTE</td>
<td>返回分钟数</td>
</tr>
<tr>
<td>HOUR</td>
<td>返回小时数</td>
</tr>
<tr>
<td>DAY</td>
<td>返回大数</td>
</tr>
<tr>
<td>WEEK</td>
<td>返回口期在一年中的第儿个星期</td>
</tr>
<tr>
<td>MONTH</td>
<td>返回日期在一年中的第几个月</td>
</tr>
<tr>
<td>QUARTER</td>
<td>返回日期在一年中的第几个季度</td>
</tr>
<tr>
<td>YEAR</td>
<td>返回日期的年份</td>
</tr>
<tr>
<td>SECOND MICROSECOND</td>
<td>返回秒和毫秒值</td>
</tr>
<tr>
<td>MINUTE MICROSECOND</td>
<td>返回分钟和毫秒值</td>
</tr>
<tr>
<td>MINUTE SECOND</td>
<td>返回分钟和秒值</td>
</tr>
<tr>
<td>HOUR MICROSECOND</td>
<td>返回小时和毫秒值</td>
</tr>
<tr>
<td>HOUR SECOND</td>
<td>返回小时和秒值</td>
</tr>
<tr>
<td>HOUR MINUTE</td>
<td>返回小时和分钟值</td>
</tr>
<tr>
<td>DAY MICROSECOND</td>
<td>返回天和毫秒值</td>
</tr>
<tr>
<td>DAY SECOND</td>
<td>返回天和秒值</td>
</tr>
<tr>
<td>DAY MINUTE</td>
<td>返回天和分钟值</td>
</tr>
<tr>
<td>DAY HOUR</td>
<td>返回天和小时</td>
</tr>
<tr>
<td>YEAR MONTH</td>
<td>返回年和月</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(<span class="keyword">MINUTE</span> <span class="keyword">FROM</span> <span class="keyword">NOW</span>()),<span class="keyword">EXTRACT</span>( <span class="keyword">WEEK</span> <span class="keyword">FROM</span> <span class="keyword">NOW</span>()),</span><br><span class="line"><span class="keyword">EXTRACT</span>( <span class="keyword">QUARTER</span> <span class="keyword">FROM</span> <span class="keyword">NOW</span>()),<span class="keyword">EXTRACT</span>( MINUTE_SECOND <span class="keyword">FROM</span> <span class="keyword">NOW</span>())</span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="时间和秒钟转换的函数"><a href="#时间和秒钟转换的函数" class="headerlink" title="时间和秒钟转换的函数"></a>时间和秒钟转换的函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>TIME_TO_SEC(time)</td>
<td>将 time 转化为秒并返回结果值。转化的公式为：<code>小时*3600+分钟*60+秒</code></td>
</tr>
<tr>
<td>SEC_TO_TIME(seconds)</td>
<td>将 seconds 描述转化为包含小时、分钟和秒的时间</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT TIME_TO_SEC(NOW());</span><br><span class="line">+--------------------+</span><br><span class="line">| TIME_TO_SEC(NOW()) |</span><br><span class="line">+--------------------+</span><br><span class="line">|               78774 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SEC_TO_TIME(78774);</span><br><span class="line">+--------------------+</span><br><span class="line">| SEC_TO_TIME(78774) |</span><br><span class="line">+--------------------+</span><br><span class="line">| 21:52:54            |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.12 sec)</span><br></pre></td></tr></table></figure>

<h3 id="计算日期和时间的函数"><a href="#计算日期和时间的函数" class="headerlink" title="计算日期和时间的函数"></a>计算日期和时间的函数</h3><p><strong>第1组：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_ADD(datetime, INTERVAL  expr type)，ADDDATE(date,INTERVAL expr type)</td>
<td>返回与给定日期时间相差INTERVAL时间段的日期时间</td>
</tr>
<tr>
<td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td>
<td>返回与date相差INTERVAL时间间隔的日期</td>
</tr>
</tbody></table>
<p>上述函数中type的取值：</p>
<table>
<thead>
<tr>
<th>间隔类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>HOUR</td>
<td>小时</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分钟</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月</td>
</tr>
<tr>
<td>DAY</td>
<td>日</td>
</tr>
<tr>
<td>YEAR MONTH</td>
<td>年和月</td>
</tr>
<tr>
<td>DAY HOUR</td>
<td>日和小时</td>
</tr>
<tr>
<td>DAY MINUTE</td>
<td>日和分钟</td>
</tr>
<tr>
<td>DAY SECOND</td>
<td>日和秒</td>
</tr>
<tr>
<td>HOUR MINUTE</td>
<td>小时和分钟</td>
</tr>
<tr>
<td>HOUR SECOND</td>
<td>小时和秒</td>
</tr>
<tr>
<td>MINUTE SECOND</td>
<td>分钟和秒</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD(&#39;2021-10-21 23:32:12&#39;,INTERVAL 1 SECOND) AS col2,</span><br><span class="line">ADDDATE(&#39;2021-10-21 23:32:12&#39;,INTERVAL 1 SECOND) AS col3,</span><br><span class="line">DATE_ADD(&#39;2021-10-21 23:32:12&#39;,INTERVAL &#39;1_1&#39; MINUTE_SECOND) AS col4,</span><br><span class="line">DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数</span><br><span class="line">DATE_ADD(NOW(), INTERVAL &#39;1_1&#39; YEAR_MONTH) AS col6 #需要单引号</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_SUB(&#39;2021-01-21&#39;,INTERVAL 31 DAY) AS col1,</span><br><span class="line">SUBDATE(&#39;2021-01-21&#39;,INTERVAL 31 DAY) AS col2,</span><br><span class="line">DATE_SUB(&#39;2021-01-21 02:01:01&#39;,INTERVAL &#39;1 1&#39; DAY_HOUR) AS col3</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><strong>第2组：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ADDTIME(time1,time2)</td>
<td>返回time1加上time2的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td>
</tr>
<tr>
<td>SUBTIME(time1,time2)</td>
<td>返回time1减去time2后的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回date1 - date2的日期间隔天数</td>
</tr>
<tr>
<td>TIMEDIFF(time1, time2)</td>
<td>返回time1 - time2的时间间隔</td>
</tr>
<tr>
<td>FROM_DAYS(N)</td>
<td>返回从0000年1月1日起，N天以后的日期</td>
</tr>
<tr>
<td>TO_DAYS(date)</td>
<td>返回日期date距离0000年1月1日的天数</td>
</tr>
<tr>
<td>LAST_DAY(date)</td>
<td>返回date所在月份的最后一天的日期</td>
</tr>
<tr>
<td>MAKEDATE(year,n)</td>
<td>针对给定年份与所在年份中的天数返回一个日期</td>
</tr>
<tr>
<td>MAKETIME(hour,minute,second)</td>
<td>将给定的小时、分钟和秒组合成时间并返回</td>
</tr>
<tr>
<td>PERIOD_ADD(time,n)</td>
<td>返回time加上n后的时间</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ADDTIME</span>(<span class="keyword">NOW</span>(),<span class="number">20</span>),<span class="keyword">SUBTIME</span>(<span class="keyword">NOW</span>(),<span class="number">30</span>),<span class="keyword">SUBTIME</span>(<span class="keyword">NOW</span>(),<span class="string">&#x27;1:1:3&#x27;</span>),<span class="keyword">DATEDIFF</span>(<span class="keyword">NOW</span>(),<span class="string">&#x27;2021-10-01&#x27;</span>),</span><br><span class="line"><span class="keyword">TIMEDIFF</span>(<span class="keyword">NOW</span>(),<span class="string">&#x27;2021-10-25 22:10:10&#x27;</span>),<span class="keyword">FROM_DAYS</span>(<span class="number">366</span>),<span class="keyword">TO_DAYS</span>(<span class="string">&#x27;0000-12-25&#x27;</span>),</span><br><span class="line"><span class="keyword">LAST_DAY</span>(<span class="keyword">NOW</span>()),<span class="keyword">MAKEDATE</span>(<span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()),<span class="number">12</span>),<span class="keyword">MAKETIME</span>(<span class="number">10</span>,<span class="number">21</span>,<span class="number">23</span>),<span class="keyword">PERIOD_ADD</span>(<span class="number">20200101010101</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="日期的格式化与解析"><a href="#日期的格式化与解析" class="headerlink" title="日期的格式化与解析"></a>日期的格式化与解析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_FORMAT(date,fmt)</td>
<td>按照字符串fmt格式化日期date值</td>
</tr>
<tr>
<td>TIME_FORMAT(time,fmt)</td>
<td>按照字符串fmt格式化时间time值</td>
</tr>
<tr>
<td>GET_FORMAT(date_type,format_type)</td>
<td>返回日期字符串的显示格式</td>
</tr>
<tr>
<td>STR_TO_DATE(str, fmt)</td>
<td>按照字符串fmt对str进行解析，解析为一个日期</td>
</tr>
</tbody></table>
<p>上述<code>非GET_FORMAT</code>函数中fmt参数常用的格式符：</p>
<table>
<thead>
<tr>
<th>格式符</th>
<th>说明</th>
<th>格式符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%Y</td>
<td>4位数字表示年份</td>
<td>%y</td>
<td>表示两位数字表示年份</td>
</tr>
<tr>
<td>%M</td>
<td>月名表示月份（January,….）</td>
<td>%m</td>
<td>两位数字表示月份（01,02,03。。。）</td>
</tr>
<tr>
<td>%b</td>
<td>缩写的月名（Jan.，Feb.，….）</td>
<td>%c</td>
<td>数字表示月份（1,2,3,…）</td>
</tr>
<tr>
<td>%D</td>
<td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td>
<td>%d</td>
<td>两位数字表示月中的天数(01,02…)</td>
</tr>
<tr>
<td>%e</td>
<td>数字形式表示月中的天数（1,2,3,4,5…..）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>两位数字表示小数，24小时制（01,02..）</td>
<td>%h和%I</td>
<td>两位数字表示小时，12小时制（01,02..）</td>
</tr>
<tr>
<td>%k</td>
<td>数字形式的小时，24小时制(1,2,3)</td>
<td>%l</td>
<td>数字形式表示小时，12小时制（1,2,3,4….）</td>
</tr>
<tr>
<td>%i</td>
<td>两位数字表示分钟（00,01,02）</td>
<td>%S和%s</td>
<td>两位数字表示秒(00,01,02…)</td>
</tr>
<tr>
<td>%W</td>
<td>一周中的星期名称（Sunday…）</td>
<td>%a</td>
<td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td>
</tr>
<tr>
<td>%w</td>
<td>以数字表示周中的天数(0=Sunday,1=Monday….)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%j</td>
<td>以3位数字表示年中的天数(001,002…)</td>
<td>%U</td>
<td>以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天</td>
</tr>
<tr>
<td>%u</td>
<td>以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%T</td>
<td>24小时制</td>
<td>%r</td>
<td>12小时制</td>
</tr>
<tr>
<td>%p</td>
<td>AM或PM</td>
<td>%%</td>
<td>表示%</td>
</tr>
</tbody></table>
<p>GET_FORMAT函数中date_type和format_type参数取值如下：</p>
<table>
<thead>
<tr>
<th>日期类型</th>
<th>格式化类型</th>
<th>返回的格式化字符串</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>USA</td>
<td>%m.%d.%Y</td>
</tr>
<tr>
<td>DATE</td>
<td>JIS</td>
<td>%Y-%m-%d</td>
</tr>
<tr>
<td>DATE</td>
<td>ISO</td>
<td>%Y-%m-%d</td>
</tr>
<tr>
<td>DATE</td>
<td>EUR</td>
<td>%d.%m.%Y</td>
</tr>
<tr>
<td>DATE</td>
<td>INTERNAL</td>
<td>%Y%m%d</td>
</tr>
<tr>
<td>TIME</td>
<td>USA</td>
<td>%h:%i:%s %p</td>
</tr>
<tr>
<td>TIME</td>
<td>JIS</td>
<td>%H:%i:%s</td>
</tr>
<tr>
<td>TIME</td>
<td>ISO</td>
<td>%H:%i:%s</td>
</tr>
<tr>
<td>TIME</td>
<td>EUR</td>
<td>%H.%i.%s</td>
</tr>
<tr>
<td>TIME</td>
<td>INTERNAL</td>
<td>%H%i%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>USA</td>
<td>%Y-%m-%d %H.%i.%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>JIS</td>
<td>%Y-%m-%d %H:%i:%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>ISO</td>
<td>%Y-%m-%d %H:%i:%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>EUR</td>
<td>%Y-%m-%d %I-L%i.%s</td>
</tr>
<tr>
<td>DATETIME</td>
<td>INTERNAL</td>
<td>%Y%m%d%H%i%s</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT DATE_FORMAT(NOW(), &#39;%H:%i:%s&#39;);</span><br><span class="line">+--------------------------------+</span><br><span class="line">| DATE_FORMAT(NOW(), &#39;%H:%i:%s&#39;) |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| 22:57:34                        |</span><br><span class="line">+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&#39;09&#x2F;01&#x2F;2009&#39;,&#39;%m&#x2F;%d&#x2F;%Y&#39;)</span><br><span class="line">FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT STR_TO_DATE(&#39;20140422154706&#39;,&#39;%Y%m%d%H%i%s&#39;)</span><br><span class="line">FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT STR_TO_DATE(&#39;2014-04-22 15:47:06&#39;,&#39;%Y-%m-%d %H:%i:%s&#39;)</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT GET_FORMAT(DATE, &#39;USA&#39;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| GET_FORMAT(DATE, &#39;USA&#39;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">| %m.%d.%Y                |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">SELECT DATE_FORMAT(NOW(),GET_FORMAT(DATE,&#39;USA&#39;)),</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT STR_TO_DATE(&#39;2020-01-01 00:00:00&#39;,&#39;%Y-%m-%d&#39;); </span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">| STR_TO_DATE(&#39;2020-01-01 00:00:00&#39;,&#39;%Y-%m-%d&#39;) |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">| 2020-01-01                                    |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value,value1,value2)</td>
<td>如果value的值为TRUE，返回value1，否则返回value2</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为NULL，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END</td>
<td>相当于Java的if…else if…else…</td>
</tr>
<tr>
<td>CASE  expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td>
<td>相当于Java的switch…case…</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT IF(1 &gt; 0,&#39;正确&#39;,&#39;错误&#39;)    </span><br><span class="line">-&gt;正确</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT IFNULL(null,&#39;Hello Word&#39;)</span><br><span class="line">-&gt;Hello Word</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT CASE </span><br><span class="line">　　WHEN 1 &gt; 0</span><br><span class="line">　　THEN &#39;1 &gt; 0&#39;</span><br><span class="line">　　WHEN 2 &gt; 0</span><br><span class="line">　　THEN &#39;2 &gt; 0&#39;</span><br><span class="line">　　ELSE &#39;3 &gt; 0&#39;</span><br><span class="line">　　END</span><br><span class="line">-&gt;1 &gt; 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT CASE 1 </span><br><span class="line">　　WHEN 1 THEN &#39;我是1&#39;</span><br><span class="line">　　WHEN 2 THEN &#39;我是2&#39;</span><br><span class="line">ELSE &#39;你是谁&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,salary, CASE WHEN salary&gt;&#x3D;15000 THEN &#39;高薪&#39; </span><br><span class="line">				  WHEN salary&gt;&#x3D;10000 THEN &#39;潜力股&#39;  </span><br><span class="line">				  WHEN salary&gt;&#x3D;8000 THEN &#39;屌丝&#39; </span><br><span class="line">				  ELSE &#39;草根&#39; END  &quot;描述&quot;</span><br><span class="line">FROM employees; </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT oid,&#96;status&#96;, CASE &#96;status&#96; WHEN 1 THEN &#39;未付款&#39; </span><br><span class="line">								   WHEN 2 THEN &#39;已付款&#39; </span><br><span class="line">								   WHEN 3 THEN &#39;已发货&#39;  </span><br><span class="line">								   WHEN 4 THEN &#39;确认收货&#39;  </span><br><span class="line">								   ELSE &#39;无效订单&#39; END </span><br><span class="line">FROM t_order;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, job_id, salary,</span><br><span class="line">       CASE job_id WHEN &#39;IT_PROG&#39;  THEN  1.10*salary</span><br><span class="line">                   WHEN &#39;ST_CLERK&#39; THEN  1.15*salary</span><br><span class="line">                   WHEN &#39;SA_REP&#39;   THEN  1.20*salary</span><br><span class="line">       			   ELSE      salary END     &quot;REVISED_SALARY&quot;</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="加密与解密函数"><a href="#加密与解密函数" class="headerlink" title="加密与解密函数"></a>加密与解密函数</h2><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>PASSWORD(str)</td>
<td>返回字符串str的加密版本，41位长的字符串。加密结果<code>不可逆</code>，常用于用户的密码加密</td>
</tr>
<tr>
<td>MD5(str)</td>
<td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL</td>
</tr>
<tr>
<td>SHA(str)</td>
<td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。<code>SHA加密算法比MD5更加安全</code>。</td>
</tr>
<tr>
<td>ENCODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码加密value</td>
</tr>
<tr>
<td>DECODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码解密value</td>
</tr>
</tbody></table>
<p>可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT PASSWORD(&#39;mysql&#39;), PASSWORD(NULL);</span><br><span class="line">+-------------------------------------------+----------------+</span><br><span class="line">| PASSWORD(&#39;mysql&#39;)                         | PASSWORD(NULL) |</span><br><span class="line">+-------------------------------------------+----------------+</span><br><span class="line">| *E74858DB86EBA20BC33D0AECAE8A8108C56B17FA |                |</span><br><span class="line">+-------------------------------------------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT md5(&#39;123&#39;)</span><br><span class="line">-&gt;202cb962ac59075b964b07152d234b70</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SHA(&#39;Tom123&#39;)</span><br><span class="line">-&gt;c7c506980abc31cc390a2438c90861d0f1216d50</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT ENCODE(&#39;mysql&#39;, &#39;mysql&#39;);</span><br><span class="line">+--------------------------+</span><br><span class="line">| ENCODE(&#39;mysql&#39;, &#39;mysql&#39;) |</span><br><span class="line">+--------------------------+</span><br><span class="line">| íg　¼　ìÉ                  |</span><br><span class="line">+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT DECODE(ENCODE(&#39;mysql&#39;,&#39;mysql&#39;),&#39;mysql&#39;);</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| DECODE(ENCODE(&#39;mysql&#39;,&#39;mysql&#39;),&#39;mysql&#39;) |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| mysql                                   |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="MySQL信息函数"><a href="#MySQL信息函数" class="headerlink" title="MySQL信息函数"></a>MySQL信息函数</h2><p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>VERSION()</td>
<td>返回当前MySQL的版本号</td>
</tr>
<tr>
<td>CONNECTION_ID()</td>
<td>返回当前MySQL服务器的连接数</td>
</tr>
<tr>
<td>DATABASE()，SCHEMA()</td>
<td>返回MySQL命令行当前所在的数据库</td>
</tr>
<tr>
<td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td>
<td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td>
</tr>
<tr>
<td>CHARSET(value)</td>
<td>返回字符串value自变量的字符集</td>
</tr>
<tr>
<td>COLLATION(value)</td>
<td>返回字符串value的比较规则</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER();</span><br><span class="line">+<span class="comment">----------------+----------------+----------------+----------------+</span></span><br><span class="line">| USER()         | CURRENT_USER() | SYSTEM_USER()  | SESSION_USER() |</span><br><span class="line">+<span class="comment">----------------+----------------+----------------+----------------+</span></span><br><span class="line">| root@localhost | root@localhost | root@localhost | root@localhost |</span><br><span class="line">+<span class="comment">----------------+----------------+----------------+----------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>FORMAT(value,n)</td>
<td>返回对数字value进行格式化后的结果数据。n表示<code>四舍五入</code>后保留到小数点后n位</td>
</tr>
<tr>
<td>CONV(value,from,to)</td>
<td>将value的值进行不同进制之间的转换</td>
</tr>
<tr>
<td>INET_ATON(ipvalue)</td>
<td>将以点分隔的IP地址转化为一个数字</td>
</tr>
<tr>
<td>INET_NTOA(value)</td>
<td>将数字形式的IP地址转化为以点分隔的IP地址</td>
</tr>
<tr>
<td>BENCHMARK(n,expr)</td>
<td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td>
</tr>
<tr>
<td>CONVERT(value USING char_code)</td>
<td>将value所使用的字符编码修改为char_code</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/23/Java-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/23/Java-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">深入浅出 Java 8 Lambda 表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-23 19:01:50" itemprop="dateCreated datePublished" datetime="2021-10-23T19:01:50+08:00">2021-10-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-24 19:14:19" itemprop="dateModified" datetime="2021-10-24T19:14:19+08:00">2021-10-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。</p>
<p>这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。</p>
<p>在写回调函数和事件处理器时，程序员不必再纠缠于匿名内部类的冗繁和可读性，函数式编程让事件处理系统变得更加简单。能将函数方便地传递也让编写惰性代码变得容易，只有在真正需要的时候，才初始化变量的值。</p>
<p>Java <em>Lambda表达式</em>的一个重要用法是简化某些<em>匿名内部类</em>（<code>Anonymous Classes</code>）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过<em>invokedynamic</em>指令来实现Lambda表达式的。</p>
<p>Lambda表达式（也称闭包），是Java8中最受期待和欢迎的新特性之一。Lambda表达式本质是一个匿名函数，但是它并不是匿名类的语法糖，它让 Java 开始走向函数式编程，其实现原理区别于一般的匿名类中的匿名函数。在Java语法层面Lambda表达式允许函数作为一个方法的参数（函数作为参数传递到方法中），或者把代码看成数据。Lambda表达式可以简化函数式接口的使用。函数式接口就是一个只有一个抽象方法的普通接口，像这样的接口就可以使用Lambda表达式来简化代码的编写。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda 表达式为 Java 添加了缺失的函数式编程特点，使我们能将函数当做一等公民看待。尽管不完全正确，我们很快就会见识到 Lambda 与闭包的不同之处，但是又无限地接近闭包。在支持一类函数的语言中，Lambda 表达式的类型将是函数。但是，在 Java 中，Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。函数式接口在java中是指:<strong>有且仅有一个抽象方法的接口</strong>，<strong>只有函数式接口，才可以转换为lambda表达式</strong>，<strong>函数式接口可以显式的被@FunctionalInterface所表示，当被标识的接口不满足规定时，编译器会提示报错</strong>。我们会在后文详细介绍函数式接口。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/java-lambda-expression.png"></p>
<p>在认识Lambda表达式基础语法之前，先来看一段用两种方式创建线程的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Hello!&quot;</span>)).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/javalambdaexpression.png"></p>
<p>Lambda 表达式的基础语法：Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符</p>
<p>箭头操作符将 Lambda 表达式拆分成两部分：</p>
<p>左侧：Lambda 表达式的参数列表</p>
<p>右侧：Lambda 表达式中所需实现的功能， 即 Lambda 体</p>
<p>Java 中的 Lambda 表达式通常使用 <code>(argument) -&gt; (body)</code> 语法书写，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class="line"></span><br><span class="line">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>

<p>以下是一些 Lambda 表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h1><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。</p>
<p><span style="color:red"><code>java.lang.Runnable</code> </span>就是一种函数式接口，在 Runnable 接口中只声明了一个方法<span style="color:red"> <code>void run()</code></span>，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</p>
<p>每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当不指明函数式接口时，编译器会自动解释这种转化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">   () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 <span style="color:red"><code>public Thread(Runnable r) &#123; &#125;</code></span>，将该 Lambda 表达式赋给 Runnable 接口。</p>
<p>以下是一些 Lambda 表达式及其函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt;  c = (<span class="keyword">int</span> x) -&gt; &#123; System.out.println(x) &#125;;</span><br><span class="line"></span><br><span class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="string">&quot; : &quot;</span> + y);</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == <span class="keyword">null</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html">@FunctionalInterface</a> 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p>
<p>以下是一种自定义的函数式接口： @FunctionalInterface public interface WorkerInterface {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeMoreWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unexpected <span class="meta">@FunctionalInterface</span> annotation </span><br><span class="line">    <span class="meta">@FunctionalInterface</span> ^ WorkerInterface is not a functional <span class="class"><span class="keyword">interface</span> <span class="title">multiple</span> </span></span><br><span class="line"><span class="class">    <span class="title">non</span>-<span class="title">overriding</span> <span class="title">abstract</span> <span class="title">methods</span> <span class="title">found</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">WorkerInterface</span> 1 <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>函数式接口定义好后，我们可以在 API 中使用它，同时利用 Lambda 表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义一个函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(WorkerInterface worker)</span> </span>&#123;</span><br><span class="line">    worker.doSomeWork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke doSomeWork using Annonymous class</span></span><br><span class="line">    execute(<span class="keyword">new</span> WorkerInterface() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Worker invoked using Anonymous class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke doSomeWork using Lambda expression </span></span><br><span class="line">    execute( () -&gt; System.out.println(<span class="string">&quot;Worker invoked using Lambda expression&quot;</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker invoked using Anonymous <span class="class"><span class="keyword">class</span> </span></span><br><span class="line"><span class="class"><span class="title">Worker</span> <span class="title">invoked</span> <span class="title">using</span> <span class="title">Lambda</span> <span class="title">expression</span></span></span><br></pre></td></tr></table></figure>

<p>这上面的例子里，我们创建了自定义的函数式接口并与 Lambda 表达式一起使用。execute() 方法现在可以将 Lambda 表达式作为参数。</p>
<h1 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h1><p>让我们了解一下 Lambda 表达式的结构。</p>
<ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：<code>a -&gt; return a*a</code></li>
<li>当参数大于一个时，所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li>
<li>空圆括号代表没有参数。例如：<code>() -&gt; 42</code></li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略，如果Lambda体不加{ }就不用写return。</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）Lambda体加上{ }就需要添加return。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h1 id="Lambda表达式和内部类区别一"><a href="#Lambda表达式和内部类区别一" class="headerlink" title="Lambda表达式和内部类区别一"></a>Lambda表达式和内部类区别一</h1><p>读过上一篇之后，相信对Lambda表达式的语法以及基本原理有了一定了解。对于编写代码，有这些知识已经够用。本文将进一步区分Lambda表达式和匿名内部类在JVM层面的区别。</p>
<p>经过第一篇的的介绍，我们看到Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。</p>
<h3 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h3><p><strong>匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名</strong>。因此如果有如下形式的代码，编译之后将会产生两个class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Anonymous Class Thread run()&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后文件分布如下，两个class文件分别是主类和匿名内部类产生的：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/2-AnonymousClass.png"></p>
<p>进一步分析主类MainAnonymousClass.class的字节码，可发现其创建了匿名内部类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javap -c MainAnonymousClass.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/lang/Thread</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: new           #3                  // class MainAnonymousClass$1 /*创建内部类对象*/</span><br><span class="line">       <span class="number">7</span>: dup</span><br><span class="line">       8: invokespecial #4                  // Method MainAnonymousClass$1.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      11: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br><span class="line">      14: invokevirtual #6                  // Method java/lang/Thread.start:()V</span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式实现"><a href="#Lambda表达式实现" class="headerlink" title="Lambda表达式实现"></a>Lambda表达式实现</h3><p><strong>Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类</strong>。如果有如下代码，编译之后只有一个class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(</span><br><span class="line">				() -&gt; System.out.println(<span class="string">&quot;Lambda Thread run()&quot;</span>)</span><br><span class="line">			).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后的结果：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/2-Lambda.png"></p>
<p>通过javap反编译命名，我们更能看出Lambda表达式内部表示的不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; javap -c -p MainLambda.class</span><br><span class="line">public class MainLambda &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Thread</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:run:()Ljava&#x2F;lang&#x2F;Runnable; &#x2F;*使用invokedynamic指令调用*&#x2F;</span><br><span class="line">       9: invokespecial #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line">      12: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.start:()V</span><br><span class="line">      15: return</span><br><span class="line"></span><br><span class="line">  private static void lambda$main$0();  &#x2F;*Lambda表达式被封装成主类的私有方法*&#x2F;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       3: ldc           #7                  &#x2F;&#x2F; String Lambda Thread run()</span><br><span class="line">       5: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法，并通过<em>invokedynamic</em>指令进行调用。</p>
<p>它没有创建将包装 Lambda 函数的新对象，而是使用Java 7 中添加的新<em>invokeDynamic</em>指令将此调用站点动态链接到实际的 Lambda 函数。</p>
<blockquote>
<p>看到 Java，最“严格”的现代语言现在如何使用动态链接来支持其新的 Lambda 表达式，真是令人着迷。这也是一种有效的方法，因为不需要额外的类加载和编译——Lambda 方法只是我们类中的另一个私有方法。</p>
</blockquote>
<hr>
<h1 id="Lambda表达式和内部类区别二"><a href="#Lambda表达式和内部类区别二" class="headerlink" title="Lambda表达式和内部类区别二"></a>Lambda表达式和内部类区别二</h1><p>尽管在实际开发中基本上用 lambda 表达式替换了内部类，但这两个概念在一个重要方面是不同的：作用域。</p>
<p>既然Lambda表达式不是内部类的简写，那么Lambda内部的<code>this</code>引用也就跟内部类对象没什么关系了。在Lambda表达式中<code>this</code>的意义跟在表达式外部完全一样。因此下列代码将输出两遍<code>Hello Hoolee</code>，而不是两个引用地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	Runnable r1 = () -&gt; &#123; System.out.println(<span class="keyword">this</span>); &#125;;</span><br><span class="line">	Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Hello().r1.run();</span><br><span class="line">		<span class="keyword">new</span> Hello().r2.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello Hoolee&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于匿名类，关键词 <code>this</code> 解读为匿名类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    String name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name); <span class="comment">//zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lambda-and-Collections"><a href="#Lambda-and-Collections" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h1><p>我们先从最熟悉的*Java集合框架(Java Collections Framework, JCF)*开始说起。</p>
<p>为引入Lambda表达式，Java8新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。</p>
<p>首先回顾一下Java集合框架的接口继承结构：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/JCF_Collection_Interfaces.png"></p>
<p>上图中绿色标注的接口类，表示在Java8中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">Java8新加入的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collection</td>
<td align="left">removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">replaceAll() sort()</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody></table>
<p>这些新加入的方法大部分要用到<code>java.util.function</code>包下的接口，这意味着这些方法大部分都跟Lambda表达式相关。我们将逐一学习这些方法。</p>
<h3 id="Collection中的新方法"><a href="#Collection中的新方法" class="headerlink" title="Collection中的新方法"></a>Collection中的新方法</h3><p>如上所示，接口<code>Collection</code>和<code>List</code>新加入了一些方法，我们以是<code>List</code>的子类<code>ArrayList</code>为例来说明。了解<a target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md">Java7<code>ArrayList</code>实现原理</a>，将有助于理解下文。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>
<p>需求：<em>假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.</em></p>
<p>Java7及以前我们可以用增强的for循环实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用曾强for循环迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>
<h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h4><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>
<p>需求：<em>假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</em></p>
<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器删除列表元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(it.next().length()&gt;<span class="number">3</span>) <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;()&#123; <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.length()&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。</p>
<h4 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素</strong>。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>
<p>需求：<em>假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</em></p>
<p>Java7及之前似乎没有优雅的办法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用下标实现元素替换</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(<span class="keyword">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序</strong>。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>
<p>需求：<em>假设有一个字符串列表，按照字符串长度增序对元素排序。</em></p>
<p>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类中，所以代码要这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.sort()方法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.length()-str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在可以直接使用<code>List.sort()方法</code>，结合Lambda表达式，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>

<h4 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h4><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>
<ol>
<li><code>Spliterator</code>既可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>
<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>
</ol>
<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>
<h4 id="stream-和parallelStream"><a href="#stream-和parallelStream" class="headerlink" title="stream()和parallelStream()"></a>stream()和parallelStream()</h4><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回该容器的<code>Stream</code>视图表示</strong>，不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。**<code>Stream</code>是Java函数式编程的核心类**，我们会在后面章节中学习。</p>
<hr>
<h3 id="Map中的新方法"><a href="#Map中的新方法" class="headerlink" title="Map中的新方法"></a>Map中的新方法</h3><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。了解[Java7<code>HashMap</code>实现原理](<a target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet</a> and HashMap.md)，将有助于理解下文。</p>
<h4 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中的每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;=&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是**按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>**。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>
<p>需求；<em>假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="comment">// Java7以及之前做法</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">4</span>))&#123; <span class="comment">// 1</span></span><br><span class="line">    System.out.println(map.get(<span class="number">4</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;NoValue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8使用Map.getOrDefault()</span></span><br><span class="line">System.out.println(map.getOrDefault(<span class="number">4</span>, <span class="string">&quot;NoValue&quot;</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改．该方法将条件判断和赋值合二为一，使用起来更加方便．</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中**<code>key</code>正好映射到<code>value</code>时**才删除该映射，否则什么也不做．</p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>在Java7及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>
<ul>
<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在时**才用<code>value</code>去替换原来的值，否则什么也不做．</li>
<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在且等于<code>oldValue</code>时**才用<code>newValue</code>去替换原来的值，否则什么也不做．</li>
</ul>
<h4 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>简洁到让人难以置信．</p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>，作用是：</p>
<ol>
<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>
<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射．</li>
</ol>
<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>
<p><code>merge()</code>方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</span><br></pre></td></tr></table></figure>

<h4 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h4><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射．</p>
<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.compute(key, (k,v) -&gt; v==<span class="keyword">null</span> ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>

<h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h4><p>该方法签名为<code>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>，作用是：只有在当前<code>Map</code>中<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>
<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>
<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K,Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">&quot;yi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>
<h4 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h4><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前<code>Map</code>中<strong>存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>
<p>这个函数的功能跟如下代码是等效的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class="line"><span class="keyword">if</span> (map.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    V oldValue = map.get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>)</span><br><span class="line">        map.put(key, newValue);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        map.remove(key);</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>Java8为容器新增一些有用的方法，这些方法有些是为<strong>完善原有功能</strong>，有些是为<strong>引入函数式编程</strong>，学习和使用这些方法有助于我们写出更加简洁有效的代码．</li>
<li><strong>函数接口</strong>虽然很多，但绝大多数时候我们根本不需要知道它们的名字，书写Lambda表达式时类型推断帮我们做了一切．</li>
</ol>
<hr>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用（Method Reference）是用来直接访问类或者实例已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。</p>
<p>当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。</p>
<p>作用</p>
<ul>
<li>方法引用的唯一用途是支持Lambda的简写。</li>
<li>方法引用提高了代码的可读性，也使逻辑更加清晰。</li>
</ul>
<p>组成</p>
<ul>
<li>使用<code>::</code>操作符将方法名和对象或类的名字分隔开。<code>::</code>是域操作符（也可以称作定界符、分隔符）。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法引用</strong></th>
<th>等价的Lambda表达式</th>
</tr>
</thead>
<tbody><tr>
<td>String::valueOf</td>
<td>x -&gt; String.valueOf(x)</td>
</tr>
<tr>
<td>Object::toString</td>
<td>x -&gt; x.toString()</td>
</tr>
<tr>
<td>x::toString</td>
<td>() -&gt; x.toString()</td>
</tr>
<tr>
<td>ArrayList::new</td>
<td>() -&gt; new ArrayList&lt;&gt;()</td>
</tr>
</tbody></table>
<p>方法引用的类型归结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>ClassName::methodName</td>
</tr>
<tr>
<td>指定对象实例方法引用</td>
<td>instanceRef::methodName</td>
</tr>
<tr>
<td>特定类型任意对象方法引用</td>
<td>ContainingType::methodName</td>
</tr>
<tr>
<td>超类方法引用</td>
<td>supper::methodName</td>
</tr>
<tr>
<td>构造器方法引用</td>
<td>ClassName::new</td>
</tr>
<tr>
<td>数组构造器方法引用</td>
<td>TypeName[]::new</td>
</tr>
</tbody></table>
<p>可见其基本形式是：方法容器::方法名称或者关键字。</p>
<p>举一些基本的使用例子：</p>
<h2 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethodRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;String, Integer&gt; function = StaticMethodRef::staticMethod;</span><br><span class="line">        <span class="comment">// 等同于</span></span><br><span class="line">        <span class="comment">// Function&lt;String, Integer&gt; function1 = (String s) -&gt; StaticMethodRef.staticMethod(s);</span></span><br><span class="line">        Integer result = function.apply(<span class="string">&quot;10086&quot;</span>);</span><br><span class="line">        <span class="comment">// 10086</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">staticMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定对象实例方法引用"><a href="#指定对象实例方法引用" class="headerlink" title="指定对象实例方法引用"></a>指定对象实例方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticularInstanceRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">refMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParticularInstanceRef ref = <span class="keyword">new</span> ParticularInstanceRef();</span><br><span class="line">        Function&lt;String, Integer&gt; function = ref::refMethod;</span><br><span class="line">        <span class="comment">// 等同于</span></span><br><span class="line">        <span class="comment">// Function&lt;String,Integer&gt; function1 = (String s) -&gt; ref.refMethod(s);</span></span><br><span class="line">        Integer result = function.apply(<span class="string">&quot;10086&quot;</span>);</span><br><span class="line">        <span class="comment">// 10086</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特定类型任意对象方法引用"><a href="#特定类型任意对象方法引用" class="headerlink" title="特定类型任意对象方法引用"></a>特定类型任意对象方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(stringArray, String::compareToIgnoreCase);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// Arrays.sort(stringArray, (String s1, String s2) -&gt; s1.compareToIgnoreCase(s2));</span></span><br><span class="line"><span class="comment">// [a, B, C]</span></span><br><span class="line">System.out.println(Arrays.toString(stringArray));</span><br></pre></td></tr></table></figure>

<h2 id="超类方法引用"><a href="#超类方法引用" class="headerlink" title="超类方法引用"></a>超类方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupperRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        <span class="comment">// 10086</span></span><br><span class="line">        System.out.println(sub.refMethod(<span class="string">&quot;10086&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Integer <span class="title">supperRefMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Integer <span class="title">refMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            Function&lt;String, Integer&gt; function = <span class="keyword">super</span>::supperRefMethod;</span><br><span class="line">            <span class="comment">// 等同于</span></span><br><span class="line">            <span class="comment">// Function&lt;String,Integer&gt; function1 = (String s) -&gt; super.supperRefMethod(s);</span></span><br><span class="line">            <span class="keyword">return</span> function.apply(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造器方法引用"><a href="#构造器方法引用" class="headerlink" title="构造器方法引用"></a>构造器方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;String, Person&gt; function = Person::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">// 等同于</span></span><br><span class="line">        <span class="comment">// Function&lt;String,Person&gt; function1 = (String s) -&gt; new Person(s);</span></span><br><span class="line">        Person person = function.apply(<span class="string">&quot;thinkwon&quot;</span>);</span><br><span class="line">        <span class="comment">// doge</span></span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组构造器方法引用"><a href="#数组构造器方法引用" class="headerlink" title="数组构造器方法引用"></a>数组构造器方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer[]&gt; function = Integer[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// Function&lt;Integer, Integer[]&gt; function1 = (Integer i) -&gt; new Integer[i];</span></span><br><span class="line">Integer[] array = function.apply(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// [null, null, null, null, null, null, null, null, null, null]</span></span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Filter-amp-Predicate"><a href="#Filter-amp-Predicate" class="headerlink" title="Filter &amp; Predicate"></a>Filter &amp; Predicate</h1><p>常规用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(args[])</span></span>&#123;</span><br><span class="line">    List languages = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Scala&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Haskell&quot;</span>, <span class="string">&quot;Lisp&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Languages which starts with J :&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.startsWith(<span class="string">&quot;J&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Languages which ends with a &quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.endsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print all languages :&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print no language : &quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;<span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print language whose length greater than 4:&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.length() &gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate condition)</span> </span>&#123;</span><br><span class="line">    names.stream().filter((name) -&gt; (condition.test(name))).forEach((name) -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>多个Predicate组合filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用and()、or()和xor()逻辑函数来合并Predicate，</span></span><br><span class="line"><span class="comment">// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入</span></span><br><span class="line">Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == <span class="number">4</span>;</span><br><span class="line">names.stream()</span><br><span class="line">    .filter(startsWithJ.and(fourLetterLong))</span><br><span class="line">    .forEach((n) -&gt; System.out.print(<span class="string">&quot;nName, which starts with &#x27;J&#x27; and four letter long is : &quot;</span> + n));</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/22/Spring-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/22/Spring-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Spring核心基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-22 10:52:05" itemprop="dateCreated datePublished" datetime="2021-10-22T10:52:05+08:00">2021-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-23 13:55:22" itemprop="dateModified" datetime="2021-10-23T13:55:22+08:00">2021-10-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-Bean命名策略"><a href="#Spring-Bean命名策略" class="headerlink" title="Spring Bean命名策略"></a>Spring Bean命名策略</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们有多个相同类型的实现时，命名Spring bean非常有用。这是因为如果我们的 bean 没有唯一的名称，Spring 将不明确注入 bean。</p>
<p>通过控制 bean 的命名，我们可以告诉 Spring 我们要将哪个 bean 注入目标对象。</p>
<p>在本文中，我们将讨论 Spring bean 命名策略，并探讨如何为单一类型的 bean 赋予多个名称。</p>
<h2 id="默认-Bean-命名策略"><a href="#默认-Bean-命名策略" class="headerlink" title="默认 Bean 命名策略"></a>默认 Bean 命名策略</h2><p>Spring为创建 bean提供了多个注解。我们可以在不同级别使用这些注解。例如，我们可以在 bean 类上放置一些注解，而在创建 bean 的方法上放置其他注解。</p>
<p>首先，让我们看看 Spring 的默认命名策略。当我们只指定注解而没有任何值时，Spring 如何命名我们的 bean？</p>
<h3 id="类级注解"><a href="#类级注解" class="headerlink" title="类级注解"></a>类级注解</h3><p>让我们从在类级别使用的注解的默认命名策略开始。为了给 bean 命名，<strong>Spring 使用类名并将第一个字母转换为小写</strong>。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，Spring 为<em>LoggingService</em>类创建了一个 bean，并使用名称“ <em>loggingService</em> ”注册它。</p>
<p>这个相同的默认命名策略适用于用于创建 Spring bean 的所有类级注解，例如<span style="color:blue">**@Component**</span>、<span style="color:blue">**@Service**</span>和<span style="color:blue">**@Controller**</span>。</p>
<h3 id="方法级注解"><a href="#方法级注解" class="headerlink" title="方法级注解"></a>方法级注解</h3><p>Spring 提供了诸如@Bean和@Qualifier 之类的注解，用于在方法上创建 bean 。</p>
<p>让我们看一个例子来理解*@Bean*注解的默认命名策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuditService <span class="title">audit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> AuditService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个配置类中，Spring在名称“ <em>audit</em> ”下注册了一个<em>AuditService</em>类型的 bean，<strong>因为当我们在方法上使用@Bean注解时，Spring 使用方法名称作为 bean 名称。</strong></p>
<p>我们也可以在方法上使用*@Qualifier*注解。</p>
<h2 id="Bean-的自定义命名"><a href="#Bean-的自定义命名" class="headerlink" title="Bean 的自定义命名"></a>Bean 的自定义命名</h2><p>当我们需要在同一个 Spring 上下文中创建多个相同类型的 bean 时，我们可以为 bean 指定自定义名称并使用这些名称引用它们。</p>
<p>那么，让我们看看如何为我们的 Spring bean 指定一个自定义名称：</p>
<h3 id="类级注解-1"><a href="#类级注解-1" class="headerlink" title="类级注解"></a>类级注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomComponent</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次，Spring 将创建名为“ <em>myBean</em> ”的<em>MyCustomComponent</em>类型的 bean 。</p>
<p>由于我们明确地为 bean 指定名称，Spring 将使用此名称，然后可以使用该名称来引用或访问 bean。</p>
<p>与*@Component(“myBean”)<em>类似，我们可以使用</em>@Service(“myService”)<em>、</em>@Controller(“myController”)<em>和</em>@Bean(“myCustomBean”)*等其他注解指定名称，然后Spring </p>
<p>会注册具有给定名称的那个 bean。</p>
<h3 id="方法级注解-1"><a href="#方法级注解-1" class="headerlink" title="方法级注解"></a>方法级注解</h3><p>正如我们之前看到的，*@Bean*注解是在方法级别应用的，默认情况下，Spring 使用方法名称作为 bean 名称。</p>
<p>这个默认的 bean 名称可以被覆盖——我们可以使用*@Bean*注解指定值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line">    @Bean(&quot;beanComponent&quot;)</span><br><span class="line">    public MyCustomComponent myComponent() &#123;</span><br><span class="line">        return new MyCustomComponent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，当我们想要获取一个<em>MyCustomComponent</em>类型的 bean 时，我们可以使用名称“ <em>beanComponent</em> ”来引用这个 bean 。</p>
<p>Spring <em>@Bean</em>注解通常在配置类方法中声明。它可以通过直接调用来引用同一个类中的其他*@Bean*方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/spring%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/beannamestrategy.png"></p>
<hr>
<h1 id="Spring-ApplicationContext"><a href="#Spring-ApplicationContext" class="headerlink" title="Spring ApplicationContext"></a>Spring ApplicationContext</h1><h2 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a><em>ApplicationContext</em>接口</h2><p>Spring 框架的主要特性之一是 IoC（控制反转）容器。在Spring IoC容器负责管理应用程序的对象。它使用依赖注入来实现控制反转。</p>
<p><em>BeanFactory</em> 和<em>ApplicationContext</em> 接口<strong>代表 Spring IoC 容器</strong>。在这里，<em>BeanFactory</em>是访问 Spring 容器的根接口。它提供了管理 bean 的基本功能。</p>
<p>另一方面，<em>ApplicationContext</em> 是<em>BeanFactory</em>的子接口。因此，它提供了<em>BeanFactory 的</em>所有功能<em>。</em></p>
<p>此外，它还<strong>提供了</strong> <strong>更多特定于企业的功能</strong>。<em>ApplicationContext</em>的重要特性是<strong>解析消息、支持国际化、发布事件和应用层特定上下文</strong>。这就是我们将其用作默认 Spring 容器的原因。</p>
<h2 id="在容器中配置Bean"><a href="#在容器中配置Bean" class="headerlink" title="在容器中配置Bean"></a>在容器中配置Bean</h2><p>正如我们所知，<em>ApplicationContext</em>的主要工作是管理 bean。</p>
<p>因此，应用程序必须向<em>ApplicationContext</em>容器提供 bean 配置。一个 Spring bean 配置由一个或多个 bean 定义组成。此外，Spring 支持不同的 bean 配置方式。</p>
<h3 id="基于-Java-的配置"><a href="#基于-Java-的配置" class="headerlink" title="基于 Java 的配置"></a>基于 Java 的配置</h3><p>首先，我们将从基于 Java 的配置开始，因为它是最新和最受欢迎的 bean 配置方式。它从 Spring 3.0 开始可用。</p>
<p>Java 配置通常在*<em>@Configuration**类中使用带有 @Bean 注解的方法</em>。方法上的*@Bean<em>注解表明该方法创建了一个 Spring bean。此外，用</em>@Configuration注解的类表示它包含Spring bean 配置。</p>
<p>现在让我们创建一个配置类来将我们的<em>AccountService</em>类定义为 Spring bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AccountService <span class="title">accountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountService(accountRepository());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountRepository();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><p>Spring 2.5 引入了基于注解的配置，作为在 Java 中启用 bean 配置的第一步。</p>
<p>在这种方法中，我们首先通过 XML 配置启用基于注解的配置。然后我们在 Java 类、方法、构造函数或字段上使用一组注解来配置 bean。这些注解的一些示例是*@Component<em>、</em>@Controller<em>、</em>@Service<em>、</em>@Repository<em>、</em>@Autowired<em>和</em>@Qualifier*。</p>
<p>值得注意的是，我们也将这些注解用于基于 Java 的配置。另外值得一提的是，Spring 会在每个版本中不断为这些注解添加更多功能。</p>
<p>现在让我们看一个这个配置的简单例子。</p>
<p>首先，我们将创建 XML 配置<em>user-bean-config.xml</em>以启用注解：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.baeldung.applicationcontext&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里，该注解的配置标签启用基于注解的映射。该<em>组件扫描</em>标签也告诉Spring到哪里寻找注解类。</p>
<p>其次，我们将创建<em>UserService</em>类并使用*@Component*注解将其定义为 Spring bean ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// user service code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-XML-的配置"><a href="#基于-XML-的配置" class="headerlink" title="基于 XML 的配置"></a>基于 XML 的配置</h3><p>最后，让我们看一下基于 XML 的配置。这是在 Spring 中配置 bean 的传统方式。</p>
<p>显然，在这种方法中，我们<strong>在一个 XML 配置文件中</strong>完成所有<strong>bean 映射</strong>。</p>
<p>因此，让我们创建一个 XML 配置文件<em>account-bean-config.xml</em>，并为我们的<em>AccountService</em>类定义 bean ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">	  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.applicationcontext.AccountService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;accountRepository&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountRepository&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.applicationcontext.AccountRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ApplicationContext-的类型"><a href="#ApplicationContext-的类型" class="headerlink" title="ApplicationContext 的类型"></a><em>ApplicationContext 的</em>类型</h2><p>Spring 提供了适合不同需求的不同类型的<em>ApplicationContext</em>容器。这些是<em>ApplicationContext</em>接口的实现。那么让我们来看看<em>ApplicationContext 的</em>一些常见类型。</p>
<h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a><em>AnnotationConfigApplicationContext</em></h3><p>首先我们来看一下Spring 3.0中引入的AnnotationConfigApplicationContext类。它可以采取<strong>与注解的类@Configuration<em>，**</em></strong>@Component**，和JSR-330的元数据作为输入。从Java的配置类中加载上下文定义。</p>
<p>因此，让我们看一个使用<em>AnnotationConfigApplicationContext</em>容器和基于 Java 的配置的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AccountConfig.class);</span><br><span class="line">AccountService accountService = context.getBean(AccountService.class);</span><br></pre></td></tr></table></figure>

<h3 id="AnnotationConfigWebApplicationContext"><a href="#AnnotationConfigWebApplicationContext" class="headerlink" title="AnnotationConfigWebApplicationContext"></a><em>AnnotationConfigWebApplicationContext</em></h3><p>适用于 Web 应用下xml文件中加载上下文，使用注解方式加载上下文</p>
<p>当我们 在<em>web.xml</em>文件中配置 Spring 的<em>ContextLoaderListener</em> servlet 侦听器或 Spring MVC <em>DispatcherServlet</em>时，我们可能会使用这个类。</p>
<p>此外，从 Spring 3.0 开始，我们还可以通过编程方式配置这个应用程序上下文容器。我们需要做的就是实现WebApplicationInitializer接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    AnnotationConfigWebApplicationContext context = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">    context.register(AccountConfig.class);</span><br><span class="line">    context.setServletContext(container);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servlet configuration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XmlWebApplicationContext"><a href="#XmlWebApplicationContext" class="headerlink" title="XmlWebApplicationContext"></a><em>XmlWebApplicationContext</em></h3><p>如果我们<strong>在 Web 应用程序中</strong>使用<strong>基于 XML 的配置</strong>，我们可以使用XmlWebApplicationContext类。</p>
<p>事实上，配置这个容器就像<em>AnnotationConfigWebApplicationContext</em>类，也就是说我们可以在<em>web.xml 中</em>配置它<em>，</em> 或者实现<em>WebApplicationInitializer</em>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyXmlWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    XmlWebApplicationContext context = <span class="keyword">new</span> XmlWebApplicationContext();</span><br><span class="line">    context.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/applicationContext.xml&quot;</span>);</span><br><span class="line">    context.setServletContext(container);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Servlet configuration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileSystemXMLApplicationContext"><a href="#FileSystemXMLApplicationContext" class="headerlink" title="FileSystemXMLApplicationContext"></a><em>FileSystemXMLApplicationContext</em></h3><p>我们使用FileSystemXMLApplicationContext类<strong>从文件系统</strong>或 URL<strong>加载基于 XML 的 Spring 配置文件</strong>。当我们需要以编程方式加载<em>ApplicationContext</em>时，这个类很有用。一般来说，测试工具和独立应用程序是一些可能的用例。</p>
<p>例如，让我们看看如何创建这个 Spring 容器并为基于 XML 的配置加载 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">&quot;C:/myProject/src/main/resources/applicationcontext/account-bean-config.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(path);</span><br><span class="line">AccountService accountService = context.getBean(<span class="string">&quot;accountService&quot;</span>, AccountService.class);</span><br></pre></td></tr></table></figure>

<h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a><em>ClassPathXmlApplicationContext</em></h3><p>如果我们想<strong>从 classpath 加载 XML 配置文件</strong>，我们可以使用ClassPathXmlApplicationContext类。与<em>FileSystemXMLApplicationContext</em>类似<em>，</em>它对于测试工具以及嵌入在 JAR 中的应用程序上下文很有用。</p>
<p>那么让我们看一个使用这个类的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationcontext/account-bean-config.xml&quot;</span>);</span><br><span class="line">AccountService accountService = context.getBean(<span class="string">&quot;accountService&quot;</span>, AccountService.class);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="BeanFactory-和-ApplicationContext-的区别"><a href="#BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="BeanFactory 和 ApplicationContext 的区别"></a>BeanFactory 和 ApplicationContext 的区别</h1><p>Spring 框架带有两个 IOC 容器—— <em>BeanFactory</em>和<em>ApplicationContext</em>。该<em>Bean工厂</em>是IOC容器的最基本的版本，以及<em>ApplicationContext的</em>扩展的功能<em>Bean工厂</em>。</p>
<p>我们将通过实际示例了解这两个 IOC 容器之间的显着差异。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/spring%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/beanfactoryand%20context.png"></p>
<p>该<em>ApplicationContext的</em>带有先进的功能，包括正朝着企业应用面向好几个，而<em>Bean工厂</em>仅预装了基本功能。因此，通常建议使用<em>ApplicationContext的，</em>并且<strong>我们应该使用Bean工厂，只有当内存消耗是至关重要的</strong>。</p>
<h1 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h1><p>在这篇文章中，我们将看到*@ComponentScan* 注解可用的不同类型的过滤器选项 <em>。</em></p>
<h2 id="ComponentScan过滤器"><a href="#ComponentScan过滤器" class="headerlink" title="@ ComponentScan过滤器"></a>@ <em>ComponentScan</em>过滤器</h2><p>默认情况下，使用*@Component、@Repository、@Service、@Controller<em>注解的</em>类<em>被注册为Spring beans。对于使用</em>@Component<em>注解的自定义注解的</em>类也是如此<em>。我们可以通过使用</em>@ComponentScan<em>注解的</em>includeFilters 和* <em>excludeFilters</em>参数 来扩展此行为。</p>
<p><strong>ComponentScan.Filter有五种类型的过滤器：</strong></p>
<ul>
<li><em>ANNOTATION</em>   按照注解过滤</li>
<li><em>ASSIGNABLE_TYPE</em>  按照给定的类型</li>
<li><em>ASPECTJ</em>  使用ASPECTJ表达式</li>
<li><em>REGEX</em>  正则表达式</li>
<li><em>CUSTOM</em>  自定义规则</li>
</ul>
<h2 id="FilterType-ANNOTATION"><a href="#FilterType-ANNOTATION" class="headerlink" title="FilterType.ANNOTATION"></a><em>FilterType.ANNOTATION</em></h2><p>例如，假设我们有一个*@Anima* l 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Animal &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们定义一个 使用*@Animal<em>的</em>Elephant*类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elephant</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>最后，让我们使用 <em>FilterType.ANNOTATION</em>告诉 Spring 扫描 <em>@Animal 注解的</em>类：扫描仪很好地拾取了我们的<em>Elephant</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">        classes = Animal.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanAnnotationFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="FilterType-ASSIGNABLE-TYPE"><a href="#FilterType-ASSIGNABLE-TYPE" class="headerlink" title="FilterType.ASSIGNABLE_TYPE"></a><em>FilterType.ASSIGNABLE_TYPE</em></h2><p>首先，让我们声明<em>Animal</em> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>再一次，让我们声明我们的<em>Elephant</em>类，这次实现<em>Animal</em>接口<em>：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elephant</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>让我们声明我们的<em>Cat</em>类也实现了<em>Animal：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们使用<em>ASSIGNABLE_TYPE</em>来引导 Spring 扫描<em>Animal</em>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,</span></span><br><span class="line"><span class="meta">        classes = Animal.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanAssignableTypeFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><em>Cat</em>和<em>Elephant 都</em>被扫描到。</p>
<h2 id="FilterType-REGEX"><a href="#FilterType-REGEX" class="headerlink" title="FilterType.REGEX"></a><em>FilterType.REGEX</em></h2><p>再一次，让我们声明我们的<em>Elephant</em>类。这次没有实现任何接口或使用任何注解进行注解<em>：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elephant</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>让我们再声明一个类<em>Cat</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们声明<em>Loin</em>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loin</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>让我们使用<em>FilterType</em>。<em>REGEX</em>指示 Spring 扫描与正则表达式*.[nt]<em>匹配的类</em>。<em>我们的正则表达式计算所有包含</em>nt 的内容：*</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.REGEX,</span></span><br><span class="line"><span class="meta">        pattern = &quot;.*[nt]&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanRegexFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>这次在我们的测试中，我们将看到 Spring 扫描<em>Elephant</em>，而不是<em>Lion</em> <em>：</em></p>
<h2 id="FilterType-ASPECTJ"><a href="#FilterType-ASPECTJ" class="headerlink" title="FilterType.ASPECTJ"></a><em>FilterType.ASPECTJ</em></h2><p>对于这个用例，我们可以重用与上一节相同的三个类。</p>
<p>让我们使用 <em>FilterType.ASPECTJ</em>来指示 Spring 扫描与我们的<em>AspectJ</em>表达式匹配的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.ASPECTJ,</span></span><br><span class="line"><span class="meta">  pattern = &quot;com.baeldung.componentscan.filter.aspectj.* &quot;</span></span><br><span class="line"><span class="meta">  + &quot;&amp;&amp; !(com.baeldung.componentscan.filter.aspectj.L* &quot;</span></span><br><span class="line"><span class="meta">  + &quot;|| com.baeldung.componentscan.filter.aspectj.C*)&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanAspectJFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>虽然有点复杂，但我们这里的逻辑希望 bean 的类名中既不以“L”也不以“C”开头，因此我们又得到了<em>Elephant</em> s</p>
<hr>
<h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><h2 id="Autowire-消除歧义的需要"><a href="#Autowire-消除歧义的需要" class="headerlink" title="Autowire 消除歧义的需要"></a>Autowire 消除歧义的需要</h2><p>当需要自动注入特定精确的Bean时，@Autowire 是一种很好的方式，尽管它很有用，但在某些用例中，仅此注解不足以让 Spring 了解要注入哪个 bean。</p>
<p>默认情况下，Spring 按类型解析自动装配的条目。</p>
<p><strong>如果容器中有多个相同类型的 bean，则框架将抛出NoUniqueBeanDefinitionException</strong>， 表明有多个 bean 可用于自动装配。</p>
<p>让我们想象这样一种情况，其中 Spring 存在两个可能的候选者作为 bean 协作者注入给定实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;barFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Formatter formatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们尝试将<em>FooService</em>加载到我们的上下文中，Spring 框架将抛出一个<em>NoUniqueBeanDefinitionException</em>。这是因为<strong>Spring 不知道要注入哪个 bean</strong>。为了避免这个问题，有几种解决方案；该*@Qualifier*注解就是其中之一。</p>
<h2 id="Qualifier注解"><a href="#Qualifier注解" class="headerlink" title="@ Qualifier注解"></a>@ <em>Qualifier</em>注解</h2><p>通过使用*@Qualifier*注解，我们可以<strong>消除需要注入哪个bean的问题</strong>。</p>
<p>让我们回顾一下之前的示例，看看我们如何通过包含*@Qualifier*注解来指示我们要使用哪个 bean 来解决问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Formatter formatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过包含*@Qualifier<em>注解，连同我们想要使用的具体实现的名称，在这个例子中为</em>Foo，*我们可以避免当 Spring 找到多个相同类型的 bean 时产生歧义。</p>
<p>我们需要<strong>考虑到要使用的限定符名称是@Component注解中声明的名称。</strong></p>
<p>请注意，我们也可以在<em>Formatter</em>实现类上使用*@Qualifier<em>注解，而不是在它们的</em>@Component*注解中指定名称，以获得相同的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;barFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Qualifier-VS-Primary"><a href="#Qualifier-VS-Primary" class="headerlink" title="@Qualifier VS @Primary"></a><em>@Qualifier</em> VS <em>@Primary</em></h2><p>还有另一个名为*@Primary*的注解 ，当依赖注入存在歧义时，我们可以使用它来决定注入哪个 bean。</p>
<p><strong>当存在多个相同类型的 bean 时，</strong>此注解<strong>定义了一个首选项</strong>。除非另有说明，否则将使用与*@Primary*注解关联的 bean 。</p>
<p>让我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">johnEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Employee(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">tonyEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Employee(<span class="string">&quot;Tony&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，两种方法都返回相同的<em>Employee</em>类型。Spring 将注入的 bean 是<em>tonyEmployee</em>方法返回的<em>bean</em>。这是因为它包含*@Primary*注解。当我们想要<strong>指定默认情况下应该注入哪个特定类型的 bean</strong>时，此注解很有用。</p>
<p>如果我们在某个注入时需要另一个 bean，我们需要特别指出它。我们可以通过*@Qualifier<em>注解来做到这一点。例如，我们可以通过使用</em>@Qualifier<em>注解来指定我们要使用</em>johnEmployee*方法返回的 bean 。</p>
<p>值得注意的是，<strong>如果@Qualifier和@Primary注解都存在，那么@Qualifier注解将具有优先权。</strong>基本上，*@Primary<em>定义了一个默认值，而</em>@Qualifier*则非常具体。</p>
<hr>
<h1 id="理解-Spring-中的-getBean"><a href="#理解-Spring-中的-getBean" class="headerlink" title="理解 Spring 中的 getBean()"></a>理解 Spring 中的 getBean()</h1><p>我们将介绍*BeanFactory.getBean()*方法的不同变体。</p>
<p>简而言之，正如该方法的名称所暗示的那样，<strong>它</strong> <strong>负责从 Spring 容器中检索 bean 实例</strong>。</p>
<h2 id="Spring-Beans-设置"><a href="#Spring-Beans-设置" class="headerlink" title="Spring Beans 设置"></a>Spring Beans 设置</h2><p>首先，让我们定义几个 Spring bean 进行测试。我们可以通过多种方式为 Spring 容器提供 bean 定义，但在我们的示例中，我们将使用基于注解的 Java 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &#123;&quot;tiger&quot;, &quot;kitty&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line">    <span class="function">Tiger <span class="title">getTiger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tiger(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;lion&quot;)</span></span><br><span class="line">    <span class="function">Lion <span class="title">getLion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Lion(<span class="string">&quot;Hardcoded lion name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经创建了两个 bean。<em>Lion</em>具有默认的单例范围。<em>Tiger</em>明确设置为原型范围。此外，请注意，我们为将在进一步请求中使用的每个 bean 定义了名称。</p>
<h2 id="getBean-API"><a href="#getBean-API" class="headerlink" title="getBean() API"></a><em>getBean()</em> API</h2><p><em>BeanFactory</em>提供了*getBean()*方法的五种不同签名</p>
<h3 id="按名称检索-Bean"><a href="#按名称检索-Bean" class="headerlink" title="按名称检索 Bean"></a>按名称检索 Bean</h3><p>让我们看看如何使用名称检索<em>Lion</em> bean 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object lion = context.getBean(<span class="string">&quot;lion&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(Lion.class, lion.getClass());</span><br></pre></td></tr></table></figure>

<p>在这个变体中，我们提供一个名称，作为回报，如果应用程序上下文中存在具有给定名称的 bean ，我们将获得一个<em>Object</em> 类的实例。否则，如果 bean 查找失败，则此实现和所有其他实现都将抛出<em>NoSuchBeanDefinitionException</em>。</p>
<p>主要的缺点是<strong>在检索 bean 后，我们必须将其强制转换为所需的类型</strong>如果返回的 bean 的类型与我们预期的不同，这可能会产生另一个异常。</p>
<h3 id="按名称和类型检索-Bean"><a href="#按名称和类型检索-Bean" class="headerlink" title="按名称和类型检索 Bean"></a>按名称和类型检索 Bean</h3><p>这里我们需要指定请求的 bean 的名称和类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lion lion = context.getBean(<span class="string">&quot;lion&quot;</span>, Lion.class);</span><br></pre></td></tr></table></figure>

<p>与前一种方法相比，这种方法更安全，因为我们可以立即获取有关类型不匹配的信息。</p>
<h3 id="按类型检索-Bean"><a href="#按类型检索-Bean" class="headerlink" title="按类型检索 Bean"></a>按类型检索 Bean</h3><p>使用*getBean()*的第三个变体， 仅指定 bean 类型就足够了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lion lion = context.getBean(Lion.class);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们需要<strong>特别注意一个潜在的模棱两可的结果</strong></p>
<p>在上面的示例中，由于<em>Lion</em>和<em>Tiger 都</em>实现了<em>Animal</em>接口，因此仅指定类型不足以明确确定结果。因此，我们得到一个<em>NoUniqueBeanDefinitionException</em>。</p>
<h3 id="使用构造函数参数按名称检索-Bean"><a href="#使用构造函数参数按名称检索-Bean" class="headerlink" title="使用构造函数参数按名称检索 Bean"></a>使用构造函数参数按名称检索 Bean</h3><p>除了 bean 名称，我们还可以传递构造函数参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = (Tiger) context.getBean(<span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;Siberian&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>这个方法有点不同，因为它只适用于具有原型作用域的 bean</strong>。</p>
<p>在单例的情况下，我们将得到一个<em>BeanDefinitionStoreException</em></p>
<p>因为原型 bean 每次从应用程序容器请求时都会返回一个新创建的实例，所以<strong>我们可以</strong>在调用<em>getBean()*时 *</em>即时提供构造函数参数**：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = (Tiger) context.getBean(<span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;Siberian&quot;</span>);</span><br><span class="line">Tiger secondTiger = (Tiger) context.getBean(<span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;Striped&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Siberian&quot;</span>, tiger.getName());</span><br><span class="line">assertEquals(<span class="string">&quot;Striped&quot;</span>, secondTiger.getName());</span><br></pre></td></tr></table></figure>

<p>正如我们所见，根据我们在请求 bean 时指定为第二个参数的内容，每个<em>Tiger</em>获得不同的名称。</p>
<h3 id="使用构造函数参数按类型检索-Bean"><a href="#使用构造函数参数按类型检索-Bean" class="headerlink" title="使用构造函数参数按类型检索 Bean"></a>使用构造函数参数按类型检索 Bean</h3><p>这个方法类似于最后一个，但我们需要传递类型而不是名称作为第一个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = context.getBean(Tiger.class, <span class="string">&quot;Shere Khan&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Shere Khan&quot;</span>, tiger.getName());</span><br></pre></td></tr></table></figure>

<p>与使用构造函数参数按名称检索 bean 类似，<strong>此方法仅适用于具有原型范围的 bean</strong>。</p>
<h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><p>尽管在<em>BeanFactory</em>接口中定义了<em>getBean()<em>方法，但它最常通过</em>ApplicationContext</em>访问<em>。</em>通常，<strong>我们不想在我们的程序中直接使用getBean()方法</strong>。</p>
<p>Bean 应该由容器管理。如果我们想使用其中之一，我们应该依赖依赖注入而不是直接调用<em>ApplicationContext.getBean()</em> <em>。</em>这样，我们就可以避免将应用程序逻辑与框架相关的细节混合在一起。</p>
<hr>
<h1 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h1><p><strong>简单地说，我们可以使用@RequestParam从请求中提取查询参数、表单参数甚至文件。</strong></p>
<h2 id="一个简单的映射"><a href="#一个简单的映射" class="headerlink" title="一个简单的映射"></a><strong>一个简单的映射</strong></h2><p>假设我们有一个端点*/api/foos<em>，它接受一个名为</em>id*的查询参数 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用*@RequestParam<em>来提取</em>id*查询参数。</p>
<p>一个简单的 GET 请求将调用<em>getFoos</em>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=abc</span><br><span class="line">----</span><br><span class="line">ID: abc</span><br></pre></td></tr></table></figure>

<p>接下来，<strong>让我们看看注解的属性：name、 value、required和defaultValue。</strong></p>
<h2 id="指定请求参数名称"><a href="#指定请求参数名称" class="headerlink" title="指定请求参数名称"></a><strong>指定请求参数名称</strong></h2><p>幸运的是，<strong>我们可以使用name属性配置@RequestParam名称</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addFoo</span><span class="params">(<span class="meta">@RequestParam(name = &quot;id&quot;)</span> String fooId, <span class="meta">@RequestParam</span> String name)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + fooId + <span class="string">&quot; Name: &quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以做 *@RequestParam(value = “id”)*或者只是@RequestParam(“id”)。</p>
<h2 id="可选的请求参数"><a href="#可选的请求参数" class="headerlink" title="可选的请求参数"></a><strong>可选的请求参数</strong></h2><p>默认用*@RequestParam*注解的方法参数 是必须的。</p>
<p>这意味着如果请求中不存在该参数，我们将收到错误消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/foos HTTP/1.1</span><br><span class="line">-----</span><br><span class="line">400 Bad Request</span><br><span class="line">Required String parameter <span class="string">&#x27;id&#x27;</span> is not present</span><br></pre></td></tr></table></figure>

<p><strong>使用required 属性将@RequestParam配置为可选：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam(required = false)</span> String id)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，两者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=abc</span><br><span class="line">----</span><br><span class="line">ID: abc</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos</span><br><span class="line">----</span><br><span class="line">ID: null</span><br></pre></td></tr></table></figure>

<p>将正确调用该方法。</p>
<p><strong>当未指定参数时，方法参数绑定到null。</strong></p>
<h2 id="请求参数的默认值"><a href="#请求参数的默认值" class="headerlink" title="请求参数的默认值"></a><strong>请求参数的默认值</strong></h2><p>我们还可以 使用<em>defaultValue</em>属性为*@RequestParam*设置默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;test&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这就像required=false， 因为用户不再需要提供参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos</span><br><span class="line">----</span><br><span class="line">ID: <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>尽管如此，我们仍然可以提供它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=abc</span><br><span class="line">----</span><br><span class="line">ID: abc</span><br></pre></td></tr></table></figure>

<p>请注意，当我们设置 <em>defaultValue</em> 属性时， <em>required</em>确实设置为<em>false</em>。</p>
<h2 id="映射所有参数"><a href="#映射所有参数" class="headerlink" title="映射所有参数"></a><strong>映射所有参数</strong></h2><p><strong>我们也可以有多个参数，而无需定义它们的名称</strong>或计数，只需使用<em>Map</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateFoos</span><span class="params">(<span class="meta">@RequestParam</span> Map&lt;String,String&gt; allParams)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Parameters are &quot;</span> + allParams.entrySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将反映发送的任何参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -F <span class="string">&#x27;name=abc&#x27;</span> -F <span class="string">&#x27;id=123&#x27;</span> http://localhost:8080/api/foos</span><br><span class="line">-----</span><br><span class="line">Parameters are &#123;[name=abc], [id=123]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="映射多值参数"><a href="#映射多值参数" class="headerlink" title="映射多值参数"></a><strong>映射多值参数</strong></h2><p>单个*@RequestParam*可以有多个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;IDs are &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring MVC 将映射一个逗号分隔的 id 参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=1,2,3</span><br><span class="line">----</span><br><span class="line">IDs are [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>或单独的id参数列表</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=1&amp;id=2</span><br><span class="line">----</span><br><span class="line">IDs are [1,2]</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Component-vs-Repository-和-Service-在-Spring-中区别"><a href="#Component-vs-Repository-和-Service-在-Spring-中区别" class="headerlink" title="@Component vs @Repository 和 @Service 在 Spring 中区别"></a>@Component vs @Repository 和 @Service 在 Spring 中区别</h1><p>在大多数典型的应用程序中，我们有不同的层，如数据访问、表示、服务、业务等。</p>
<p>此外，在每一层中，我们都有不同的 bean。为了自动检测这些 bean，<strong>Spring 使用类路径扫描注释</strong>。</p>
<p>然后它在<em>ApplicationContext 中</em>注册每个 bean 。</p>
<p>以下是其中一些注释的快速概览：</p>
<ul>
<li><em>@Component</em>是任何 Spring 管理的组件的通用<em>构造</em>型。</li>
<li><em>@Service</em>在服务层注释类。</li>
<li><em>@Repository</em>在持久层注释类，它将充当数据库存储库。</li>
</ul>
<h2 id="有什么不同？"><a href="#有什么不同？" class="headerlink" title="有什么不同？"></a>有什么不同？</h2><p><strong>这些刻板印象之间的主要区别在于它们用于不同的分类。</strong>当我们为自动检测注释一个类时，我们应该使用相应的构造型。</p>
<p>现在让我们更详细地了解它们。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><strong>@Component</strong></h3><p><strong>我们可以在整个应用程序中使用 @Component 将 bean 标记为 Spring 的托管组件</strong>。<code>@Component</code>是任何 Spring 管理的组件的通用构造型。Spring 只会使用*@Component<em>获取和注册 bean ，一般不会查找</em>@Service* 和 <em>@Repository</em>。</p>
<p>它们在<em>ApplicationContext</em>中注册，因为它们用*@Component*注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>@Service</em> 和 <em>@Repository</em>是*@Component 的*特例。它们在技术上是相同的，但我们将它们用于不同的目的。</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a><strong>@Repository</strong></h3><p><strong>@Repository的工作是捕获特定于持久性的异常并将它们作为 Spring 的统一未检查异常之一重新抛出</strong>。</p>
<p>为此，Spring 提供了<em>PersistenceExceptionTranslationPostProcessor</em>，我们需要将其添加到我们的应用程序上下文中（如果我们使用 Spring Boot，则已包含）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=</span></span><br><span class="line"><span class="tag">  &quot;<span class="attr">org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor</span>&quot;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 bean 后处理器向任何用*@Repository*注释的 bean 添加了一个顾问 <em>。</em></p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a><strong>@Service</strong></h3><p><strong>我们用 @Service 标记 bean 以表明它们持有业务逻辑</strong>。除了在服务层使用之外，这个注解没有任何其他特殊用途。</p>
<hr>
<h1 id="Spring-中基于-XML-的注入"><a href="#Spring-中基于-XML-的注入" class="headerlink" title="Spring 中基于 XML 的注入"></a>Spring 中基于 XML 的注入</h1><p>让我们从在<em>pom.xml 中</em>添加 Spring 的库依赖开始：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="依赖注入——概述"><a href="#依赖注入——概述" class="headerlink" title="依赖注入——概述"></a><strong>依赖注入——概述</strong></h2><p><a target="_blank" rel="noopener" href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">依赖注入</a>是一种技术，其中对象的依赖项由外部容器提供。</p>
<p>假设我们有一个依赖于实际处理业务逻辑的服务的应用程序类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line">    <span class="comment">// standard constructors/getters/setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们说<em>IService</em>是一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口可以有多个实现。</p>
<p>让我们快速看一下一个潜在的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<em>IndexApp</em>是一个依赖于名为<em>IService</em>的低级组件的高级组件。</p>
<p>从本质上讲，我们将<em>IndexApp</em>与<em>IService</em>的特定实现分离，该实现可能因各种因素而异。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="使用属性注入"><a href="#使用属性注入" class="headerlink" title="使用属性注入"></a><strong>使用属性注入</strong></h3><p>让我们看看如何使用基于 XML 的配置将依赖项连接在一起：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;indexService&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexService&quot;</span> /&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;indexService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<p>可以看出，我们正在创建一个<em>IndexService</em>实例并为其分配一个 id。默认情况下，bean 是单例。此外，我们正在创建<em>IndexApp</em>的实例。</p>
<p>在这个 bean 中，我们使用 setter 方法注入另一个 bean。</p>
<h3 id="使用构造函数注入"><a href="#使用构造函数注入" class="headerlink" title="使用构造函数注入"></a><strong>使用构造函数注入</strong></h3><p>我们可以使用构造函数注入依赖项，而不是通过 setter 方法注入 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;indexService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<h3 id="使用静态工厂"><a href="#使用静态工厂" class="headerlink" title="使用静态工厂"></a><strong>使用静态工厂</strong></h3><p>我们也可以注入一个由工厂返回的 bean。让我们创建一个简单的工厂，根据提供的数字返回<em>IService</em>的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IService <span class="title">getNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们看看我们如何使用上述实现使用基于 XML 的配置将 bean 注入到<em>IndexApp 中</em>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.StaticServiceFactory&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们使用<em>factory-method</em>调用静态<em>getService**方法</em>来创建一个带有 id <em>messageService</em>的 bean ，我们将其注入<em>IndexApp。</em></p>
<h3 id="使用工厂方法"><a href="#使用工厂方法" class="headerlink" title="使用工厂方法"></a><strong>使用工厂方法</strong></h3><p>让我们考虑一个实例工厂，它根据提供的数字返回一个<em>IService</em>实例。这一次，该方法不是静态的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IService <span class="title">getNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们看看我们如何使用上面的实现来使用 XML 配置将 bean 注入到<em>IndexApp 中</em>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;indexServiceFactory&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.InstanceServiceFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.InstanceServiceFactory&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;indexServiceFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用<em>factory-method</em>调用<em>InstanceServiceFactory 实例</em>上的<em>getService**方法</em>来创建一个带有 id <em>messageService</em>的 bean ，我们将其注入<em>IndexApp</em>。</p>
<h2 id="访问配置的bean："><a href="#访问配置的bean：" class="headerlink" title="访问配置的bean："></a>访问配置的bean：</h2><p>这是我们如何访问配置的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenGetBeans_returnsBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    IndexApp indexApp = applicationContext.getBean(<span class="string">&quot;indexApp&quot;</span>, IndexApp.class);</span><br><span class="line">    assertNotNull(indexApp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用带有默认值的-Spring-Value"><a href="#使用带有默认值的-Spring-Value" class="headerlink" title="使用带有默认值的 Spring @Value"></a>使用带有默认值的 Spring @Value</h1><h2 id="字符串默认值"><a href="#字符串默认值" class="headerlink" title="字符串默认值"></a><strong>字符串默认值</strong></h2><p>让我们看一下为<em>String</em>属性设置默认值的基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:my default value&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String stringWithDefaultValue;</span><br></pre></td></tr></table></figure>

<p>如果<em>some.key</em>无法解析，<em>stringWith</em> <em>ithDefaultValue</em>将设置为<em>my default value 的默认值</em>。</p>
<p>同样，我们可以设置一个零长度的<em>字符串</em>作为默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:&#125;)</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">private String stringWithBlankDefaultValue;</span></span><br></pre></td></tr></table></figure>

<p><strong>基本类型默认值</strong></p>
<p>要为基本类型（例如<em>boolean</em>和<em>int ）</em>设置默认值，我们使用文字值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:true&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> booleanWithDefaultValue;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:42&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> intWithDefaultValue;</span><br></pre></td></tr></table></figure>

<p>如果我们愿意，我们可以通过将类型更改为<em>Boolean</em>和<em>Integer</em>来使用原始包装器。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>我们还可以将逗号分隔的值列表注入数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:one,two,three&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String[] stringArrayWithDefaults;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:1,2,3&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] intArrayWithDefaults;</span><br></pre></td></tr></table></figure>

<p>在上面的第一个示例中，值<em>one</em>、<em>two</em> 和<em>three作为默认值注入到</em>stringArrayWithDefaults 中。</p>
<h2 id="使用-SpEL-的高级示例"><a href="#使用-SpEL-的高级示例" class="headerlink" title="使用 SpEL 的高级示例"></a>使用 SpEL 的高级示例</h2><p>我们还可以使用 SpEL 表达式来获取值。</p>
<p>如果我们有一个名为<em>priority</em>的系统属性<em>，</em>那么它的值将应用于该字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;priority&#x27;]&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String spelValue;</span><br></pre></td></tr></table></figure>

<p>如果我们还没有定义系统属性，那么将分配<em>空</em>值。</p>
<p>为了防止这种情况，我们可以在 SpEL 表达式中提供一个默认值。如果未定义系统属性，我们会为该字段获取<em>一些默认</em>值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;unknown&#x27;] ?: &#x27;some default&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String spelSomeDefault;</span><br></pre></td></tr></table></figure>

<p>此外，我们可以使用来自其他 bean 的字段值。假设我们有一个名为<em>someBean</em>的 bean ，其字段<em>someValue</em>等于<em>10</em>。然后，将<em>10</em>分配给该字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;someBean.someValue&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer someBeanValue;</span><br></pre></td></tr></table></figure>

<p>我们可以操作属性来获取值<em>列表</em>，这里是字符串值 A、B 和 C 的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;&#x27;$&#123;listOfValues&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; valuesList;</span><br></pre></td></tr></table></figure>

<h2 id="Value-“-”-和-Value-“-”-的区别"><a href="#Value-“-”-和-Value-“-”-的区别" class="headerlink" title="@Value(“${}”)**和@Value(“#{}”)**的区别"></a><strong>@Value(“${}”)**和</strong>@Value(“#{}”)**的区别</h2><ul>
<li>@Value(“${}”)主要获取的是配置文件 application.yml /application.proterties 中的配置信息。</li>
<li>@Value(“#{}”) 表示SpEl表达式通常用来获取bean的属性，或者调用bean的某个方法或属性。当然还有可以表示常量</li>
</ul>
<p>在下面的示例中，我们希望将<em>some.system.key</em>设置为系统属性，如果未设置，我们希望使用<em>我的默认系统属性值</em> 作为默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;some.key&#x27;] ?: &#x27;my default system property value&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String spelWithDefaultValue;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Autowired-vs-Resource-vs-Inject-的区别"><a href="#Autowired-vs-Resource-vs-Inject-的区别" class="headerlink" title="@Autowired vs @Resource vs @Inject 的区别"></a>@Autowired vs @Resource vs @Inject 的区别</h1><p>为了实现依赖注入 DI 而引入，Java 提供 <code>javax.annotation.Resource</code> , <code>javax.inject.Inject</code> 注解，Spring 框架提供了 <code>org.springframework.beans.factory.annotation.Autowired</code> 。依赖注入（Denpendency Injection，DI）， 控制反转（Inversion of Control, IoC），主要的目的是去除代码耦合。</p>
<h2 id="具体解释"><a href="#具体解释" class="headerlink" title="具体解释"></a>具体解释</h2><table>
<thead>
<tr>
<th align="left">Annotation</th>
<th align="left">Package</th>
<th align="left">Source</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Autowired</td>
<td align="left">org.springframework.beans.factory.annotation.Autowire</td>
<td align="left">Spring</td>
</tr>
<tr>
<td align="left">@Resource</td>
<td align="left">javax.annotation.Resource</td>
<td align="left">Java</td>
</tr>
<tr>
<td align="left">@Inject</td>
<td align="left">javax.inject.Inject</td>
<td align="left">Java 需额外依赖</td>
</tr>
</tbody></table>
<p><code>@Autowired</code>: Spring 特有的注解，@Autowired 通过<strong>类型</strong>来注入，比如通过类的类型，或者类的接口来注解 field 或者 constructor。为了防止在项目中实现同一个接口，或者一系列子类，可以使用 @Qualifier 注解来避免歧义。默认情况下 bean 的名字就是 qualifier 的值。 尽管你可以按照约定通过名字来使用 @Autowired 注解，@Autowired 根本上还是类型驱动的注入，并且附带可选的语义上的 qualifiers.</p>
<p>@Inject: 该注解基于 <a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=330">JSR-330</a>, @Inject 注解是 Spring @Autowired 注解的代替品。所以使用 Spring 独有的 @Autowired 注解时，可以考虑选择使用 @Inject. @Autowired 和 @Inject 的不同之处在于是否有 required 属性，@Inject 没有 required 属性，因此在找不到合适的依赖对象时 inject 会失败，而 @Autowired 可以使用 required=false 来允许 null 注入。</p>
<p>使用 @Inject 需要添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Advantage of @Inject annotation is that rather than inject a reference directly, you could ask @Inject to inject a Provider. The Provider interface enables, among other things, lazy injection of bean references and injection of multiple instances of a bean. In case we have few implementation of an interface or a subclass we can narrow down the selection using the @Named annotation to avoid ambiguity. @Named annotation works much like Spring’s @Qualifier</p>
<p><code>@Resource</code>: JDK 1.6 支持注解，<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=250">JSR-250</a> 引入。@Resource 和 @Autowired @Inject 类似，最主要的区别在于寻找存在的 Bean 注入的路径不同。<code>@Resource</code> 寻找的优先顺序为</p>
<ul>
<li><ol>
<li>优先通过名字 (by name)</li>
</ol>
</li>
<li>2）其次是类型 (by type)</li>
<li>3）再次是 qualifier(by qualifier)</li>
</ul>
<p>而 <code>@Autowired</code> and <code>@Inject</code> 寻找的顺序为</p>
<ol>
<li>通过类型寻找</li>
<li>通过 qualifier</li>
<li>最后通过名字寻找</li>
</ol>
<p>@Resource 如果没有指定 name 属性，当注解标注在 field 上，默认取字段名称作为 bean 名称寻找依赖对象；当标注在属性 setter 方法上，默认取属性名作为 bean 名称寻找依赖。如果没有指定 name 属性，并且按照默认名称找不到依赖对象时，回退到类型装配。</p>
<hr>
<h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p>从 Spring 2.5 开始，该框架引入了注解驱动的<em>依赖注入</em>。此功能的主要注释是*@Autowired* <em>。</em> <strong>它允许 Spring 解析并将协作 bean 注入到我们的 bean 中。</strong></p>
<h2 id="启用-Autowired-注解"><a href="#启用-Autowired-注解" class="headerlink" title="启用*@Autowired*注解"></a>启用*@Autowired*注解</h2><p>Spring 框架支持自动依赖注入。换句话说，<strong>通过在 Spring 配置文件中声明所有 bean 依赖项，Spring 容器可以自动装配协作 bean 之间的关系</strong>。这称为*<strong>Spring bean 自动装配</strong>。</p>
<p>要在我们的应用程序中使用基于 Java 的配置，让我们启用注解驱动注入 来加载我们的 Spring 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.baeldung.autowire.sample&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>或者，[**注解](<a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-contextannotation-contextcomponentscan#:~:text=The">https://www.baeldung.com/spring-contextannotation-contextcomponentscan#:~:text=The</a>  can resolve.)主要用于激活 Spring XML 文件中的依赖注入注解。</p>
<p>此外，<strong>Spring Boot 引入了@SpringBootApplication注解</strong>。这个单一的注解等效于使用*@Configuration<em>、</em>@EnableAutoConfiguration*和 <em>@ComponentScan</em>。</p>
<p>让我们在应用程序的主类中使用这个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactoryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(VehicleFactoryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，当我们运行这个 Spring Boot 应用程序时，<strong>它会自动扫描当前包及其子包中的组件</strong>。因此，它将在 Spring 的应用程序上下文中注册它们，并允许我们使用*@Autowired*注入 bean 。</p>
<h2 id="使用-Autowired"><a href="#使用-Autowired" class="headerlink" title="使用@Autowired"></a>使用@Autowired</h2><p>启用注解注入后，<strong>我们可以在属性、设置器和构造函数上使用自动装配</strong>。</p>
<h3 id="Autowired用在属性上"><a href="#Autowired用在属性上" class="headerlink" title="@Autowired用在属性上"></a><strong>@Autowired用在属性上</strong></h3><p>让我们看看如何使用*@Autowired<em>注释</em>属性*。这消除了对 getter 和 setter 的需要。</p>
<p>首先，让我们定义一个<em>fooFormatter</em> bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooFormatter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们将在字段定义上使用*@Autowired<em>将此 bean 注入</em>FooService* bean ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其结果是，Spring注入<em>fooFormatter</em>时<em>FooService接口</em>被创建。</p>
<h3 id="Autowired在-Setter-上"><a href="#Autowired在-Setter-上" class="headerlink" title="@Autowired在 Setter 上"></a><strong>@Autowired在 Setter 上</strong></h3><p>现在让我们尝试在 setter 方法上添加*@Autowired*注释。</p>
<p>在以下示例中，在创建<em>FooService</em>时使用<em>FooFormatter</em>实例调用 setter 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFooFormatter</span><span class="params">(FooFormatter fooFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fooFormatter = fooFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Autowired在构造函数上"><a href="#Autowired在构造函数上" class="headerlink" title="@Autowired在构造函数上"></a><strong>@Autowired在构造函数上</strong></h3><p>最后，让我们在构造函数上使用*@Autowired*。</p>
<p>我们将看到Spring 注入了一个<em>FooFormatter</em>实例作为<em>FooService</em>构造函数的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooService</span><span class="params">(FooFormatter fooFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fooFormatter = fooFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Autowired-可选注入"><a href="#Autowired-可选注入" class="headerlink" title="@Autowired 可选注入"></a><em>@Autowired</em> 可选注入</h2><p>在构建 bean 时，@ <em>Autowired</em>依赖项应该可用。否则，<strong>如果 Spring 无法解析用于连接的 bean，它将抛出异常</strong>。</p>
<p>因此，它会阻止 Spring 容器成功启动，但以下形式除外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: </span><br><span class="line">No qualifying bean of type [com.autowire.sample.FooDAO] found <span class="keyword">for</span> dependency: </span><br><span class="line">expected at least <span class="number">1</span> bean which qualifies as autowire candidate <span class="keyword">for</span> <span class="keyword">this</span> dependency. </span><br><span class="line">Dependency annotations: </span><br><span class="line">&#123;<span class="meta">@org</span>.springframework.beans.factory.annotation.Autowired(required=<span class="keyword">true</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们需要required解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> FooDAO dataAccessor; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="PropertySource注解"><a href="#PropertySource注解" class="headerlink" title="@PropertySource注解"></a>@PropertySource注解</h1><p>@PropertySource注解是Spring 3.1开始引入的配置类注解。通过@PropertySource注解将properties配置文件中的值存储到Spring的 Environment中，Environment接口提供方法去读取配置文件中的值，参数是properties文件中定义的key值。也可以使用@Value 注解用${}占位符注入属性</p>
<p>@PropertySource注解的源代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertySourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(PropertySources.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PropertySource &#123;</span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">	String[] value();</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">	Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> PropertySourceFactory.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从@PropertySource的源码可以看出，我们可以通过@PropertySource注解指定多个properties文件，可以使用如下形式进行指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value=&#123;&quot;classpath:xxx.properties&quot;, &quot;classpath:yyy.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>细心的读者可以看到，在@PropertySource注解类的上面标注了如下的注解信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(PropertySources.class)</span></span><br></pre></td></tr></table></figure>

<p>看到这里，小伙伴们是不是有种恍然大悟的感觉呢？没错，我们也可以使用@PropertySources注解来指定properties配置文件。</p>
<h2 id="通过注解注册一个配置文件"><a href="#通过注解注册一个配置文件" class="headerlink" title="通过注解注册一个配置文件"></a>通过注解注册一个配置文件</h2><p>我们可以将此注解与*@Configuration*注解结合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:foo.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesWithJavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种注册新属性文件的非常有用的方法是使用占位符，它允许我们<strong>在运行时动态选择正确的文件</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123; </span></span><br><span class="line"><span class="meta">  &quot;classpath:persistence-$&#123;envTarget:mysql&#125;.properties&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="定义多个属性位置"><a href="#定义多个属性位置" class="headerlink" title="定义多个属性位置"></a>定义多个属性位置</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html">根据 Java 8 约定</a>，@ <em>PropertySource</em>注释是可重复的。因此，如果我们使用 Java 8 或更高版本，我们可以使用此注释来定义多个属性位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:foo.properties&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:bar.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesWithJavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，<strong>我们也可以使用@PropertySources注解，指定一个@PropertySource数组。</strong>这适用于任何受支持的 Java 版本，而不仅仅是 Java 8 或更高版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySources(&#123;</span></span><br><span class="line"><span class="meta">    @PropertySource(&quot;classpath:foo.properties&quot;),</span></span><br><span class="line"><span class="meta">    @PropertySource(&quot;classpath:bar.properties&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesWithJavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任何一种情况下，值得注意的是，在发生属性名称冲突的情况下，最后一个源读取优先。</p>
<h2 id="使用-注入属性"><a href="#使用-注入属性" class="headerlink" title="使用/注入属性"></a>使用/注入属性</h2><p><strong>使用@Value注释</strong>注入属性很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value( &quot;$&#123;jdbc.url&#125;&quot; )</span></span><br><span class="line"><span class="keyword">private</span> String jdbcUrl;</span><br></pre></td></tr></table></figure>

<p><strong>我们还可以为属性指定一个默认值：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value( &quot;$&#123;jdbc.url:aDefaultUrl&#125;&quot; )</span></span><br><span class="line"><span class="keyword">private</span> String jdbcUrl;</span><br></pre></td></tr></table></figure>

<p>Spring 3.1 中添加的新<em>PropertySourcesPlaceholderConfigurer**</em>解析了 bean 定义属性值和@Value注释中的${…} 占位符**。</p>
<p>最后，我们可以 <strong>使用Environment API获取属性的值</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line">...</span><br><span class="line">dataSource.setUrl(env.getProperty(<span class="string">&quot;jdbc.url&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot-的属性"><a href="#Spring-Boot-的属性" class="headerlink" title="Spring Boot 的属性"></a>Spring Boot 的属性</h2><p>在我们进入更高级的属性配置选项之前，让我们花点时间看看 Spring Boot 中的新属性支持。</p>
<p>一般来说，<strong>与标准 Spring 相比</strong>，<strong>这种新支持涉及的配置更少</strong>，这当然是 Boot 的主要目标之一。</p>
<h3 id="application-properties：默认属性文件"><a href="#application-properties：默认属性文件" class="headerlink" title="application.properties：默认属性文件"></a>application.properties：默认属性文件</h3><p>Boot 将其典型的约定应用于属性文件的配置方法。这意味着<strong>我们可以简单地将application.properties文件放在我们的src/main/resources 目录中，它将被自动检测</strong>。然后我们可以像往常一样从它注入任何加载的属性。</p>
<p>因此，通过使用此默认文件，我们不必显式注册<em>PropertySource</em> ，甚至不必提供属性文件的路径。</p>
<p>从<em>2.4.0</em>版本开始，<strong>Spring Boot 支持使用多文档属性文件</strong>，类似于<a target="_blank" rel="noopener" href="https://yaml.org/spec/1.2/spec.html#id2760395">YAML</a>的设计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baeldung.customProperty=defaultValue</span><br><span class="line">#---</span><br><span class="line">baeldung.customProperty=overriddenValue</span><br></pre></td></tr></table></figure>

<p>请注意，对于属性文件，三个破折号符号前面有一个注释字符 ( <em>#</em> )。</p>
<h3 id="特定于环境的属性文件"><a href="#特定于环境的属性文件" class="headerlink" title="特定于环境的属性文件"></a><strong>特定于环境的属性文件</strong></h3><p>如果我们需要针对不同的环境，Boot 中有一个内置的机制。</p>
<p><strong>我们可以简单地在src/main/resources目录下定义一个application-environment.properties文件，然后设置一个具有相同环境名称的 Spring 配置文件。</strong></p>
<p>例如，如果我们定义一个“暂存”环境，这意味着我们必须定义一个<em>暂存</em>配置文件，然后是<em>application-staging.properties</em>。</p>
<p>此 env 文件将被加载并<strong>优先于默认属性文件。</strong>注意，默认文件还是会被加载，只是当发生属性冲突时，特定于环境的属性文件优先。<strong>替代方案：YAML 文件</strong></p>
<p>Spring 还支持 YAML 文件。</p>
<p>所有相同的命名规则都适用于特定于测试、特定于环境和默认属性文件。唯一的区别是文件扩展名和对我们类路径上的<a target="_blank" rel="noopener" href="https://bitbucket.org/asomov/snakeyaml">SnakeYAML</a>库的依赖。</p>
<p><strong>YAML 特别适合分层属性存储</strong>；以下属性文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database.url=jdbc:postgresql:/localhost:5432/instance</span><br><span class="line">database.username=foo</span><br><span class="line">database.password=bar</span><br><span class="line">secret: foo</span><br></pre></td></tr></table></figure>

<p>与以下 YAML 文件同义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">database:</span><br><span class="line">  url: jdbc:postgresql:/localhost:5432/instance</span><br><span class="line">  username: foo</span><br><span class="line">  password: bar</span><br><span class="line">secret: foo</span><br></pre></td></tr></table></figure>

<p>还值得一提的是，YAML 文件不支持*@PropertySource*注解，所以如果我们需要使用这个注解，它会限制我们使用属性文件。</p>
<p>另一个值得注意的地方是，在 2.4.0 版本中，Spring Boot 改变了从多文档 YAML 文件加载属性的方式。以前，它们的添加顺序基于配置文件激活顺序。然而，在新版本中，框架遵循我们之前为*.properties*文件指出的相同排序规则；在文件中声明较低的属性将简单地覆盖那些较高的属性。</p>
<p>此外，在此版本中，配置文件无法再从配置文件特定文档中激活，从而使结果更清晰、更可预测。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/19/Macbook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/19/Macbook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Macbook使用技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-19 16:34:26 / 修改时间：20:13:06" itemprop="dateCreated datePublished" datetime="2021-10-19T16:34:26+08:00">2021-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="批量更改文件名称"><a href="#批量更改文件名称" class="headerlink" title="批量更改文件名称"></a>批量更改文件名称</h1><p>对我而言这个功能最好用的是批量更改时替换功能，在截了一堆图需要改名字的时候就可以派上用场。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/batchRename1.png"></p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/batchRename2.png"></p>
<h1 id="聚焦Spotlight"><a href="#聚焦Spotlight" class="headerlink" title="聚焦Spotlight"></a>聚焦<strong>Spotlight</strong></h1><p>“聚焦”可以帮助您快速找到 Mac 上的 App、文稿和其他文件。借助 Siri 建议，您还可以获取最新新闻、体育赛事比分、天气状况等信息。“聚焦”甚至可以为您进行计算和转换。</p>
<h2 id="搜索内容"><a href="#搜索内容" class="headerlink" title="搜索内容"></a>搜索内容</h2><ol>
<li><p>在 Mac 上，点按<a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/guide/mac-help/aside/glos33eb8abd/11.0/mac/11.0">菜单栏</a>中的“聚焦”图标 <img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/bb4de0babc81c7fedb3e9663d00d7a3a.png" alt="img" style="zoom:25%;" />（如果显示），或者按下 Command-空格键或按下键盘上功能键行中的 <img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/bb4de0babc81c7fedb3e9663d00d7a3a.png" alt="聚焦键" style="zoom:25%;" />（如果可用）。</p>
<p>您可以将“聚焦”窗口拖到桌面上的任意位置。</p>
<p><strong>【提示】</strong>如果“聚焦”图标未显示在菜单栏中，请<a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/guide/mac-help/mchlp1119/11.0/mac/11.0">使用“程序坞与菜单栏”偏好设置</a>进行添加。</p>
</li>
<li><p>在搜索栏中，键入要查找的内容，键入时结果会随之出现。</p>
<p>“聚焦”首先列出最常点选，点按一个最常点选以进行预览或打开。“聚焦”还会建议搜索的各种变体；您可以在“聚焦”或网上查看这些结果。</p>
<p><img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/5026e0adf32c51825c1daf163ec73501.png" alt="“聚焦”窗口顶部显示了搜索栏中的搜索文本，下方是结果。"></p>
</li>
<li><p>在结果中，执行以下任一项操作：</p>
<ul>
<li><em>显示预览：</em>按下 Tab 键。根据结果中所选的项目类型，您可以与之交互。例如，选择 App 以查看最近打开文件的列表，然后点按以打开文件。或者点按“播放”按钮来聆听歌曲。</li>
</ul>
</li>
</ol>
<h2 id="在“聚焦”中进行计算和转换"><a href="#在“聚焦”中进行计算和转换" class="headerlink" title="在“聚焦”中进行计算和转换"></a>在“聚焦”中进行计算和转换</h2><p>您可以在“聚焦”搜索栏中输入数学表达式、金额、温度或单位，搜索栏中会立即显示转换或计算结果。</p>
<p><img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/6136d2d5c08bb8b6ebf10fc3c3248f48.png" alt="“聚焦”窗口，显示搜索栏中从码到米的转换。左侧是搜索结果列表。右侧预览中显示更多转换。"></p>
<ul>
<li><em>计算：</em>输入数学表达式，如 956*23.94 或 2020/15。</li>
<li><em>货币转换：</em>输入金额，如 100 美元、100 日元或“300 克朗转换成欧元”。</li>
<li><em>温度转换：</em>输入温度，如 98.8F、32C 或“340K 转换成华氏度”。</li>
<li><em>单位转换：</em>输入度量单位，例如 25 磅、54 码、23 英石或“32 英尺转换成米”。</li>
</ul>
<p><strong>【提示】</strong>按下 Tab 键以在预览区域中显示更多转换。</p>
<h1 id="快速添加emoji表情"><a href="#快速添加emoji表情" class="headerlink" title="快速添加emoji表情"></a>快速添加emoji表情</h1><p>按住键盘Control+Command+空格键，此时你的输入栏中，就会跳出所有表情了。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/emoji.png"></p>
<p>​                </p>
<h1 id="快速锁屏"><a href="#快速锁屏" class="headerlink" title="快速锁屏"></a>快速锁屏</h1><p>只需按住control+command+Q，此时你的MacBook就会马上锁屏</p>
<hr>
<h1 id="向后删除"><a href="#向后删除" class="headerlink" title="向后删除"></a>向后删除</h1><p>文本编辑时按 Fn + Delete 键可向后删除内容</p>
<hr>
<h1 id="切换应用程序"><a href="#切换应用程序" class="headerlink" title="切换应用程序"></a>切换应用程序</h1><p>按住command键再按tab键，可从左往右切换已打开的应用程序；command+shift+tab，可从右往左切换</p>
<hr>
<h1 id="触控板手势"><a href="#触控板手势" class="headerlink" title="触控板手势"></a>触控板手势</h1><p>Mac触控板强大无比，掌握触控板使用技能，对提高学习工作效率大有帮助，打开Mac系统偏好设置中的触控板，选择相应手势，右边会有动画教程。</p>
<p>还有一个比较特殊的手势，三指拖动，需在系统偏好设置下的辅助功能中设置。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/split.png"></p>
<hr>
<h1 id="设置文件默认打开方式"><a href="#设置文件默认打开方式" class="headerlink" title="设置文件默认打开方式"></a>设置文件默认打开方式</h1><p>不同格式的文件有不同的默认打开方式，比如视频文件会默认用QuickTime Player打开，如果你想更改系统默认的打开方式，按照如下步骤设置即可，</p>
<p>单击你想要改变默认打开方式的文件，右键单击选择显示简介，或者按快捷键Command+i 显示简介；</p>
<p>在打开方式的下拉菜单中选择你需要的默认打开方式，点击全部更改，在弹出的窗口中选择继续即可。</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/softopentype.png" style="zoom: 50%;" />

<hr>
<h1 id="自带截屏"><a href="#自带截屏" class="headerlink" title="自带截屏"></a>自带截屏</h1><ul>
<li><p>cmd+shift+3：对整个屏幕进行截图；</p>
</li>
<li><p>cmd+shift+4：对自行选择的区域进行截图；</p>
</li>
<li><p>cmd+shift+4+space（空格键）：对选定的某个应用程序界面窗口进行截图。</p>
</li>
</ul>
<hr>
<h1 id="Command（或-Cmd）⌘键"><a href="#Command（或-Cmd）⌘键" class="headerlink" title="Command（或 Cmd）⌘键"></a>Command（或 Cmd）⌘键</h1><p>以下是常用的12个快捷键：</p>
<ul>
<li>Command + X: 剪切</li>
<li>Command + C: 拷贝</li>
<li>Command + V: 原格式粘贴</li>
<li>Command + Shift +Option +V: 合并格式粘贴</li>
<li>Command + Z: 撤销上一个操作（Shift + Command + Z: 反向执行撤销命令）</li>
<li>Command + W: 关闭但不退出应用</li>
<li>Command + Q: 退出应用</li>
<li>Command + Option + Esc: 强制退出应用</li>
<li>Command + Tab: 切换应用</li>
<li>Command + 空格: “聚焦”查找</li>
<li>Command + Shift + 5（MacOS Mojave系统）: 截屏或录屏（其他MacOS: Command + Shift +3: 捕捉整个屏幕；Command + Shift +4: 自选截屏区域）</li>
<li>Command + Control + 空格: 添加emoji</li>
</ul>
<p>Command键除了上面 提到的常用组合快捷键外，还有很多其他功能，这里介绍四个关于Command的隐藏功能</p>
<ul>
<li>按住Command，可以选择并移动菜单栏图标</li>
</ul>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/top.png"></p>
<ul>
<li>在“聚焦”中搜索文件，按住Command就可以显示文件路径，按住Command打开文件可以打开所在的文件夹</li>
</ul>
<h1 id="Option（或-Alt）⌥键"><a href="#Option（或-Alt）⌥键" class="headerlink" title="Option（或 Alt）⌥键"></a>Option（或 Alt）⌥键</h1><ul>
<li><p>按住Option，可以同时关闭同个程序的多个窗口</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/optioncloaseall.png" style="zoom:67%;" />
</li>
<li><p>按住Option，单击右侧翻页条任何位置，就可以快速跳到指定位置</p>
</li>
<li><p>『移动文件』CMD+C 复制文件，在目标目录 CMD+Option+V，就把原文件移动过来了，相当于剪切粘贴。</p>
</li>
<li><p>按住Option+拖到文件，可快速复制一份原文件</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/09/Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/09/Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/" class="post-title-link" itemprop="url">Javascript闭包（Closure）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-09 12:18:51" itemprop="dateCreated datePublished" datetime="2021-10-09T12:18:51+08:00">2021-10-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-23 14:25:18" itemprop="dateModified" datetime="2021-10-23T14:25:18+08:00">2021-10-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h1><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　alert(n);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　n=<span class="number">999</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1();</span><br><span class="line"></span><br><span class="line">　　alert(n); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<h2 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h2><p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n); <span class="comment">// 999</span></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>专业的讲，一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
<p>我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>上一节代码中的f2函数，就是闭包。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h1 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h1><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解这句话呢？请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h1 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h1><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/27/SpringBoot%E9%A1%B9%E7%9B%AE%E6%8A%A5%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%E7%9A%84%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/27/SpringBoot%E9%A1%B9%E7%9B%AE%E6%8A%A5%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%E7%9A%84%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">SpringBoot项目报端口冲突的错误</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 08:38:58" itemprop="dateCreated datePublished" datetime="2021-09-27T08:38:58+08:00">2021-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近运行Springboot项目是，报了一个端口号被占用的错</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Web server failed to start. Port 10000 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#x27;s listening on port 10000 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/springbooterr.png"></p>
<p>报错原因：端口被占用。</p>
<p>解决办法</p>
<p>1.使用cmd命令查看端口号占用情况，例如查看端口10000，可以看出进程号为5372；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 10000</span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/findport.png"></p>
<p>2.关闭该进程</p>
<p>方法一： 使用命令关闭</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /F /pid 5372 </span><br></pre></td></tr></table></figure>

<p>如果是非管理员用户可能报拒绝访问的错误</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/confusetoaccess.png"></p>
<p>重新以管理员的身份打开cmd窗口，重新运行以上的关闭进程命令</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/opencmd.png"></p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/killtaskpidZ.png"></p>
<p>方法二：使用任务管理器关闭：</p>
<p>菜单栏 -&gt; 右键 - &gt; 任务管理器 -&gt; 详细信息，根据PID排序找到PID为5372的进程，选择后点击结束任务。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/killtask.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/22/%E8%A7%A3%E5%86%B3Mysql5-7%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AFRestarting-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/22/%E8%A7%A3%E5%86%B3Mysql5-7%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AFRestarting-1/" class="post-title-link" itemprop="url">解决Mysql5.7一直重启Restarting(1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-22 16:16:44" itemprop="dateCreated datePublished" datetime="2021-09-22T16:16:44+08:00">2021-09-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>优于长时间没进Linux连接mysql，今天进入Linux连接mysql，使用<code>docker ps</code>，mysql的状态一直是Restarting (1) x seconds ago，mysql一直在重启无法连接</p>
<p>查看日志</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs mysql</span><br></pre></td></tr></table></figure>

<p>发现是内存不足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">2021-06-14T11:41:26.576589Z 0 [ERROR] InnoDB: Error number 28 means &#39;No space left on device&#39;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>使用 df -h 查看 发现是 /var/docker/overlay2里面的东西占了很大的空间</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/linuxdfh.png"></p>
<p>检查内存占用情况，发现vagrant占用36G，一路找下去，发现到application data目录无线循环，上网搜索发现了问题所在。</p>
<p><strong>ls查看发现里的东西很多和我本机C盘里的文件一模一样 AppData之类的 为什么这些东西会在虚拟机里 虚拟机同步了C盘里的内容 百度发现 vagrant提供了将本机</strong></p>
<p><strong>目录挂载到虚拟机目录下的功能，默认是将vagrant配置文件所在目录挂载到虚拟机/vagrant目录下。</strong></p>
<p><strong>也就是说 我的VagrantFile 是 C/user/username/VagrantFile 那么所有和VagrantFile同级的 C/user/username/里面的内容会全部同步到vagrant中 导致虚拟机内存爆满</strong></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ol>
<li><p>在和Vagrantfile同级目录（C:\Users\Administrator\）创建一个自己的文件夹,我的叫VagrantSyncFolder</p>
</li>
<li><p>然后打开目录到C:\Users\Administrator.vagrant.d\boxes\centos-VAGRANTSLASH-7\2004.01\virtualbox</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/vagrantfile.png"></p>
</li>
<li><p>打开Vagrantfile，</p>
<p>config.vm.synced_folder “.”, “/vagrant”, type: “rsync”</p>
<p>修改为</p>
<p>config.vm.synced_folder “./vagrantCache”, “/vagrant”, type: “rsync”</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/changevagrantfile.png"></p>
</li>
<li><p>修改完这个之后,vagrant reload发现还是不行,猜测可能只有vagrant成功重启之后修改的这个映射才能生效,但是已经占用100%不能成功重启,没办法,只能删东</p>
<p>西了</p>
<p>查看了一下vagrant目录里文件的大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/cdvagrant.png"></p>
<p>其中AppData很大</p>
<p>试着删了一下3D Objects文件里的一些东西,发现文件里的文件并没有影响,ok,直接将AppData删了,释放了很大的空间，然后exit退出</p>
<p>vagrant reload重启，大功告成！</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/vagrantreload.png"></p>
</li>
</ol>
<p>其实这种情况，可能在使用vagrant  up命令的时候就会报Rsync 错误，可以参考这篇文章，其问题和上方的一样</p>
<p><a target="_blank" rel="noopener" href="https://www.dissmeyer.com/2020/02/11/issue-with-centos-7-vagrant-boxes-on-windows-10/">Windows 10 上的 CentOS 7 Vagrant 框出现 Rsync 错误</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/Vue3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/11/Vue3/" class="post-title-link" itemprop="url">Vue3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-11 19:52:10" itemprop="dateCreated datePublished" datetime="2021-09-11T19:52:10+08:00">2021-09-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>2020年9月18日Vue.js 3.0“海贼王”正式发布。该框架的这个新主要版本提供了改进的性能、更小的包大小、更好的 TypeScript 集成、用于处理大规模用例的新 API，以及该框架未来长期迭代的坚实基础。</p>
<p>特点：</p>
<ul>
<li>随着时间的推移，它演变成我们所说的“渐进式框架”：一个可以逐渐学习和采用的框架，同时随着用户处理越来越多的要求的场景提供持续的支持。</li>
<li>Vue 3.0 核心仍然可以通过一个简单的<code>&lt;script&gt;</code>标签使用，但它的内部已经从头开始重写为<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/tree/master/packages">一组解耦模块</a>。新架构提供了更好的可维护性，并允许最终用户通过 tree-shaking 将运行时大小减少一半。</li>
<li>2.x 基于对象的 API 在 Vue 3 中基本保持不变。但是，3.0 还引入了<a target="_blank" rel="noopener" href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API——</a>一组新的 API，旨在解决 Vue 在大规模应用程序中使用的痛点。</li>
<li>性能改进</li>
<li>Vue 3 的代码库是用 TypeScript 编写的，具有自动生成、测试和捆绑的类型定义，因此它们始终是最新的</li>
</ul>
<h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="使用-vue-cli-创建Vue3-0工程"><a href="#使用-vue-cli-创建Vue3-0工程" class="headerlink" title="使用 vue-cli 创建Vue3.0工程"></a>使用 vue-cli 创建Vue3.0工程</h2><p>先查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<p>如果版本过低，就需要安装或者升级你的@vue/cli</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>

<p>运行以下命令来创建一个新项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure>

<p>启动项目</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-world</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h1 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a><code>setup</code></h2><p>使用 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，<strong>逻辑关注点</strong>的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/options-api.png"></p>
<p>这是一个大型组件的示例，其中<strong>逻辑关注点</strong>按颜色进行分组。</p>
<p>这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块。</p>
<p>如果能够将同一个逻辑关注点相关代码收集在一起会更好。</p>
<p><span style="color:red"><strong>setup的设计是为了使用组合式api，使相关逻辑的代码集中在一起.</strong></span></p>
<h3 id="setup-组件选项"><a href="#setup-组件选项" class="headerlink" title="setup 组件选项"></a><code>setup</code> 组件选项</h3><p>新的 <code>setup</code> 选项在<strong>组件创建之前</strong>执行，一旦 <code>props</code> 被解析，就将作为组合式 API 的入口。</p>
<blockquote>
<p><span style="color:orange">在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例。<code>setup</code> 的调用发生在 <code>data</code> property、<code>computed</code> property 或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。</span></p>
</blockquote>
<p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数，此外，我们将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">prop,context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;prop:&quot;</span>,prop)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;context:&quot;</span>,context)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125; <span class="comment">// 这里返回的任何内容都可以用于组件的其余部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>setup</code> 函数时，它将接收两个参数：</p>
<ol>
<li><code>props</code></li>
<li><code>context</code></li>
</ol>
<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 prop 时，它将被更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:orange">但是，因为 <code>props</code> 是响应式的，你<strong>不能使用 ES6 解构</strong>，它会消除 prop 的响应性。</span></p>
</blockquote>
<p>如果需要解构 prop，可以在 <code>setup</code> 函数中使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84"><code>toRefs</code></a> 函数来完成此操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>title</code> 是可选的 prop，则传入的 <code>props</code> 中可能没有 <code>title</code> 。在这种情况下，<code>toRefs</code> 将不会为 <code>title</code> 创建一个 ref 。你需要使用 <code>toRef</code> 替代它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> title = toRef(props, <span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>props</code>在浏览器的控制台输出如下图：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3props.png"></p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露组件的三个 property：</p>
<p>的三个 property：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Attribute (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插槽 (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件 (方法)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, &#123; attrs, slots, emit &#125;</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。</p>
<p><code>context</code>在浏览器的控制台输出如下图：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3context.png"></p>
<p><code>setup</code>注意点：</p>
<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
<li><strong>在 <code>setup()</code> 内部，<code>this</code> 不是该活跃实例的引用</strong></li>
</ol>
<p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p>
<ul>
<li><code>props</code></li>
<li><code>attrs</code></li>
<li><code>slots</code></li>
<li><code>emit</code></li>
</ul>
<p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p>
<ul>
<li><code>data</code></li>
<li><code>computed</code></li>
<li><code>methods</code></li>
</ul>
<hr>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property <code>.value</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count.value++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    countAdd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将对象分配为 ref 值，则通过 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive">reactive</a> 方法使该对象具有高度的响应式。</p>
<p>使用数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>count: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;countAdd&quot;</span>&gt;</span>count++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 使用了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
<hr>
<h2 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h2><p>返回对象的响应式副本，Proxy的实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:green"><code>reactive</code> 将解包所有深层的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">refs</a>，同时维持 ref 的响应性。</span></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123; count &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref 会被解包</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count === count.value) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它会更新 `obj.count`</span></span><br><span class="line">count.value++</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它也会更新 `count` ref</span></span><br><span class="line">obj.count++</span><br><span class="line"><span class="built_in">console</span>.log(obj.count) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue3-0中的响应式原理"><a href="#Vue3-0中的响应式原理" class="headerlink" title="Vue3.0中的响应式原理"></a>Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li><p>实现原理: </p>
<ul>
<li><p>通过Proxy（代理）:  <strong>Proxy 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。</strong></p>
</li>
<li><p>通过Reflect（反射）:  使用 Proxy 的一个难点是 <code>this</code> 绑定。我们希望任何方法都绑定到这个 Proxy，而不是目标对象，这样我们也可以拦截它们。值得庆幸的是，ES6 引入了另一个名为 <code>Reflect</code> 的新特性，它允许我们以最小的代价消除了这个问题：</p>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure>

<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>有时我们需要依赖于其他状态的状态——在 Vue 中，这是用组件<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8">计算属性</a>处理的，以直接创建计算值，我们可以使用 <code>computed</code> 方法：它接受 getter 函数并为 getter 返回的值返回一个不可变的响应式 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%80%BC%E4%BD%9C%E4%B8%BA-refs">ref</a> 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> person = reactive(&#123;</span><br><span class="line">    firstName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  person.fullName = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> person.firstName + <span class="string">&#x27; &#x27;</span> + person.lastName</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   person</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请输入姓名<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>firstName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.firstName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.lastName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>fullName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; person.fullName &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3computed.png" style="zoom: 80%;" />

<p>或者，它可以使用一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> person = reactive(&#123;</span><br><span class="line">      firstName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      lastName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    person.fullName = computed(&#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> person.firstName + <span class="string">&quot; &quot;</span> + person.lastName;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> names = newValue.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        person.firstName = names[<span class="number">0</span>];</span><br><span class="line">        person.lastName = names[names.length - <span class="number">1</span>];</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      person,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>使用数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请输入姓名<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>fullName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.fullName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>firstName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; person.firstName &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; person.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3computed1.png" style="zoom:80%;" />

<hr>
<h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。</p>
<h4 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h4><p>侦听器数据源可以是返回值的 getter 函数，也可以直接是 <code>ref</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h4><p>侦听器还可以使用数组同时侦听多个源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = ref(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> lastName = ref(<span class="string">&quot;san&quot;</span>);</span><br><span class="line"></span><br><span class="line">watch([firstName, lastName], <span class="function">(<span class="params">newValues, prevValues</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValues, prevValues);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeFirstName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  firstName.value = <span class="string">&quot;Steve&quot;</span>; <span class="comment">// logs: [&quot;Steve&quot;, &quot;san&quot;] [&quot;zhang&quot;, &quot;san&quot;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeLastName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  lastName.value = <span class="string">&quot;Jobs&quot;</span>;  <span class="comment">// logs: [&quot;zhang&quot;, &quot;Jobs&quot;] [&quot;zhang&quot;, &quot;san&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管如此，如果你在同一个方法里同时改变这些被侦听的来源，侦听器仍只会执行一次：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeFullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  firstName.value = <span class="string">&quot;Steve&quot;</span>;</span><br><span class="line">  lastName.value = <span class="string">&quot;Jobs&quot;</span>;</span><br><span class="line">  <span class="comment">// 打印 [&quot;Steve&quot;, &quot;Jobs&quot;] [&quot;zhang&quot;, &quot;san&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意多个同步更改只会触发一次侦听器。</p>
<p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、默认已经强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<hr>
<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><ul>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li><p>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</p>
</li>
<li><p>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line">watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.value</span><br><span class="line">    <span class="keyword">const</span> x2 = person.age</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/lifecycle.svg"  />

<p>下表包含如何在 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup ()</a> 内部调用生命周期钩子：</p>
<table>
<thead>
<tr>
<th>选项式 API</th>
<th>Hook inside <code>setup</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>beforeCreate</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>created</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>beforeMount</code></td>
<td><code>onBeforeMount</code></td>
</tr>
<tr>
<td><code>mounted</code></td>
<td><code>onMounted</code></td>
</tr>
<tr>
<td><code>beforeUpdate</code></td>
<td><code>onBeforeUpdate</code></td>
</tr>
<tr>
<td><code>updated</code></td>
<td><code>onUpdated</code></td>
</tr>
<tr>
<td><code>beforeUnmount</code></td>
<td><code>onBeforeUnmount</code></td>
</tr>
<tr>
<td><code>unmounted</code></td>
<td><code>onUnmounted</code></td>
</tr>
<tr>
<td><code>errorCaptured</code></td>
<td><code>onErrorCaptured</code></td>
</tr>
<tr>
<td><code>renderTracked</code></td>
<td><code>onRenderTracked</code></td>
</tr>
<tr>
<td><code>renderTriggered</code></td>
<td><code>onRenderTriggered</code></td>
</tr>
<tr>
<td><code>activated</code></td>
<td><code>onActivated</code></td>
</tr>
<tr>
<td><code>deactivated</code></td>
<td><code>onDeactivated</code></td>
</tr>
</tbody></table>
<blockquote>
<p><span style="color:green">因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写。</span></p>
</blockquote>
<h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a><code>toRef</code></h2><p>可以用来为源响应式对象上的某个 property 新创建一个 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = toRef(state, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fooRef.value++</span><br><span class="line"><span class="built_in">console</span>.log(state.foo) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">state.foo++</span><br><span class="line"><span class="built_in">console</span>.log(fooRef.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a><code>toRefs</code></h2><p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>。</p>
<p>当从组合式函数返回响应式对象时，<code>toRefs</code> 非常有用，这样消费组件就可以在不丢失响应性的情况下对返回的对象进行分解/扩散：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFeatureX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作 state 的逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回时转换为ref</span></span><br><span class="line">  <span class="keyword">return</span> toRefs(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在不失去响应性的情况下解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toRefs</code> 只会为源对象中包含的 property 生成 ref。如果要为特定的 property 创建 ref，则应当使用 <code>toRef</code></p>
<hr>
<h1 id="其他-Composition-API"><a href="#其他-Composition-API" class="headerlink" title="其他 Composition API"></a>其他 Composition API</h1><h2 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h2><ul>
<li><p><code>shallowReactive</code>：创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 state 本身的性质是响应式的</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="comment">// ...但是不转换嵌套对象</span></span><br><span class="line">isReactive(state.nested) <span class="comment">// false</span></span><br><span class="line">state.nested.bar++ <span class="comment">// 非响应式</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>shallowRef</code>：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = shallowRef(&#123;&#125;)</span><br><span class="line"><span class="comment">// 改变 ref 的值是响应式的</span></span><br><span class="line">foo.value = &#123;&#125;</span><br><span class="line"><span class="comment">// 但是这个值不会被转换。</span></span><br><span class="line">isReactive(foo.value) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么时候使用?</p>
<ul>
<li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; <code>shallowReactive</code>。</li>
<li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; <code>shallowRef</code>。</li>
</ul>
</li>
</ul>
<h2 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h2><ul>
<li><p><code>readonly</code>: 接受一个对象 (响应式或纯对象) 或 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = readonly(original)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用于响应性追踪</span></span><br><span class="line">  <span class="built_in">console</span>.log(copy.count)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更 original 会触发依赖于副本的侦听器</span></span><br><span class="line">original.count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更副本将失败并导致警告</span></span><br><span class="line">copy.count++ <span class="comment">// 警告!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shallowReadonly</code>：创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReadonly(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 state 本身的 property 将失败</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="comment">// ...但适用于嵌套对象</span></span><br><span class="line">isReadonly(state.nested) <span class="comment">// false</span></span><br><span class="line">state.nested.bar++ <span class="comment">// 适用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景: 不希望数据被修改时。</p>
</li>
</ul>
<h2 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h2><ul>
<li><p>toRaw：</p>
<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li><p>markRaw：</p>
<ul>
<li><p>作用：标记一个对象，使其永远不会再成为响应式对象。返回对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = markRaw(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(reactive(foo))) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套在其他响应式对象中时也可以使用</span></span><br><span class="line"><span class="keyword">const</span> bar = reactive(&#123; foo &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(bar.foo)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red">有些值不应该是响应式的，例如复杂的第三方类实例或 Vue 组件对象</span></p>
<p><span style="color:red">当渲染具有不可变数据源的大列表时，跳过 proxy 转换可以提高性能。</span></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h2><p>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收 <code>track</code> 和 <code>trigger</code> 函数作为参数，并且应该返回一个带有 <code>get</code> 和 <code>set</code> 的对象。</p>
<p>自定义customRef配合自定义hook函数使用。</p>
<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。类似于vue2.x中的mixin。自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
<p>在项目中新建hooks文件夹，在hooks文件夹下新建useDebounce.js文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, delay = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout</span><br><span class="line">    <span class="keyword">return</span> customRef(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          track()</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">          timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            value = newValue</span><br><span class="line">            trigger()</span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义 ref 通过 <code>v-model</code> 实现 debounce 的示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useDebouncedRef <span class="keyword">from</span> <span class="string">&#x27;../hooks/useDebounce&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: useDebouncedRef(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><p>通常，当我们需要从父组件向子组件传递数据时，我们使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-props.html">props</a>。想象一下这样的结构：有一些深度嵌套的组件，而深层的子组件只需要父组件的部分内容。在这种情况下，如果仍然将 prop 沿着组件链逐级传递下去，可能会很麻烦。</p>
<p>对于这种情况，我们可以使用一对 <code>provide</code> 和 <code>inject</code>。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这些数据。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/components_provide.png"></p>
<p>用法:</p>
<p>父组件中提供：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = reactive(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    provide(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件中使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props,context</span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = inject(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<hr>
<h1 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h1><p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>
<p>让我们修改 <code>modal-button</code> 以使用 <code>&lt;teleport&gt;</code>，并告诉 Vue “<strong>Teleport</strong> 这个 HTML <strong>到</strong>该‘<strong>body</strong>’标签”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;modal-button&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;modalOpen = true&quot;&gt;</span></span><br><span class="line"><span class="string">        Open full screen modal! (With teleport!)</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;teleport to=&quot;body&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">          I&#x27;m a teleported modal! </span></span><br><span class="line"><span class="string">          (My parent is &quot;body&quot;)</span></span><br><span class="line"><span class="string">          &lt;button @click=&quot;modalOpen = false&quot;&gt;</span></span><br><span class="line"><span class="string">            Close</span></span><br><span class="line"><span class="string">          &lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      modalOpen: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="全局API的转移"><a href="#全局API的转移" class="headerlink" title="全局API的转移"></a>全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  inserted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close&#x3D;&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click&#x3D;&quot;handleNativeClickEvent&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#39;close&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/09/Vue-Router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/Vue-Router/" class="post-title-link" itemprop="url">Vue Router</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-09 11:26:13" itemprop="dateCreated datePublished" datetime="2021-09-09T11:26:13+08:00">2021-09-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure>

<h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><h2 id="引入插件并使用"><a href="#引入插件并使用" class="headerlink" title="引入插件并使用"></a>引入插件并使用</h2><p>在<code>main.js</code>中引入插件并使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>

<h2 id="编写router配置项"><a href="#编写router配置项" class="headerlink" title="编写router配置项:"></a>编写router配置项:</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Chinese <span class="keyword">from</span> <span class="string">&quot;../pages/Chinese.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> English <span class="keyword">from</span> <span class="string">&quot;../pages/English.vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/chinese&#x27;</span>,</span><br><span class="line">            component: Chinese</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/english&#x27;</span>,</span><br><span class="line">            component: English</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用router"><a href="#使用router" class="headerlink" title="使用router"></a>使用router</h2><p>在<code>main.js</code>中引入<code>router</code>并使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router: router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="实现路由页面切换"><a href="#实现路由页面切换" class="headerlink" title="实现路由页面切换"></a>实现路由页面切换</h2><p>（active-class可配置高亮样式）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/chinese&quot;</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/english&quot;</span>&gt;</span>英文<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定组件渲染的位置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h2><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件。</p>
<p>配置路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/chinese&#x27;</span>,</span><br><span class="line">            component: Chinese</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/english&#x27;</span>,</span><br><span class="line">            component: English,</span><br><span class="line">            <span class="comment">//通过children配置子级路由</span></span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;book&#x27;</span>,</span><br><span class="line">                    component: Book</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">                    component: Author</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>路由跳转:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/english/book&quot;</span>&gt;</span>Book<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/english/author&quot;</span>&gt;</span>Author<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h1><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&#x27;chineseRouter&#x27;</span>,</span><br><span class="line">            path: <span class="string">&#x27;/chinese&#x27;</span>,</span><br><span class="line">            component: Chinese</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/english&#x27;</span>,</span><br><span class="line">            component: English,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: <span class="string">&#x27;bookRouter&#x27;</span>,</span><br><span class="line">                    path: <span class="string">&#x27;book&#x27;</span>,</span><br><span class="line">                    component: Book</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: <span class="string">&#x27;authorRouter&#x27;</span>,</span><br><span class="line">                    path: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">                    component: Author</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>路由跳转:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=<span class="string">&quot;/english/book&quot;</span>&gt;Book&lt;/router-link&gt;</span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;name : &#x27;bookRouter&#x27;&#125;&quot;</span>&gt;Book&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;</span>&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">  path: &#x27;/english/author/info&#x27;,</span></span><br><span class="line"><span class="string">  query: &#123;</span></span><br><span class="line"><span class="string">      id: author.id,</span></span><br><span class="line"><span class="string">      name: author.name,</span></span><br><span class="line"><span class="string">      info: author.info</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&quot;</span>&gt;</span><br><span class="line">&#123;&#123; author.name &#125;&#125;</span><br><span class="line">&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;    </span><br></pre></td></tr></table></figure>

<p>接收参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>编号: &#123;&#123;$route.query.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>作家: &#123;&#123;$route.query.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>简介: &#123;&#123;$route.query.info&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="路由的param参数"><a href="#路由的param参数" class="headerlink" title="路由的param参数"></a>路由的param参数</h1><p>在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;bookRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;book&#x27;</span>,</span><br><span class="line">        component: Book</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;authorRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">        component: Author,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;authorInfoRouter&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;info/:id/:name/:info&#x27;</span>,<span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">                component: AuthorInfo</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>路由跳转:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  name: &#x27;authorInfoRouter&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="string">  params: &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">      id: author.id,</span></span></span><br><span class="line"><span class="tag"><span class="string">      name: author.name,</span></span></span><br><span class="line"><span class="tag"><span class="string">      info: author.info</span></span></span><br><span class="line"><span class="tag"><span class="string">  &#125;</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; author.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red">特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</span></p>
</blockquote>
<p>接受参数:</p>
<p>当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>编号: &#123;&#123;$route.params.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>作家: &#123;&#123;$route.params.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>简介: &#123;&#123;$route.params.info&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h1><p>在上面的例子中，我们读取参数需要不停重复的写 <code>this.$route.params</code> 前缀，很繁琐，使用props配置可以解决</p>
<h2 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h2><p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性。</p>
<p>若<code>props</code>为true，就会把路由组件收到的所有<span style="color:red"><code>params</code></span>参数，以<code>props</code>的形式传给AuthorInfo组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;authorInfoRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;info/:id/:name/:info&#x27;</span>,</span><br><span class="line">        component: AuthorInfo,</span><br><span class="line">        props: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>使用<code>props</code> 配置项接受参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    props: [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;info&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//这里存放数据</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>使用参数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>编号: &#123;&#123;id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>作家: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>简介: &#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h2><p>你可以创建一个函数返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;authorInfoRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">        component: AuthorInfo,</span><br><span class="line">        <span class="function"><span class="title">props</span>(<span class="params">$route</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                id: $route.query.id,</span><br><span class="line">                name: $route.query.name,</span><br><span class="line">                info: $route.query.info</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>props</code>函数的结构赋值形式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">props</span>(<span class="params">&#123;query: &#123;id, name, info&#125;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        name: name,</span><br><span class="line">        info: info</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lt-router-link-gt-的replace属性"><a href="#lt-router-link-gt-的replace属性" class="headerlink" title="&lt;router-link&gt;的replace属性"></a><code>&lt;router-link&gt;</code>的replace属性</h1><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录（相当于向一个栈中添加元素），<code>replace</code>是替换当前记录（相当于替换掉栈顶元素）。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h1 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h1><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法<code>push</code>，通过编写代码来实现。</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td><code>router.push(...)</code></td>
</tr>
</tbody></table>
<p><strong>注意：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</strong></p>
<p><code>router.push(location, onComplete?, onAbort?)</code></p>
<p>可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; </span><br><span class="line">    name: <span class="string">&#x27;user&#x27;</span>, </span><br><span class="line">    params: &#123; </span><br><span class="line">        userId: <span class="string">&#x27;123&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; </span><br><span class="line">    path: <span class="string">&#x27;register&#x27;</span>, </span><br><span class="line">    query: &#123; </span><br><span class="line">        plan: <span class="string">&#x27;private&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，使用<code>params</code>就不用<code>path</code>，而是用<code>name</code></strong></p>
<p><code>router.replace(location, onComplete?, onAbort?)</code></p>
<p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录，相当于替换掉栈顶元素。</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td><code>router.replace(...)</code></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.replace(&#123; </span><br><span class="line">    path: <span class="string">&#x27;register&#x27;</span>, </span><br><span class="line">    query: &#123; </span><br><span class="line">        plan: <span class="string">&#x27;private&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>forward</code>  、<code>back</code>  、<code>go</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.forward() <span class="comment">//前进</span></span><br><span class="line"><span class="built_in">this</span>.$router.back() <span class="comment">//后退</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(-<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><ul>
<li><p><strong>Props</strong>：</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>
<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>
</li>
</ul>
<p>主要用于保留组件状态或避免重新渲染。</p>
<p><code>include</code> 和 <code>exclude</code> prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组（组件名）来表示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;News&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="路由相关的两个生命周期钩子"><a href="#路由相关的两个生命周期钩子" class="headerlink" title="路由相关的两个生命周期钩子"></a>路由相关的两个生命周期钩子</h1><h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件激活时调用。</p>
</li>
<li><p><strong>代码</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">//import 引入的组件需要注入到对象中才能使用</span></span><br><span class="line">  name: <span class="string">&quot;English&quot;</span>,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//这里存放数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//计算属性类似于data 概念</span></span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;&#125;, <span class="comment">// 被 keep-alive 缓存的组件激活时调用。</span></span><br><span class="line">  <span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">// 被 keep-alive 缓存的组件停用时调用。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件停用时调用。</p>
</li>
</ul>
<hr>
<h1 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h1><p>作用：对路由进行权限控制</p>
<h2 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h2><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><strong><code>to: Route</code></strong>: 即将要进入的目标路由对象</li>
<li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li>
<li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul>
<li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li>
<li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <code>router-link</code> 的 <code>to</code> prop 或 <code>router.push</code>中的选项。</li>
<li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError()</code>注册过的回调。</li>
</ul>
</li>
</ul>
<blockquote>
<p><span style="color:red"><strong>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错</strong>。</span></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h2><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h2><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这些守卫与全局前置守卫的方法参数是一样的</p>
<h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h2><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code> (2.2 新增)</li>
<li><code>beforeRouteLeave</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">//import 引入的组件需要注入到对象中才能使用</span></span><br><span class="line">  name: <span class="string">&quot;English&quot;</span>,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//这里存放数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过路由规则，进入该组件时被调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过路由规则，离开该组件时被调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>定义路由的时候可以配置 <code>meta</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">          component: Bar,</span><br><span class="line">          <span class="comment">// a meta field</span></span><br><span class="line">          meta: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过<code>to.meta.requiresAuth</code>访问</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/Vuex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/Vuex/" class="post-title-link" itemprop="url">Vuex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-08 09:38:03" itemprop="dateCreated datePublished" datetime="2021-09-08T09:38:03+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex?"></a>什么是Vuex?</h1><p>Vuex是专门在Vue 中实现集中式状态（数据）管理的一个Vue 插件，对vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<p>当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
<p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p>
<p>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想.</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/vuex.png"></p>
<h1 id="什么情况下我应该使用-Vuex？"><a href="#什么情况下我应该使用-Vuex？" class="headerlink" title="什么情况下我应该使用 Vuex？"></a>什么情况下我应该使用 Vuex？</h1><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>
<blockquote>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>
</blockquote>
<hr>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装vuex"><a href="#安装vuex" class="headerlink" title="安装vuex"></a>安装vuex</h2><p><code>NPM</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex </span><br></pre></td></tr></table></figure>

<h2 id="使用Store"><a href="#使用Store" class="headerlink" title="使用Store"></a>使用Store</h2><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
</li>
<li><p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用</p>
</li>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<p>为了在 Vue 组件中访问 <code>this.$store</code> property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 <code>store</code> 选项的方式“注入”该 store 的机制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store: store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 ES6，你也可以以 ES6 对象的 property 简写 (用在对象某个 property 的 key 和被传入的变量同名时)：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在子组件<span style="color:red">HelloWorld</span>中绑定一个方法，用来改变store中的数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前的值是:&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increase&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;increment&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完善<code>src/store/index.js</code>中的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="comment">//  Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 		   			context.state 和 context.getters 来获取 state 和 getters。</span></span><br><span class="line">        <span class="comment">// 参数value值是通过dispatch方法传过来的参数</span></span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">context, value</span>)</span> &#123;</span><br><span class="line">            context.commit(<span class="string">&quot;increment&quot;</span>,value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state,value</span>)</span> &#123;</span><br><span class="line">            state.count += value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>效果</p>
<p>点击按钮前：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/vuexchangebefore.png"></p>
<p>点击按钮5下后</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/vuexchangeafter.png"></p>
</li>
</ol>
<hr>
<h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>Getter 接受 state 作为其第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="function"><span class="title">increase</span>(<span class="params">context, value</span>)</span> &#123;</span><br><span class="line">            context.commit(<span class="string">&quot;increase&quot;</span>,value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        dollar: <span class="number">0</span>,</span><br><span class="line">        rate: <span class="number">7</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        <span class="function"><span class="title">rmb</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state.dollar * state.rate</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">increase</span>(<span class="params">state,value</span>)</span> &#123;</span><br><span class="line">            state.dollar += value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.getters.rmb </span><br></pre></td></tr></table></figure>

<h2 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h2><p>先引入mapGetters </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数组写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h2><p>先引入mapState </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p>
<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>对象写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  count:<span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="mapActions-辅助函数"><a href="#mapActions-辅助函数" class="headerlink" title="mapActions 辅助函数"></a>mapActions 辅助函数</h2><p>先导入mapActions </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数组写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   ...mapActions([</span><br><span class="line">     <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">     <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">   ]),</span><br><span class="line">   ...mapActions(&#123;</span><br><span class="line">     add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对象写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...mapActions(&#123;</span><br><span class="line">  add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="mapMutations-辅助函数"><a href="#mapMutations-辅助函数" class="headerlink" title="mapMutations 辅助函数"></a>mapMutations 辅助函数</h2><p>先导入mapActions </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数组写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">]),</span><br></pre></td></tr></table></figure>

<p>对象写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...mapMutations(&#123;</span><br><span class="line">  add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Module模块化"><a href="#Module模块化" class="headerlink" title="Module模块化"></a>Module模块化</h1><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  namespaced:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  namespaced:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在组件中对数据进行读取:</strong></p>
<p>读取<span style="color:red"><code>state</code></span>数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数空间名称字符串，第二个参数是空间名称字符串的中的参数</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(<span class="string">&#x27;currency&#x27;</span>,[<span class="string">&#x27;dollar&#x27;</span>,<span class="string">&#x27;rate&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>读取<span style="color:red"><code>getters</code></span>数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数空间名称字符串</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters(<span class="string">&#x27;currency&#x27;</span>,[<span class="string">&#x27;rmb&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>组件中调用<span style="color:red"><code>dispatch</code></span>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;currency/increase&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">    <span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">    ...mapActions(<span class="string">&#x27;currency&#x27;</span>,[<span class="string">&#x27;increase&#x27;</span>])</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件中调用<span style="color:red"><code>commit</code></span>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addOnePerson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;person/addOnePerson&#x27;</span>,newPerson)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">    ...mapActions(<span class="string">&#x27;person&#x27;</span>,[<span class="string">&#x27;addOnePerson&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wotzc</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>















  








  

  

</body>
</html>
