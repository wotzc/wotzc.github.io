---
title: 快速掌握正则表达式
date: 2022-03-10 14:56:28
tags:
- 正则表达式
categories: 正则表达式
---

# 什么是正则表达式？

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。**正则表达式**就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

很可能你使用过Windows/Dos下用于文件查找的**通配符(wildcard)**，也就是*和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索*.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像*010-12345678*或*0376-7654321)。

# 入门

学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。

假设你在一篇英文小说里查找hi，你可以使用正则表达式<span style="color:red">hi</span>。

这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配*hi*,*HI*,*Hi*,*hI*这四种情况中的任意一种。

不幸的是，很多单词里包含*hi*这两个连续的字符，比如*him*,*history*,*high*等等。用<span style="color:red">hi</span>来查找的话，这里边的*hi*也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<span style="color:red">\bhi\b</span>。

<span style="color:green">\b</span>是正则表达式规定的一个特殊代码（好吧，某些人叫它**元字符，metacharacter**），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它**只匹配一个位置**。

假如你要找的是hi后面不远处跟着一个Lucy，你应该用<span style="color:red">\bhi\b.*\bLucy\b</span>。

这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。现在\bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。

换行符就是'\n',ASCII编码为10(十六进制0x0A)的字符。

如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：

0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。

这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。

为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。

**注解：**

1. 如果需要更精确的说法，`\b`匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)`\w`。
2. 换行符就是'\n',ASCII编码为10(十六进制0x0A)的字符。

<span style="color:red">hi</span>

# 元字符

现在你已经知道几个很有用的元字符了，如<span style="color:red">`\b,.,*`</span>，还有<span style="color:red">`\d.`</span>正则表达式里还有更多的元字符，比如<span style="color:red">`\s`</span>匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。<span style="color:red">`\w`</span>匹配字母或数字或下划线或汉字等。

对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。

下面来看看更多的例子：

<span style="color:red">`\ba\w*\b`</span>匹配以字母a开头的单词——先是某个单词开始处(<span style="color:red">`\b`</span>)，然后是字母a,然后是任意数量的字母或数字(<span style="color:red">`\w*`</span>)，最后是单词结束处(<span style="color:red">`\b`</span>)。

<span style="color:red">`\d+`</span>匹配1个或更多连续的数字。这里的+是和\*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。

<span style="color:red">`\b\w{6}\b`</span> 匹配刚好6个字符的单词。

|                代码                 |            说明            |
| :---------------------------------: | :------------------------: |
| <span style="color:red">`.`</span>  | 匹配除换行符以外的任意字符 |
| <span style="color:red">`\w`</span> |   匹配字母或数字或下划线   |
| <span style="color:red">`\s`</span> |      匹配任意的空白符      |
| <span style="color:red">`\d`</span> |          匹配数字          |
| <span style="color:red">`\b`</span> |    匹配单词的开始或结束    |
| <span style="color:red">`^`</span>  |      匹配字符串的开始      |
| <span style="color:red">`$`</span>  |      匹配字符串的结束      |

元字符<span style="color:red">`^`</span>（和数字6在同一个键位上的符号）和<span style="color:red">`$`</span>都匹配一个位置，这和<span style="color:red">`\b`</span>有点类似。<span style="color:red">`^`</span>匹配你要用来查找的字符串的开头，<span style="color:red">`$`</span>匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<span style="color:red">`^\d{5,12}$`</span>。

这里的<span style="color:red">`{5,12}`</span>和前面介绍过的<span style="color:red">`{2}`</span>是类似的，只不过<span style="color:red">`{2}`</span>匹配只能不多不少重复2次，<span style="color:red">`{5,12}`</span>则是重复的次数不能少于5次，不能多于12次，否则都不匹配。

因为使用了<span style="color:red">`^`</span>和<span style="color:red">`$`</span>，所以输入的整个字符串都要用来和<span style="color:red">`\d{5,12}`</span>来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。

和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，<span style="color:red">`^`</span>和<span style="color:red">`$`</span>的意义就变成了匹配行的开始处和结束处。

**注解：**

1. **对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。**
2. 好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的`\w`。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)

# 字符转义

有时候在我们查找 . ，或者*，或者一些元字符本身的话，会有一些问题出现，因为这些元字符已经变成别的意思了，所以我们没有办法指定这些元字符。出现这种情况，我们就得使用<span style="color:red">`\`</span>来取消这些字符的特殊意义。所以，我们应该使用<span style="color:red">`\.`</span>和<span style="color:red">`\*`</span>。当然，要查找\本身，你也得用<span style="color:red">`\\`</span>.

例如：<span style="color:red">`deerchao\.net`</span>匹配deerchao.net，<span style="color:red">`C:\\Windows`</span>匹配C:\Windows。

# 重复

你已经看过了前面的<span style="color:red">`*`</span>，<span style="color:red">`+`</span>，<span style="color:red">`{2}`</span>，<span style="color:red">`{5,12}`</span>这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：

|               代码/语法                |       说明       |
| :------------------------------------: | :--------------: |
|   <span style="color:red">`*`</span>   | 重复零次或更多次 |
|   <span style="color:red">`+`</span>   | 重复一次或更多次 |
|   <span style="color:red">`?`</span>   |  重复零次或一次  |
|  <span style="color:red">`{n}`</span>  |     重复n次      |
| <span style="color:red">`{n,}`</span>  | 重复n次或更多次  |
| <span style="color:red">`{n,m}`</span> |    重复n到m次    |

下面是一些使用重复的例子：

<span style="color:red">`Windows\d+`</span>匹配Windows后面跟1个或更多数字

<span style="color:red">`^\w+`</span>匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)

# 正则表达式之字符类

如果想要查找数字，字母或数字，空白是很简单的，因为对应这些字符集合的元字符是已经存在的了，不过要想匹配像元音字母a，e，i，o，u这些没有预先定义元字符的字符集合该怎么做呢？

有个很简单的方法，只需要在方括号里列出它们就可以了，像<span style="color:red">`[aeiou]`</span>就匹配任何一个英文元音字母，<span style="color:red">`[.?!]`</span>匹配标点符号(.或?或!)。

我们也可以轻松地指定一个字符**范围**，像<span style="color:red">`[0-9]`</span>代表的含意与<span style="color:red">`\d`</span>就是完全一致的：一位数字；同理<span style="color:red">`[a-z0-9A-Z_]`</span>也完全等同于`\w`（如果只考虑英文的话）。

下面是一个更复杂的表达式：<span style="color:red">`\(?0\d{2}[) -]?\d{8}`</span>。

这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符<span style="color:red">`\(`</span>,它能出现0次或1次(<span style="color:red">`?`</span>),然后是一个<span style="color:red">`0`</span>，后面跟着2个数字(<span style="color:red">`\d{2}`</span>)，然后是<span style="color:red">`)`</span>或<span style="color:red">`-`</span>或<span style="color:red">`空格`</span>中的一个，它出现1次或不出现(<span style="color:red">`?`</span>)，最后是8个数字(<span style="color:red">`\d{8}`</span>)。

**注解：**

1. “(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。

# 正则表达式的分枝条件

但是在上节内容介绍的那个表达式也可以用来匹配类似*010)12345678*或*(022-87654321*这样的错误的格式。怎么办？要想解决这个问题，我们可以使用**分枝条件。**正则表达式里的**分枝条件**指的是有几种规则，只要满足这些规则中的任意一种，都会被当成匹配，因此我们要使用<span style="color:red">` | `</span>把这些规则分开。为了更好的理解上述内容，我们来看看几个例子：

<span style="color:red">`0\d{2}-\d{8}|0\d{3}-\d{7}`</span>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

<span style="color:red">`\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}`</span>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。

<span style="color:red">`\d{5}-\d{4}|\d{5}`</span>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成<span style="color:red">`\d{5}|\d{5}-\d{4}`</span>的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

# 正则表达式之分组

在上述章节中我们已经知道直接在字符后面加上限定符就可以重复单个字符，那么多个字符的重复又该如何实现呢？你可以使用小括号来指定子表达式（也称为**分组**），然后对于这个子表达式的重复次数你就可以自行规定了，子表达式也可以进行一些其他的操作，这个在后面会进行介绍。

<span style="color:red">`(\d{1,3}\.){3}\d{1,3}`</span>是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：<span style="color:red">`\d{1,3}`</span>匹配1到3位的数字，<span style="color:red">`(\d{1,3}\.){3}`</span>匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次，最后再加上一个一到三位的数字<span style="color:red">`(\d{1,3})`</span>。

不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<span style="color:red">`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`</span>。

理解这个表达式的关键是理解<span style="color:red">`2[0-4]\d|25[0-5]|[01]?\d\d?`</span>，这里我就不细说了，你自己应该能分析得出来它的意义。

**注解：**

1. IP地址中每个数字都不能大于255. 经常有人问我，01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).

# 正则表达式之反义

有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**：

|                 代码/语法                 |                    说明                    |
| :---------------------------------------: | :----------------------------------------: |
|    <span style="color:red">`\W`</span>    | 匹配任意不是字母，数字，下划线，汉字的字符 |
|    <span style="color:red">`\S`</span>    |          匹配任意不是空白符的字符          |
|    <span style="color:red">`\D`</span>    |            匹配任意非数字的字符            |
|    <span style="color:red">`\B`</span>    |        匹配不是单词开头或结束的位置        |
|   <span style="color:red">`[^x]`</span>   |          匹配除了x以外的任意字符           |
| <span style="color:red">`[^aeiou]`</span> |   匹配除了aeiou这几个字母以外的任意字符    |

例子：<span style="color:red">`\S+`</span>匹配不包含空白符的字符串。

<span style="color:red">`<a[^>]+>`</span>匹配用尖括号括起来的以a开头的字符串。

怎么查找**不是某个字符或不在某个字符类里**的字符的方法（反义）我们之前已经提过了。但是如果我们的目的不是去匹配某个字符，而是只想要该字符是否出现过，怎么办？例如，如果我们想要查找的单词中出现了字母q，但是字母q的后面跟着的不是字母u的话，我们可以尝试：

<span style="color:red">`\b\w*q[^u]\w*\b`</span>匹配包含**后面不是字母u的字母q**的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像**Iraq,Benq**，这个表达式就会出错。这是因为<span style="color:red">`[^u]`</span>总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的<span style="color:red">`[^u]`</span>将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的<span style="color:red">`\w*\b`</span>将会匹配下一个单词，于是<span style="color:red">`\b\w*q[^u]\w*\b`</span>就能匹配整个*Iraq fighting*。**负向零宽断言**能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：<span style="color:red">`\b\w*q(?!u)\w*\b`</span>。

**零宽度负预测先行断言**<span style="color:red">`(?!exp)`</span>，断言此位置的后面不能匹配表达式exp。例如：<span style="color:red">`\d{3}(?!\d)`</span>匹配三位数字，而且这三位数字的后面不能是数字；<span style="color:red">`\b((?!abc)\w)+\b`</span>匹配不包含连续字符串abc的单词。

同理，我们可以用<span style="color:red">`(?<!exp)`</span>,**零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式exp：<span style="color:red">`(?<![a-z])\d{7}`</span>匹配前面不是小写字母的七位数字。

一个更复杂的例子：<span style="color:red">`(?<=<(\w+)>).*(?=<\/\1>)`</span>匹配不包含属性的简单HTML标签内里的内容。<span style="color:red">`(?<=<(\w+)>)`</span>指定了这样的**前缀**：被尖括号括起来的单词(比如可能是<b>)，然后是<span style="color:red">`.*`</span>(任意的字符串),最后是一个**后缀**<span style="color:red">`(?=<\/\1>)`</span>。注意后缀里的<span style="color:red">`\/`</span>，它用到了前面提过的字符转义；<span style="color:red">`\1`</span>则是一个反向引用，引用的正是捕获的第一组，前面的<span style="color:red">`(\w+)`</span>匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。

**注解：**

- 请详细分析表达式<span style="color:red">`(?<=<(\w+)>).*(?=<\/\1>)`</span>，这个表达式最能表现零宽断言的真正用途。

# 正则表达式之注释

小括号还有另一种用途，就是通过语法<span style="color:red">`(?#comment)`来包含注释。例如：<span style="color:red">`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`。

如果要包含注释，最好是启用“忽略模式里的空白符”选项，因为这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。

例如，我们可以前面的一个表达式写成这样：

<span style="color:red">`(?<= # 断言要匹配的文本的前缀`</span>

<span style="color:red">`<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)`</span>

<span style="color:red">`) # 前缀结束`</span>

<span style="color:red">`.* # 匹配任意文本`</span>

<span style="color:red">`(?= # 断言要匹配的文本的后缀`</span>

<span style="color:red">`<\/\1> # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签`</span>

<span style="color:red">`) # 后缀结束`</span>

# 正则表达式之贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：<span style="color:red">`a.*b`</span>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串*aabab*。这被称为**贪婪**匹配。

有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<span style="color:red">`?`</span>。这样<span style="color:red">`.*?`</span>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

<span style="color:red">`a.*?b`</span>匹配最短的，以a开始，以b结束的字符串。如果把它应用于*aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

|                代码/语法                |              说明               |
| :-------------------------------------: | :-----------------------------: |
|   <span style="color:red">`*?`</span>   |   重复任意次，但尽可能少重复    |
|   <span style="color:red">`+?`</span>   | 重复1次或更多次，但尽可能少重复 |
|   <span style="color:red">`??`</span>   |  重复0次或1次，但尽可能少重复   |
| <span style="color:red">`{n,m}?`</span> |   重复n到m次，但尽可能少重复    |
| <span style="color:red">`{n,}?`</span>  |   重复n次以上，但尽可能少重复   |

**注解：**

- 为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。

# 正则表达式之处理选项

以前介绍的忽略大小写、处理多行等选项可以用来改变处理正则表达式的方式，接下来要来介绍下载.Net中常用到的正则表达式的选项：

|               名称                |                             说明                             |
| :-------------------------------: | :----------------------------------------------------------: |
|      IgnoreCase(忽略大小写)       |                     匹配时不区分大小写。                     |
|        Multiline(多行模式)        | 更改<span style="color:red">`^`</span>和<span style="color:red">`$`</span>的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,<span style="color:red">`$`</span>的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) |
|       Singleline(单行模式)        |     更改.的含义，使它与每一个字符匹配（包括换行符\n）。      |
| IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由<span style="color:red">`#`</span>标记的注释。 |
|     ExplicitCapture(显式捕获)     |                   仅捕获已被显式命名的组。                   |

一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。

**注解：**

- 在C#中，你可以使用Regex(String, RegexOptions)构造函数来设置正则表达式的处理选项。如：Regex regex = new Regex(@"\ba\w{6}\b", RegexOptions.IgnoreCase);

# 正则表达式补充

到此为止，我们已经介绍了有关于正则表达式的大量元素，但是那么复杂的正则表达式，肯定还有一些元素还未提到，作者把那些未被提到的元素整合成如下的列表，其中还包含了语法和简单的说明。如果你觉得列表中的介绍不够详细的话，你也可以根据自己的需要利用更多的资源去学习它们。如果你的电脑中装了MSDN Library，你也能够在里面查到.net下正则表达式的详细文档，如果你没有安装MSDN Library,可以查看[关于正则表达式语言元素的MSDN在线文档](http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)。

|                    代码/语法                     |                             说明                             |
| :----------------------------------------------: | :----------------------------------------------------------: |
|       <span style="color:red">`\a`</span>        |              报警字符(打印它的效果是电脑嘀一声)              |
|       <span style="color:red">`\b`</span>        |       通常是单词分界位置，但如果在字符类里使用代表退格       |
|       <span style="color:red">`\t`</span>        |                         制表符，Tab                          |
|       <span style="color:red">`\r`</span>        |                             回车                             |
|       <span style="color:red">`\v`</span>        |                          竖向制表符                          |
|       <span style="color:red">`\f`</span>        |                            换页符                            |
|       <span style="color:red">`\n`</span>        |                            换行符                            |
|       <span style="color:red">`\e`</span>        |                            Escape                            |
|      <span style="color:red">`\0nn`</span>       |               ASCII代码中八进制代码为nn的字符                |
|      <span style="color:red">`\xnn`</span>       |              ASCII代码中十六进制代码为nn的字符               |
|     <span style="color:red">`\unnnn`</span>      |            Unicode代码中十六进制代码为nnnn的字符             |
|       <span style="color:red">`\cN`</span>       |               ASCII控制字符。比如\cC代表Ctrl+C               |
|       <span style="color:red">`\A`</span>        |         字符串开头(类似^，但不受处理多行选项的影响)          |
|       <span style="color:red">`\Z`</span>        |           字符串结尾或行尾(不受处理多行选项的影响)           |
|       <span style="color:red">`\z`</span>        |         字符串结尾(类似$，但不受处理多行选项的影响)          |
|       <span style="color:red">`\G`</span>        |                        当前搜索的开头                        |
|    <span style="color:red">`\p{name}`</span>     |         Unicode中命名为name的字符类，例如\p{IsGreek}         |
|     <span style="color:red">`(?>exp)`</span>     |                         贪婪子表达式                         |
|  <span style="color:red">`(?<x>-<y>exp)`</span>  |                            平衡组                            |
|  <span style="color:red">`(?im-nsx:exp)`</span>  |                 在子表达式exp中改变处理选项                  |
|    <span style="color:red">`(?im-nsx)`</span>    |                为表达式后面的部分改变处理选项                |
| <span style="color:red">`(?(exp)yes|no)`</span>  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |
|   <span style="color:red">`(?(exp)yes)`</span>   |                 同上，只是使用空表达式作为no                 |
| <span style="color:red">`(?(name)yes|no)`</span> | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no |
|  <span style="color:red">`(?(name)yes)`</span>   |                 同上，只是使用空表达式作为no                 |

# 常用正则表达式示例

## 使用正则表达式匹配数值范围

由于正则表达式处理文本而不是数字，因此匹配给定范围内的数字需要格外小心。你不能只写`[ 0-2 55 ]`来匹配 0 到 255 之间的数字。虽然是有效的正则表达式，但它匹配完全不同的东西。`[ 0-2 55 ]`是具有三个元素的字符类：字符范围 0-2、字符 5 和字符 5（再次）。该字符类匹配单个数字 0、1、2 或 5，就像`[ 0125 ]`一样。

由于正则表达式适用于文本，因此正则表达式引擎将`0`视为单个字符，将`255`视为三个字符。要匹配从 0 到 255 的所有字符，我们需要一个匹配 1 到 3 个字符的正则表达式。

正则表达式`[ 0-9 ]`匹配 0 到 9 的一位数。`[ 1-9 ] [ 0-9 ]`匹配 10 到 99 的两位数。这很容易。

匹配三位数字有点复杂，因为我们需要排除数字 256 到 999。1 `[ 0-9 ] [ 0-9 ]处理`100 到 199。`2 [ 0-4 ] [ 0-9 ]`匹配 200 到 249。最后，`25 [ 0-5 ]`添加 250 到 255。

如您所见，您需要将数字范围拆分为具有相同位数的范围，并且每个范围都允许每个数字具有相同的变化。在我们示例中的 3 位范围内，以 1 开头的数字允许后面的两位数字使用所有 10 位数字，而以 2 开头的数字则限制后面允许的数字。

使用交替将所有这些放在一起，我们得到：`[ 0-9 ] | [ 1-9 ] [ 0-9 ] | 1 [ 0-9 ] [ 0-9 ] | 2 [ 0-4 ] [ 0-9 ] | 25 [ 0-5 ]`。这匹配了我们想要的数字，但有一点需要注意：正则表达式搜索通常允许部分匹配，因此我们的正则表达式将匹配`123`中的`12345`。有两种解决方案。

## 搜索数值范围

如果您在较大的文档或输入字符串中搜索这些数字，请使用[单词边界](https://www.regular-expressions.info/wordboundaries.html)来要求在任何有效匹配之前和之后都需要一个非单词字符（或根本没有字符）。然后正则表达式变为`\b ( [ 0-9 ] | [ 1-9 ] [ 0-9 ] | 1 [ 0-9 ] [ 0-9 ] | 2 [ 0-4 ] [ 0-9 ] | 25 [ 0-5 ] ) \b`。由于交替运算符的优先级最低，因此[需要括号](https://www.regular-expressions.info/brackets.html)将备选方案组合在一起。这样，正则表达式引擎将尝试匹配第一个单词边界，然后尝试所有备选方案，然后尝试匹配它匹配的数字之后的第二个单词边界。正则表达式引擎将所有字母数字字符以及下划线视为单词字符。

## 验证数值范围

如果您使用正则表达式验证输入，您可能需要检查整个输入是否包含有效数字。为此，请将单词边界替换为[锚点](https://www.regular-expressions.info/anchors.html)以匹配字符串的开头和结尾：`^ ( [ 0-9 ] | [ 1-9 ] [ 0-9 ] | 1 [ 0-9 ] [ 0-9 ] | 2 [ 0-4 ] [ 0-9 ] | 25 [ 0-5 ] )美元`。

以下是您可能想要匹配的一些更常见的范围：

- 000..255：`^ （[ 01 ] [ 0-9 ] [ 0-9 ] | 2 [ 0-4 ] [ 0-9 ] | 25 [ 0-5 ] ）$`
- 0 或 000..255: `^ ( [ 01 ] ? [ 0-9 ] ? [ 0-9 ] | 2 [ 0-4 ] [ 0-9 ] | 25 [ 0-5 ] ) $`
- 0 或 000..127: `^ ( 0 ? [ 0-9 ] ? [ 0-9 ] | 1 [ 01 ] [ 0-9 ] | 12 [ 0-7 ] ) $`
- 0..999：`^ （[ 0-9 ] | [ 1-9 ] [ 0-9 ] | [ 1-9 ] [ 0-9 ] [ 0-9 ] ）$`
- 000..999: `^ [ 0-9 ] {3} $`
- 0 或 000..999: `^ [ 0-9 ] {1,3} $`
- 1..999：`^ （[ 1-9 ] | [ 1-9 ] [ 0-9 ] | [ 1-9 ] [ 0-9 ] [ 0-9 ] ）$`
- 001..999: `^ ( 00 [ 1-9 ] | 0 [ 1-9 ] [ 0-9 ] | [ 1-9 ] [ 0-9 ] [ 0-9 ] ) $`
- 1 或 001..999: `^ ( 0 {0,2} [ 1-9 ] | 0 ? [ 1-9 ] [ 0-9 ] | [ 1-9 ] [ 0-9 ] [ 0-9 ] ) $`
- 0 或 00..59: `^ [ 0-5 ] ? [ 0-9 ] $`
- 0 或 000..366: `^ ( [ 012 ] ? [ 0-9 ] ? [ 0-9 ] | 3 [ 0-5 ] [ 0-9 ] | 36 [ 0-6 ] ) $`

## 用正则表达式匹配浮点数

此示例说明如何避免不熟悉[正则表达式](https://www.regular-expressions.info/index.html)的人经常犯的常见错误。例如，我们将尝试构建一个可以匹配任何浮点数的正则表达式。我们的正则表达式还应该匹配未给出整数部分的整数和浮点数。我们不会尝试将数字与指数相匹配，例如 1.5e8（科学计数法中的 1.5 亿）。

乍一看，以下正则表达式似乎可以解决问题：`[ -+ ] ？[ 0-9 ] * \。? [ 0-9 ] *`。这将浮点数定义为[可选](https://www.regular-expressions.info/optional.html)符号，后跟可选的[数字](https://www.regular-expressions.info/charclass.html)[系列](https://www.regular-expressions.info/repeat.html)（整数部分），后跟可选的点，然后是另一个可选的数字系列（小数部分）。

用单词拼写正则表达式很明显：这个正则表达式中的所有内容都是可选的。此正则表达式将单独的符号或单独的点视为有效的浮点数。事实上，它甚至将空字符串视为有效的浮点数。如果您尝试使用此正则表达式在文件中查找浮点数，您将在字符串中没有出现浮点数的每个位置获得[零长度匹配。](https://www.regular-expressions.info/zerolength.html)

不转义[点](https://www.regular-expressions.info/dot.html)也是一个常见的错误。未转义的点匹配任何字符，包括点。如果我们没有转义点，那么`4.4`和`4X4`都将被视为浮点数。

在创建正则表达式时，考虑它不应该匹配的内容比它应该匹配的内容更*重要*。上面的正则表达式确实匹配正确的浮点数，因为正则表达式引擎是[greedy](https://www.regular-expressions.info/optional.html#greedy)。但它也匹配了许多我们不想要的东西，我们必须排除这些东西。

这是一个更好的尝试：`[ -+ ] ? ( [ 0-9 ] * \。[ 0-9 ] + | [ 0-9 ] + )`。此正则表达式匹配一个可选符号，该符号后跟零个[或](https://www.regular-expressions.info/alternation.html)多个数字，后跟一个点和一个或多个数字（带有可选整数部分的浮点数），或者后跟一个或多个数字（整数） .

这是一个更好的定义。任何匹配项都必须包含至少一位数字。没有办法绕过`[ 0 - 9 ] +`部分。我们已经成功排除了我们不想要的匹配项：那些没有数字的匹配项。

我们可以将这个正则表达式优化为：`[ -+ ] ? [ 0-9 ] * \。? [ 0-9 ] +`。

如果您还想将数字与指数匹配，您可以使用：`[ -+ ] ? [ 0-9 ] * \。? [ 0-9 ] + （[ eE ] [ -+ ] ？[ 0-9 ] + ）？`. [请注意我是如何通过将整个指数部分组合](https://www.regular-expressions.info/brackets.html)在一起来使整个指数部分成为可选的，而不是使指数中的每个元素都是可选的。

最后，如果要验证特定字符串是否包含浮点数，而不是在较长的文本中查找浮点数，则必须[锚定](https://www.regular-expressions.info/anchors.html)正则表达式：`^ [ -+ ] ? [ 0-9 ] * \。? [ 0-9 ] + $`或`^ [ -+ ] ？[ 0-9 ] * \。? [ 0-9 ] + ( [ eE ] [ -+ ] ? [ 0-9 ] +) ? $` . 您可以在[RegexBuddy 的库](https://www.regexbuddy.com/library.html)中找到这些正则表达式的其他变体。

## 如何查找或验证电子邮件地址

我收到最多反馈的正则表达式，更不用说“bug”报告了，就是你可以在这个网站的[主页上](https://www.regular-expressions.info/index.html)找到的那个：`\b [ AZ 0-9 ._%+ - ] + @ [ AZ 0 -9 。- ] + \。[ AZ ] {2,} \b`。我声称，这个正则表达式匹配任何电子邮件地址。我收到的大多数反馈都通过显示一个与此正则表达式不匹配的电子邮件地址来驳斥这种说法。通常，“错误”报告还包括使正则表达式“完美”的建议。

正如我在下面解释的那样，只有当人们接受我对有效电子邮件地址到底是什么以及不是什么的定义时，我的主张才成立。如果您想使用不同的定义，则必须调整正则表达式。匹配一个有效的电子邮件地址是一个完美的例子，它表明（1）在编写正则表达式之前，您必须确切地知道您要匹配的内容，以及不匹配的内容；(2) 在准确和实用之间经常需要权衡取舍。

我上面的正则表达式的优点是它匹配了当今使用的 99% 的电子邮件地址。它匹配的所有电子邮件地址都可以被 99% 的所有电子邮件软件处理。如果您正在寻找快速解决方案，您只需阅读下一段。如果您想了解所有权衡并获得大量可供选择的替代方案，请继续阅读。

如果要使用上面的正则表达式，有两点需要了解。首先，长正则表达式很难很好地格式化段落。所以我没有将`az`包含在三个字符类中的任何一个中。此正则表达式旨在与您的正则表达式引擎的“不区分大小写”选项打开时使用。（你会惊讶于我收到了多少“错误”报告。）其次，上面的正则表达式是用[单词边界](https://www.regular-expressions.info/wordboundaries.html)分隔的，这使它适合从文件或更大的文本块中提取电子邮件地址。如果要检查用户是否输入了有效的电子邮件地址，请将单词边界替换为[字符串开头和字符串结尾的锚点](https://www.regular-expressions.info/anchors.html)，如下所示：`^ [ AZ 0-9 ._%+- ] + @ [ AZ 0-9 。- ] + \。[ AZ ] {2,} $`。

上一段也适用于以下所有示例。您可能需要将单词边界更改为字符串开始/结束锚点，反之亦然。而且您必须打开不区分大小写的匹配选项。

## 如何查找或验证 IP 地址

匹配 IP 地址是在正则表达式复杂性和准确性之间进行权衡的另一个很好的例子。`\b \d {1,3} \. \d {1,3} \. \d {1,3} \. \d {1,3} \b`将匹配任何 IP 地址就好了。但也会匹配`999.999.999.999`，就好像它是一个有效的 IP 地址一样。如果您的正则表达式支持 Unicode，它甚至可以匹配`١٢٣.१२३.೧೨೩.๑๒๓`。这是否是一个问题取决于您打算应用正则表达式的文件或数据。
