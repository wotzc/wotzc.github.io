<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="真正的大师永远都怀着一颗学徒的心">
<meta property="og:type" content="website">
<meta property="og:title" content="Cai">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Cai">
<meta property="og:description" content="真正的大师永远都怀着一颗学徒的心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wotzc">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Cai</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cai</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wotzc"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">wotzc</p>
  <div class="site-description" itemprop="description">真正的大师永远都怀着一颗学徒的心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/23/Java-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/23/Java-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">深入浅出 Java 8 Lambda 表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-23 19:01:50" itemprop="dateCreated datePublished" datetime="2021-10-23T19:01:50+08:00">2021-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 16:52:24" itemprop="dateModified" datetime="2023-09-05T16:52:24+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。</p>
<p>这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。</p>
<p>在写回调函数和事件处理器时，程序员不必再纠缠于匿名内部类的冗繁和可读性，函数式编程让事件处理系统变得更加简单。能将函数方便地传递也让编写惰性代码变得容易，只有在真正需要的时候，才初始化变量的值。</p>
<p>Java <em>Lambda表达式</em>的一个重要用法是简化某些<em>匿名内部类</em>（<code>Anonymous Classes</code>）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过<em>invokedynamic</em>指令来实现Lambda表达式的。</p>
<p>Lambda表达式（也称闭包），是Java8中最受期待和欢迎的新特性之一。Lambda表达式本质是一个匿名函数，但是它并不是匿名类的语法糖，它让 Java 开始走向函数式编程，其实现原理区别于一般的匿名类中的匿名函数。在Java语法层面Lambda表达式允许函数作为一个方法的参数（函数作为参数传递到方法中），或者把代码看成数据。Lambda表达式可以简化函数式接口的使用。函数式接口就是一个只有一个抽象方法的普通接口，像这样的接口就可以使用Lambda表达式来简化代码的编写。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda 表达式为 Java 添加了缺失的函数式编程特点，使我们能将函数当做一等公民看待。尽管不完全正确，我们很快就会见识到 Lambda 与闭包的不同之处，但是又无限地接近闭包。在支持一类函数的语言中，Lambda 表达式的类型将是函数。但是，在 Java 中，Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。函数式接口在java中是指:<strong>有且仅有一个抽象方法的接口</strong>，<strong>只有函数式接口，才可以转换为lambda表达式</strong>，<strong>函数式接口可以显式的被@FunctionalInterface所表示，当被标识的接口不满足规定时，编译器会提示报错</strong>。我们会在后文详细介绍函数式接口。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/java-lambda-expression.png"></p>
<p>在认识Lambda表达式基础语法之前，先来看一段用两种方式创建线程的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Hello!&quot;</span>)).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/javalambdaexpression.png"></p>
<p>Lambda 表达式的基础语法：Java8中引入了一个新的操作符 <code>-></code>该操作符称为箭头操作符或 Lambda 操作符</p>
<p>箭头操作符将 Lambda 表达式拆分成两部分：</p>
<p>左侧：Lambda 表达式的参数列表</p>
<p>右侧：Lambda 表达式中所需实现的功能， 即 Lambda 体</p>
<p>Java 中的 Lambda 表达式通常使用<code>(argument) -> (body)</code>语法书写，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class="line"></span><br><span class="line">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>

<p>以下是一些 Lambda 表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h1><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。</p>
<p><code>java.lang.Runnable </code>就是一种函数式接口，在 Runnable 接口中只声明了一个方法<code>void run()</code>，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</p>
<p>每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当不指明函数式接口时，编译器会自动解释这种转化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">   () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 <span style="color:red"><code>public Thread(Runnable r) &#123; &#125;</code></span>，将该 Lambda 表达式赋给 Runnable 接口。</p>
<p>以下是一些 Lambda 表达式及其函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt;  c = (<span class="keyword">int</span> x) -&gt; &#123; System.out.println(x) &#125;;</span><br><span class="line"></span><br><span class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="string">&quot; : &quot;</span> + y);</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == <span class="keyword">null</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html">@FunctionalInterface</a> 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p>
<p>以下是一种自定义的函数式接口： @FunctionalInterface public interface WorkerInterface {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeMoreWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unexpected <span class="meta">@FunctionalInterface</span> annotation </span><br><span class="line">    <span class="meta">@FunctionalInterface</span> ^ WorkerInterface is not a functional <span class="class"><span class="keyword">interface</span> <span class="title">multiple</span> </span></span><br><span class="line"><span class="class">    <span class="title">non</span>-<span class="title">overriding</span> <span class="title">abstract</span> <span class="title">methods</span> <span class="title">found</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">WorkerInterface</span> 1 <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>函数式接口定义好后，我们可以在 API 中使用它，同时利用 Lambda 表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义一个函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(WorkerInterface worker)</span> </span>&#123;</span><br><span class="line">    worker.doSomeWork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke doSomeWork using Annonymous class</span></span><br><span class="line">    execute(<span class="keyword">new</span> WorkerInterface() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Worker invoked using Anonymous class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke doSomeWork using Lambda expression </span></span><br><span class="line">    execute( () -&gt; System.out.println(<span class="string">&quot;Worker invoked using Lambda expression&quot;</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker invoked using Anonymous <span class="class"><span class="keyword">class</span> </span></span><br><span class="line"><span class="class"><span class="title">Worker</span> <span class="title">invoked</span> <span class="title">using</span> <span class="title">Lambda</span> <span class="title">expression</span></span></span><br></pre></td></tr></table></figure>

<p>这上面的例子里，我们创建了自定义的函数式接口并与 Lambda 表达式一起使用。execute() 方法现在可以将 Lambda 表达式作为参数。</p>
<h1 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h1><p>让我们了解一下 Lambda 表达式的结构。</p>
<ul>
<li>一个 Lambda 表达式可以有<code>零个</code>或<code>多个</code>参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li>
<li>当只有一个参数，且其类型可推导时，圆括号<code>()</code>可省略。例如：<code>a -> return a*a</code></li>
<li>当参数大于一个时，所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code>或 <code>(String a, int b, float c)</code></li>
<li>空圆括号代表没有参数。例如：<code>() -> 42</code></li>
<li>Lambda 表达式的主体可包含<code>零条</code>或<code>多条</code>语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号<code>&#123;&#125;</code>可省略，如果Lambda体不加<code>&#123;&#125;</code>就不用写<code>return</code>。</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号<code>&#123;&#125;中</code>（形成代码块）Lambda体加上<code>&#123;&#125;</code>就需要添加<code>return</code>。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h1 id="Lambda表达式和内部类区别一"><a href="#Lambda表达式和内部类区别一" class="headerlink" title="Lambda表达式和内部类区别一"></a>Lambda表达式和内部类区别一</h1><p>读过上一篇之后，相信对Lambda表达式的语法以及基本原理有了一定了解。对于编写代码，有这些知识已经够用。本文将进一步区分Lambda表达式和匿名内部类在JVM层面的区别。</p>
<p>经过第一篇的的介绍，我们看到Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。</p>
<h3 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h3><p><strong>匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名</strong>。因此如果有如下形式的代码，编译之后将会产生两个class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Anonymous Class Thread run()&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后文件分布如下，两个class文件分别是主类和匿名内部类产生的：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/2-AnonymousClass.png"></p>
<p>进一步分析主类MainAnonymousClass.class的字节码，可发现其创建了匿名内部类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javap -c MainAnonymousClass.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/lang/Thread</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: new           #3                  // class MainAnonymousClass$1 /*创建内部类对象*/</span><br><span class="line">       <span class="number">7</span>: dup</span><br><span class="line">       8: invokespecial #4                  // Method MainAnonymousClass$1.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      11: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br><span class="line">      14: invokevirtual #6                  // Method java/lang/Thread.start:()V</span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式实现"><a href="#Lambda表达式实现" class="headerlink" title="Lambda表达式实现"></a>Lambda表达式实现</h3><p><strong>Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类</strong>。如果有如下代码，编译之后只有一个class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(</span><br><span class="line">				() -&gt; System.out.println(<span class="string">&quot;Lambda Thread run()&quot;</span>)</span><br><span class="line">			).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后的结果：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/2-Lambda.png"></p>
<p>通过javap反编译命名，我们更能看出Lambda表达式内部表示的不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; javap -c -p MainLambda.class</span><br><span class="line">public class MainLambda &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Thread</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:run:()Ljava&#x2F;lang&#x2F;Runnable; &#x2F;*使用invokedynamic指令调用*&#x2F;</span><br><span class="line">       9: invokespecial #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line">      12: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.start:()V</span><br><span class="line">      15: return</span><br><span class="line"></span><br><span class="line">  private static void lambda$main$0();  &#x2F;*Lambda表达式被封装成主类的私有方法*&#x2F;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       3: ldc           #7                  &#x2F;&#x2F; String Lambda Thread run()</span><br><span class="line">       5: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法，并通过<code>invokedynamic</code>指令进行调用。</p>
<p>它没有创建将包装 Lambda 函数的新对象，而是使用Java 7 中添加的新<code>invokeDynamic</code>指令将此调用站点动态链接到实际的 Lambda 函数。</p>
<div class="note no-icon success"><p>看到 Java，最“严格”的现代语言现在如何使用动态链接来支持其新的 Lambda 表达式，真是令人着迷。这也是一种有效的方法，因为不需要额外的类加载和编译——Lambda 方法只是我们类中的另一个私有方法。</p>
</div>

<hr>
<h1 id="Lambda表达式和内部类区别二"><a href="#Lambda表达式和内部类区别二" class="headerlink" title="Lambda表达式和内部类区别二"></a>Lambda表达式和内部类区别二</h1><p>尽管在实际开发中基本上用 lambda 表达式替换了内部类，但这两个概念在一个重要方面是不同的：作用域。</p>
<p>既然Lambda表达式不是内部类的简写，那么Lambda内部的<code>this</code>引用也就跟内部类对象没什么关系了。在Lambda表达式中<code>this</code>的意义跟在表达式外部完全一样。因此下列代码将输出两遍<code>Hello Hoolee</code>，而不是两个引用地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	Runnable r1 = () -&gt; &#123; System.out.println(<span class="keyword">this</span>); &#125;;</span><br><span class="line">	Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Hello().r1.run();</span><br><span class="line">		<span class="keyword">new</span> Hello().r2.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello Hoolee&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于匿名类，关键词 <code>this</code> 解读为匿名类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    String name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name); <span class="comment">//zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lambda-and-Collections"><a href="#Lambda-and-Collections" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h1><p>我们先从最熟悉的*Java集合框架(Java Collections Framework, JCF)*开始说起。</p>
<p>为引入Lambda表达式，Java8新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。</p>
<p>首先回顾一下Java集合框架的接口继承结构：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/JCF_Collection_Interfaces.png"></p>
<p>上图中绿色标注的接口类，表示在Java8中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">Java8新加入的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Collection</code></td>
<td align="left"><code>removeIf() spliterator() stream() parallelStream() forEach()</code></td>
</tr>
<tr>
<td align="left"><code>List</code></td>
<td align="left"><code>replaceAll() sort()</code></td>
</tr>
<tr>
<td align="left"><code>Map</code></td>
<td align="left"><code>getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</code></td>
</tr>
</tbody></table>
<p>这些新加入的方法大部分要用到<code>java.util.function</code>包下的接口，这意味着这些方法大部分都跟Lambda表达式相关。我们将逐一学习这些方法。</p>
<h3 id="Collection中的新方法"><a href="#Collection中的新方法" class="headerlink" title="Collection中的新方法"></a>Collection中的新方法</h3><p>如上所示，接口<code>Collection</code>和<code>List</code>新加入了一些方法，我们以<code>List</code>的子类<code>ArrayList</code>为例来说明。了解<a target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md">Java7<code>ArrayList</code>实现原理</a>，将有助于理解下文。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法的签名为<code>void forEach(Consumer<? super E> action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>
<p>需求：<em>假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.</em></p>
<p>Java7及以前我们可以用<code>增强的for循环</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用曾强for循环迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>
<h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h4><p>该方法签名为<code>boolean removeIf(Predicate<? super E> filter)</code>，作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>
<p>需求：<em>假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</em></p>
<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器删除列表元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(it.next().length()&gt;<span class="number">3</span>) <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;()&#123; <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.length()&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。</p>
<h4 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E> operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素</strong>。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>
<p>需求：<em>假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</em></p>
<p>Java7及之前似乎没有优雅的办法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用下标实现元素替换</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(<span class="keyword">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator<? super E> c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序</strong>。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>
<p>需求：<em>假设有一个字符串列表，按照字符串长度增序对元素排序。</em></p>
<p>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类中，所以代码要这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.sort()方法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.length()-str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在可以直接使用<code>List.sort()方法</code>，结合Lambda表达式，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>

<h4 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h4><p>方法签名为<code>Spliterator&lt;E> spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>iterator()</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>
<ol>
<li><code>Spliterator</code>既可以像<code>iterator()</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>
<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T> trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>
</ol>
<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>
<h4 id="stream-和parallelStream"><a href="#stream-和parallelStream" class="headerlink" title="stream()和parallelStream()"></a>stream()和parallelStream()</h4><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回该容器的<code>Stream</code>视图表示</strong>，不同之处在于<code>parallelStream()</code>返回并行的<code>stream()</code>。<code>stream()</code><strong>是Java函数式编程的核心类</strong>，我们会在后面章节中学习。</p>
<hr>
<h3 id="Map中的新方法"><a href="#Map中的新方法" class="headerlink" title="Map中的新方法"></a>Map中的新方法</h3><p>相比<code>Collection</code>，Map<code>中加入了更多的方法，我们以</code>HashMap<code>为例来逐一探秘。了解[Java7</code>HashMap`实现原理](<a target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet</a> and HashMap.md)，将有助于理解下文。</p>
<h4 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法签名为<code>void forEach(BiConsumer<? super K,? super V> action)</code>，作用是<strong>对<code>Map</code>中的每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;=&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>
<p>需求；<em>假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="comment">// Java7以及之前做法</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">4</span>))&#123; <span class="comment">// 1</span></span><br><span class="line">    System.out.println(map.get(<span class="number">4</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;NoValue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8使用Map.getOrDefault()</span></span><br><span class="line">System.out.println(map.getOrDefault(<span class="number">4</span>, <span class="string">&quot;NoValue&quot;</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改．该方法将条件判断和赋值合二为一，使用起来更加方便．</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中**<code>key</code>正好映射到<code>value</code>时**才删除该映射，否则什么也不做．</p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>在Java7及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>
<ul>
<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在时**才用<code>value</code>去替换原来的值，否则什么也不做．</li>
<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在且等于<code>oldValue</code>时**才用<code>newValue</code>去替换原来的值，否则什么也不做．</li>
</ul>
<h4 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>replaceAll(BiFunction<? super K,? super V,? extends V> function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>简洁到让人难以置信．</p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>该方法签名为<code>merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)</code>，作用是：</p>
<ol>
<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>
<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射．</li>
</ol>
<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>
<p><code>merge()</code>方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</span><br></pre></td></tr></table></figure>

<h4 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h4><p>该方法签名为<code>compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射．</p>
<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.compute(key, (k,v) -&gt; v==<span class="keyword">null</span> ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>

<h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h4><p>该方法签名为<code>V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)</code>，作用是：只有在当前<code>Map</code>中<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>
<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>
<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map<K,Set&lt;V>></code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">&quot;yi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>
<h4 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h4><p>该方法签名为<code>V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前<code>Map</code>中<strong>存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>
<p>这个函数的功能跟如下代码是等效的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class="line"><span class="keyword">if</span> (map.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    V oldValue = map.get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>)</span><br><span class="line">        map.put(key, newValue);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        map.remove(key);</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>Java8为容器新增一些有用的方法，这些方法有些是为<strong>完善原有功能</strong>，有些是为<strong>引入函数式编程</strong>，学习和使用这些方法有助于我们写出更加简洁有效的代码．</li>
<li><strong>函数接口</strong>虽然很多，但绝大多数时候我们根本不需要知道它们的名字，书写Lambda表达式时类型推断帮我们做了一切．</li>
</ol>
<hr>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用（<code>Method Reference</code>）是用来直接访问类或者实例已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。</p>
<p>当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。</p>
<p>作用</p>
<ul>
<li>方法引用的唯一用途是支持Lambda的简写。</li>
<li>方法引用提高了代码的可读性，也使逻辑更加清晰。</li>
</ul>
<p>组成</p>
<ul>
<li>使用<code>::</code>操作符将方法名和对象或类的名字分隔开。<code>::</code>是域操作符（也可以称作定界符、分隔符）。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法引用</strong></th>
<th>等价的Lambda表达式</th>
</tr>
</thead>
<tbody><tr>
<td><code>String::valueOf</code></td>
<td><code>x -> String.valueOf(x)</code></td>
</tr>
<tr>
<td><code>Object::toString</code></td>
<td><code>x -> x.toString()</code></td>
</tr>
<tr>
<td><code>x::toString</code></td>
<td><code>() -> x.toString()</code></td>
</tr>
<tr>
<td><code>ArrayList::new</code></td>
<td><code>() -> new ArrayList<>()</code></td>
</tr>
</tbody></table>
<p>方法引用的类型归结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td><code>ClassName::methodName</code></td>
</tr>
<tr>
<td>指定对象实例方法引用</td>
<td><code>instanceRef::methodName</code></td>
</tr>
<tr>
<td>特定类型任意对象方法引用</td>
<td><code>ContainingType::methodName</code></td>
</tr>
<tr>
<td>超类方法引用</td>
<td><code>supper::methodName</code></td>
</tr>
<tr>
<td>构造器方法引用</td>
<td><code>ClassName::new</code></td>
</tr>
<tr>
<td>数组构造器方法引用</td>
<td><code>TypeName[]::new</code></td>
</tr>
</tbody></table>
<p>可见其基本形式是：<code>方法容器::方法名称或者关键字</code>。</p>
<p>举一些基本的使用例子：</p>
<h2 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethodRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;String, Integer&gt; function = StaticMethodRef::staticMethod;</span><br><span class="line">        <span class="comment">// 等同于</span></span><br><span class="line">        <span class="comment">// Function&lt;String, Integer&gt; function1 = (String s) -&gt; StaticMethodRef.staticMethod(s);</span></span><br><span class="line">        Integer result = function.apply(<span class="string">&quot;10086&quot;</span>);</span><br><span class="line">        <span class="comment">// 10086</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">staticMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定对象实例方法引用"><a href="#指定对象实例方法引用" class="headerlink" title="指定对象实例方法引用"></a>指定对象实例方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticularInstanceRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">refMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParticularInstanceRef ref = <span class="keyword">new</span> ParticularInstanceRef();</span><br><span class="line">        Function&lt;String, Integer&gt; function = ref::refMethod;</span><br><span class="line">        <span class="comment">// 等同于</span></span><br><span class="line">        <span class="comment">// Function&lt;String,Integer&gt; function1 = (String s) -&gt; ref.refMethod(s);</span></span><br><span class="line">        Integer result = function.apply(<span class="string">&quot;10086&quot;</span>);</span><br><span class="line">        <span class="comment">// 10086</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特定类型任意对象方法引用"><a href="#特定类型任意对象方法引用" class="headerlink" title="特定类型任意对象方法引用"></a>特定类型任意对象方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(stringArray, String::compareToIgnoreCase);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// Arrays.sort(stringArray, (String s1, String s2) -&gt; s1.compareToIgnoreCase(s2));</span></span><br><span class="line"><span class="comment">// [a, B, C]</span></span><br><span class="line">System.out.println(Arrays.toString(stringArray));</span><br></pre></td></tr></table></figure>

<h2 id="超类方法引用"><a href="#超类方法引用" class="headerlink" title="超类方法引用"></a>超类方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupperRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        <span class="comment">// 10086</span></span><br><span class="line">        System.out.println(sub.refMethod(<span class="string">&quot;10086&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Integer <span class="title">supperRefMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Integer <span class="title">refMethod</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            Function&lt;String, Integer&gt; function = <span class="keyword">super</span>::supperRefMethod;</span><br><span class="line">            <span class="comment">// 等同于</span></span><br><span class="line">            <span class="comment">// Function&lt;String,Integer&gt; function1 = (String s) -&gt; super.supperRefMethod(s);</span></span><br><span class="line">            <span class="keyword">return</span> function.apply(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造器方法引用"><a href="#构造器方法引用" class="headerlink" title="构造器方法引用"></a>构造器方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;String, Person&gt; function = Person::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">// 等同于</span></span><br><span class="line">        <span class="comment">// Function&lt;String,Person&gt; function1 = (String s) -&gt; new Person(s);</span></span><br><span class="line">        Person person = function.apply(<span class="string">&quot;thinkwon&quot;</span>);</span><br><span class="line">        <span class="comment">// doge</span></span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组构造器方法引用"><a href="#数组构造器方法引用" class="headerlink" title="数组构造器方法引用"></a>数组构造器方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer[]&gt; function = Integer[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// Function&lt;Integer, Integer[]&gt; function1 = (Integer i) -&gt; new Integer[i];</span></span><br><span class="line">Integer[] array = function.apply(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// [null, null, null, null, null, null, null, null, null, null]</span></span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Filter-amp-Predicate"><a href="#Filter-amp-Predicate" class="headerlink" title="Filter &amp; Predicate"></a>Filter &amp; Predicate</h1><p>常规用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(args[])</span></span>&#123;</span><br><span class="line">    List languages = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Scala&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Haskell&quot;</span>, <span class="string">&quot;Lisp&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Languages which starts with J :&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.startsWith(<span class="string">&quot;J&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Languages which ends with a &quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.endsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print all languages :&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print no language : &quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;<span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print language whose length greater than 4:&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.length() &gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate condition)</span> </span>&#123;</span><br><span class="line">    names.stream().filter((name) -&gt; (condition.test(name))).forEach((name) -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>多个Predicate组合filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用and()、or()和xor()逻辑函数来合并Predicate，</span></span><br><span class="line"><span class="comment">// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入</span></span><br><span class="line">Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == <span class="number">4</span>;</span><br><span class="line">names.stream()</span><br><span class="line">    .filter(startsWithJ.and(fourLetterLong))</span><br><span class="line">    .forEach((n) -&gt; System.out.print(<span class="string">&quot;nName, which starts with &#x27;J&#x27; and four letter long is : &quot;</span> + n));</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/22/Spring-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/22/Spring-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Spring核心基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-22 10:52:05" itemprop="dateCreated datePublished" datetime="2021-10-22T10:52:05+08:00">2021-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 16:57:59" itemprop="dateModified" datetime="2023-09-05T16:57:59+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-Bean命名策略"><a href="#Spring-Bean命名策略" class="headerlink" title="Spring Bean命名策略"></a>Spring Bean命名策略</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们有多个相同类型的实现时，命名<code>Spring bean</code>非常有用。这是因为如果我们的 bean 没有唯一的名称，Spring 将不明确注入 bean。</p>
<p>通过控制 bean 的命名，我们可以告诉 Spring 我们要将哪个 bean 注入目标对象。</p>
<p>在本文中，我们将讨论 Spring bean 命名策略，并探讨如何为单一类型的 bean 赋予多个名称。</p>
<h2 id="默认-Bean-命名策略"><a href="#默认-Bean-命名策略" class="headerlink" title="默认 Bean 命名策略"></a>默认 Bean 命名策略</h2><p>Spring为创建 bean提供了多个注解。我们可以在不同级别使用这些注解。例如，我们可以在 bean 类上放置一些注解，而在创建 bean 的方法上放置其他注解。</p>
<p>首先，让我们看看 Spring 的默认命名策略。当我们只指定注解而没有任何值时，Spring 如何命名我们的 bean？</p>
<h3 id="类级注解"><a href="#类级注解" class="headerlink" title="类级注解"></a>类级注解</h3><p>让我们从在类级别使用的注解的默认命名策略开始。为了给 bean 命名，<span style="color:#b30049;font-weight: bold">Spring 使用类名并将第一个字母转换为小写</span>。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，Spring 为<code>LoggingService</code>类创建了一个 bean，并使用名称<code>loggingService</code>注册它。</p>
<p>这个相同的默认命名策略适用于用于创建 Spring bean 的所有类级注解，例如<span style="color:blue;font-weight:bold">@Component</span>、<span style="color:blue;font-weight:bold">@Service</span>和<span style="color:blue;font-weight:bold">@Controller</span>。</p>
<h3 id="方法级注解"><a href="#方法级注解" class="headerlink" title="方法级注解"></a>方法级注解</h3><p>Spring 提供了诸如<code>@Bean</code>和<code>@Qualifier</code>之类的注解，用于在方法上创建 bean 。</p>
<p>让我们看一个例子来理解<code>@Bean</code>注解的默认命名策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuditService <span class="title">audit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> AuditService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个配置类中，Spring在名称“ <em>audit</em> ”下注册了一个<code>AuditService</code>类型的 bean，<strong>因为当我们在方法上使用@Bean注解时，Spring 使用方法名称作为 bean 名称。</strong></p>
<p>我们也可以在方法上使用<code>@Qualifier</code>注解。</p>
<h2 id="Bean-的自定义命名"><a href="#Bean-的自定义命名" class="headerlink" title="Bean 的自定义命名"></a>Bean 的自定义命名</h2><p>当我们需要在同一个 Spring 上下文中创建多个相同类型的 bean 时，我们可以为 bean 指定自定义名称并使用这些名称引用它们。</p>
<p>那么，让我们看看如何为我们的 Spring bean 指定一个自定义名称：</p>
<h3 id="类级注解-1"><a href="#类级注解-1" class="headerlink" title="类级注解"></a>类级注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomComponent</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次，Spring 将创建名为“ <em>myBean</em> ”的<em>MyCustomComponent</em>类型的 bean 。</p>
<p>由于我们明确地为 bean 指定名称，Spring 将使用此名称，然后可以使用该名称来引用或访问 bean。</p>
<p>与<code>@Component(“myBean”)</code>类似，我们可以使用<code>@Service(“myService”)</code>、<code>@Controller(“myController”)</code>和<code>@Bean(“myCustomBean”)</code>等其他注解指定名称，然后Spring 会注册具有给定名称的那个 bean。</p>
<h3 id="方法级注解-1"><a href="#方法级注解-1" class="headerlink" title="方法级注解"></a>方法级注解</h3><p>正如我们之前看到的，<code>@Bean</code>注解是在方法级别应用的，默认情况下，Spring 使用方法名称作为 bean 名称。</p>
<p>这个默认的 bean 名称可以被覆盖——我们可以使用<code>@Bean</code>注解指定值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line">    @Bean(&quot;beanComponent&quot;)</span><br><span class="line">    public MyCustomComponent myComponent() &#123;</span><br><span class="line">        return new MyCustomComponent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，当我们想要获取一个<em>MyCustomComponent</em>类型的 bean 时，我们可以使用名称“ <em>beanComponent</em> ”来引用这个 bean 。</p>
<p>Spring <code>@Bean</code>注解通常在配置类方法中声明。它可以通过直接调用来引用同一个类中的其他<code>@Bean</code>方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/spring%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/beannamestrategy.png"></p>
<hr>
<h1 id="Spring-ApplicationContext"><a href="#Spring-ApplicationContext" class="headerlink" title="Spring ApplicationContext"></a>Spring ApplicationContext</h1><h2 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a><em>ApplicationContext</em>接口</h2><p>Spring 框架的主要特性之一是<code>IoC</code>（控制反转）容器。在Spring <code>IoC</code>容器负责管理应用程序的对象。它使用依赖注入来实现控制反转。</p>
<p><code>BeanFactory</code>和<code>ApplicationContext</code> 接口<strong>代表 Spring IoC 容器</strong>。在这里，<code>BeanFactory</code>是访问 Spring 容器的根接口。它提供了管理 bean 的基本功能。</p>
<p>另一方面，<code>ApplicationContext</code> 是<code>BeanFactory</code>的子接口。因此，它提供了<code>BeanFactory</code>的<em>所有功能</em>。</p>
<p>此外，它还<strong>提供了</strong> <strong>更多特定于企业的功能</strong>。<code>ApplicationContext</code>的重要特性是<strong>解析消息、支持国际化、发布事件和应用层特定上下文</strong>。这就是我们将其用作默认 Spring 容器的原因。</p>
<h2 id="在容器中配置Bean"><a href="#在容器中配置Bean" class="headerlink" title="在容器中配置Bean"></a>在容器中配置Bean</h2><p>正如我们所知，<code>ApplicationContext</code>的主要工作是管理 bean。</p>
<p>因此，应用程序必须向<code>ApplicationContext容器</code>提供 bean 配置。一个 Spring bean 配置由一个或多个 bean 定义组成。此外，Spring 支持不同的 bean 配置方式。</p>
<h3 id="基于-Java-的配置"><a href="#基于-Java-的配置" class="headerlink" title="基于 Java 的配置"></a>基于 Java 的配置</h3><p>首先，我们将从基于 Java 的配置开始，因为它是最新和最受欢迎的 bean 配置方式。它从 Spring 3.0 开始可用。</p>
<p>Java 配置通常在<code>@Configuration</code>类中使用带有 @Bean 注解的方法<em>。方法上的</em>@Bean<em>注解表明该方法创建了一个 Spring bean。此外，用</em><code>@Configuration</code>注解的类表示它包含Spring bean 配置。</p>
<p>现在让我们创建一个配置类来将我们的<code>AccountService</code>类定义为 Spring bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AccountService <span class="title">accountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountService(accountRepository());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountRepository();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><p>Spring 2.5 引入了基于注解的配置，作为在 Java 中启用 bean 配置的第一步。</p>
<p>在这种方法中，我们首先通过<code>XML</code>配置启用基于注解的配置。然后我们在 Java 类、方法、构造函数或字段上使用一组注解来配置 bean。这些注解的一些示例是<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Autowired</code>和<code>@Qualifier</code>。</p>
<p>值得注意的是，我们也将这些注解用于基于 Java 的配置。另外值得一提的是，Spring 会在每个版本中不断为这些注解添加更多功能。</p>
<p>现在让我们看一个这个配置的简单例子。</p>
<p>首先，我们将创建 XML 配置<code>user-bean-config.xml</code>以启用注解：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.baeldung.applicationcontext&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里，该注解的配置标签启用基于注解的映射。该<em>组件扫描</em>标签也告诉Spring到哪里寻找注解类。</p>
<p>其次，我们将创建<em>UserService</em>类并使用<code>@Component</code>注解将其定义为 Spring bean ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// user service code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-XML-的配置"><a href="#基于-XML-的配置" class="headerlink" title="基于 XML 的配置"></a>基于 XML 的配置</h3><p>最后，让我们看一下基于 XML 的配置。这是在 Spring 中配置 bean 的传统方式。</p>
<p>显然，在这种方法中，我们<strong>在一个 XML 配置文件中</strong>完成所有<strong>bean 映射</strong>。</p>
<p>因此，让我们创建一个 XML 配置文件<code>account-bean-config.xml</code>，并为我们的<em>AccountService</em>类定义 bean ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">	  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.applicationcontext.AccountService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;accountRepository&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountRepository&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.applicationcontext.AccountRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ApplicationContext-的类型"><a href="#ApplicationContext-的类型" class="headerlink" title="ApplicationContext 的类型"></a><em>ApplicationContext 的</em>类型</h2><p>Spring 提供了适合不同需求的不同类型的<code>ApplicationContext</code>容器。这些是<code>ApplicationContext</code>接口的实现。那么让我们来看看<code>ApplicationContext</code> 的一些常见类型。</p>
<h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a><em>AnnotationConfigApplicationContext</em></h3><p>首先我们来看一下Spring 3.0中引入的<code>AnnotationConfigApplicationContext</code>类。它可以采取与注解的类<code>@Configuration</code>，<code>@Component</code>，和JSR-330的元数据作为输入。从Java的配置类中加载上下文定义。</p>
<p>因此，让我们看一个使用<code>AnnotationConfigApplicationContext</code>容器和基于 Java 的配置的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AccountConfig.class);</span><br><span class="line">AccountService accountService = context.getBean(AccountService.class);</span><br></pre></td></tr></table></figure>

<h3 id="AnnotationConfigWebApplicationContext"><a href="#AnnotationConfigWebApplicationContext" class="headerlink" title="AnnotationConfigWebApplicationContext"></a><em>AnnotationConfigWebApplicationContext</em></h3><p>适用于 Web 应用下xml文件中加载上下文，使用注解方式加载上下文</p>
<p>当我们 在<code>web.xml</code>文件中配置 Spring 的<code>ContextLoaderListener servlet</code>侦听器或<code>Spring MVC DispatcherServlet</code>时，我们可能会使用这个类。</p>
<p>此外，从 Spring 3.0 开始，我们还可以通过编程方式配置这个应用程序上下文容器。我们需要做的就是实现<code>WebApplicationInitializer</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    AnnotationConfigWebApplicationContext context = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">    context.register(AccountConfig.class);</span><br><span class="line">    context.setServletContext(container);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servlet configuration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XmlWebApplicationContext"><a href="#XmlWebApplicationContext" class="headerlink" title="XmlWebApplicationContext"></a><em>XmlWebApplicationContext</em></h3><p>如果我们<strong>在 Web 应用程序中</strong>使用<strong>基于 XML 的配置</strong>，我们可以使用<code>XmlWebApplicationContext</code>类。</p>
<p>事实上，配置这个容器就像<code>AnnotationConfigWebApplicationContext</code>类，也就是说我们可以在<code>web.xml</code>中<em>配置它</em>， 或者实现<code>WebApplicationInitializer</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyXmlWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    XmlWebApplicationContext context = <span class="keyword">new</span> XmlWebApplicationContext();</span><br><span class="line">    context.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/applicationContext.xml&quot;</span>);</span><br><span class="line">    context.setServletContext(container);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Servlet configuration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileSystemXMLApplicationContext"><a href="#FileSystemXMLApplicationContext" class="headerlink" title="FileSystemXMLApplicationContext"></a><em>FileSystemXMLApplicationContext</em></h3><p>我们使用<code>FileSystemXMLApplicationContext</code>类<strong>从文件系统</strong>或 URL<strong>加载基于 XML 的 Spring 配置文件</strong>。当我们需要以编程方式加载<code>ApplicationContext</code>时，这个类很有用。一般来说，测试工具和独立应用程序是一些可能的用例。</p>
<p>例如，让我们看看如何创建这个 Spring 容器并为基于 XML 的配置加载 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">&quot;C:/myProject/src/main/resources/applicationcontext/account-bean-config.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(path);</span><br><span class="line">AccountService accountService = context.getBean(<span class="string">&quot;accountService&quot;</span>, AccountService.class);</span><br></pre></td></tr></table></figure>

<h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a><em>ClassPathXmlApplicationContext</em></h3><p>如果我们想<strong>从 classpath 加载 XML 配置文件</strong>，我们可以使用<code>ClassPathXmlApplicationContext</code>类。与<em>FileSystemXMLApplicationContext</em>类似<em>，</em>它对于测试工具以及嵌入在 JAR 中的应用程序上下文很有用。</p>
<p>那么让我们看一个使用这个类的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationcontext/account-bean-config.xml&quot;</span>);</span><br><span class="line">AccountService accountService = context.getBean(<span class="string">&quot;accountService&quot;</span>, AccountService.class);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="BeanFactory-和-ApplicationContext-的区别"><a href="#BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="BeanFactory 和 ApplicationContext 的区别"></a>BeanFactory 和 ApplicationContext 的区别</h1><p>Spring 框架带有两个 IOC 容器—— <code>BeanFactory</code>和<code>ApplicationContext</code>。该<em>Bean工厂</em>是IOC容器的最基本的版本，以及<em>ApplicationContext的</em>扩展的功能<em>Bean工厂</em>。</p>
<p>我们将通过实际示例了解这两个 IOC 容器之间的显着差异。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/spring%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/beanfactoryand%20context.png"></p>
<p>该<code>ApplicationContext</code>的带有先进的功能，包括正朝着企业应用面向好几个，而<em>Bean工厂</em>仅预装了基本功能。因此，通常建议使用<code>ApplicationContext</code>的，并且<strong>只有当内存消耗是至关重要的时候，我们才应该使用Bean工厂</strong>。</p>
<h1 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h1><p>在这篇文章中，我们将看到<code>@ComponentScan</code>注解可用的不同类型的过滤器选项 。</p>
<h2 id="ComponentScan过滤器"><a href="#ComponentScan过滤器" class="headerlink" title="@ ComponentScan过滤器"></a>@ <em>ComponentScan</em>过滤器</h2><p>默认情况下，使用<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>注解的<em>类</em>被注册为Spring beans。对于使用<code>@Component</code>注解的自定义注解的<em>类也是如此</em>。我们可以通过使用<code>@ComponentScan</code>注解的<code>includeFilters</code>和 <code>excludeFilters</code>参数 来扩展此行为。</p>
<p><strong>ComponentScan.Filter有五种类型的过滤器：</strong></p>
<ul>
<li><code>ANNOTATION</code>   按照注解过滤</li>
<li><code>ASSIGNABLE_TYPE</code>  按照给定的类型</li>
<li><code>ASPECTJ</code>  使用ASPECTJ表达式</li>
<li><code>REGEX</code>  正则表达式</li>
<li><code>CUSTOM</code>  自定义规则</li>
</ul>
<h2 id="FilterType-ANNOTATION"><a href="#FilterType-ANNOTATION" class="headerlink" title="FilterType.ANNOTATION"></a><em>FilterType.ANNOTATION</em></h2><p>例如，假设我们有一个<code>@Animal</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Animal &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们定义一个 使用*@Animal<em>的</em>Elephant*类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elephant</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>最后，让我们使用<code>FilterType.ANNOTATION</code>告诉 Spring 扫描 <code>@Animal</code> 注解的<em>类：扫描仪很好地拾取了我们的</em>Elephant</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">        classes = Animal.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanAnnotationFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="FilterType-ASSIGNABLE-TYPE"><a href="#FilterType-ASSIGNABLE-TYPE" class="headerlink" title="FilterType.ASSIGNABLE_TYPE"></a><em>FilterType.ASSIGNABLE_TYPE</em></h2><p>首先，让我们声明<em>Animal</em> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>再一次，让我们声明我们的<em>Elephant</em>类，这次实现<em>Animal</em>接口<em>：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elephant</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>让我们声明我们的<em>Cat</em>类也实现了<em>Animal：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们使用<em>ASSIGNABLE_TYPE</em>来引导 Spring 扫描<em>Animal</em>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,</span></span><br><span class="line"><span class="meta">        classes = Animal.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanAssignableTypeFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><em>Cat</em>和<em>Elephant 都</em>被扫描到。</p>
<h2 id="FilterType-REGEX"><a href="#FilterType-REGEX" class="headerlink" title="FilterType.REGEX"></a><em>FilterType.REGEX</em></h2><p>再一次，让我们声明我们的<em>Elephant</em>类。这次没有实现任何接口或使用任何注解进行注解<em>：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elephant</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>让我们再声明一个类<em>Cat</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们声明<em>Loin</em>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loin</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>让我们使用<em>FilterType</em>。<em>REGEX</em>指示 Spring 扫描与正则表达式<code>.*[nt]</code>匹配的类<em>。</em>我们的正则表达式计算所有包含<em>nt 的内容：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.REGEX,</span></span><br><span class="line"><span class="meta">        pattern = &quot;.*[nt]&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanRegexFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>这次在我们的测试中，我们将看到 Spring 扫描<em>Elephant</em>，而不是<em>Lion</em> <em>：</em></p>
<h2 id="FilterType-ASPECTJ"><a href="#FilterType-ASPECTJ" class="headerlink" title="FilterType.ASPECTJ"></a><em>FilterType.ASPECTJ</em></h2><p>对于这个用例，我们可以重用与上一节相同的三个类。</p>
<p>让我们使用<code>FilterType.ASPECTJ</code>来指示 Spring 扫描与我们的<em>AspectJ</em>表达式匹配的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.ASPECTJ,</span></span><br><span class="line"><span class="meta">  pattern = &quot;com.baeldung.componentscan.filter.aspectj.* &quot;</span></span><br><span class="line"><span class="meta">  + &quot;&amp;&amp; !(com.baeldung.componentscan.filter.aspectj.L* &quot;</span></span><br><span class="line"><span class="meta">  + &quot;|| com.baeldung.componentscan.filter.aspectj.C*)&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanAspectJFilterApp</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>虽然有点复杂，但我们这里的逻辑希望 bean 的类名中既不以“L”也不以“C”开头，因此我们又得到了<em>Elephant</em> s</p>
<hr>
<h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><h2 id="Autowire-消除歧义的需要"><a href="#Autowire-消除歧义的需要" class="headerlink" title="Autowire 消除歧义的需要"></a>Autowire 消除歧义的需要</h2><p>当需要自动注入特定精确的Bean时，<code>@Autowire</code>是一种很好的方式，尽管它很有用，但在某些用例中，仅此注解不足以让 Spring 了解要注入哪个 bean。</p>
<p><strong>默认情况下，Spring 按类型解析自动装配的条目。</strong></p>
<p><strong>如果容器中有多个相同类型的 bean，则框架将抛出NoUniqueBeanDefinitionException</strong>， 表明有多个 bean 可用于自动装配。</p>
<p>让我们想象这样一种情况，其中 Spring 存在两个可能的候选者作为 bean 协作者注入给定实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;barFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Formatter formatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们尝试将<em>FooService</em>加载到我们的上下文中，Spring 框架将抛出一个<code>NoUniqueBeanDefinitionException</code>。这是因为<strong>Spring 不知道要注入哪个 bean</strong>。为了避免这个问题，有几种解决方案；该<code>@Qualifier</code>注解就是其中之一。</p>
<h2 id="Qualifier注解"><a href="#Qualifier注解" class="headerlink" title="@ Qualifier注解"></a>@ <em>Qualifier</em>注解</h2><p>通过使用<code>@Qualifier</code>注解，我们可以<strong>消除需要注入哪个bean的问题</strong>。</p>
<p>让我们回顾一下之前的示例，看看我们如何通过包含*@Qualifier*注解来指示我们要使用哪个 bean 来解决问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Formatter formatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过包含*@Qualifier<em>注解，连同我们想要使用的具体实现的名称，在这个例子中为</em>Foo，*我们可以避免当 Spring 找到多个相同类型的 bean 时产生歧义。</p>
<p>我们需要<strong>考虑到要使用的限定符名称是@Component注解中声明的名称。</strong></p>
<p>请注意，我们也可以在<em>Formatter</em>实现类上使用<code>@Qualifier</code>注解，而不是在它们的<code>@Component</code>注解中指定名称，以获得相同的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;barFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Qualifier-VS-Primary"><a href="#Qualifier-VS-Primary" class="headerlink" title="@Qualifier VS @Primary"></a><em>@Qualifier</em> VS <em>@Primary</em></h2><p>还有另一个名为<code>@Primary</code>的注解 ，当依赖注入存在歧义时，我们可以使用它来决定注入哪个 bean。</p>
<p><strong>当存在多个相同类型的 bean 时，</strong>此注解<strong>定义了一个首选项</strong>。除非另有说明，否则将使用与@Primary注解关联的 bean 。</p>
<p>让我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">johnEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Employee(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">tonyEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Employee(<span class="string">&quot;Tony&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，两种方法都返回相同的<em>Employee</em>类型。Spring 将注入的 bean 是<em>tonyEmployee</em>方法返回的<em>bean</em>。这是因为它包含<code>@Primary</code>注解。当我们想要<strong>指定默认情况下应该注入哪个特定类型的 bean</strong>时，此注解很有用。</p>
<p>如果我们在某个注入时需要另一个 bean，我们需要特别指出它。我们可以通过*@Qualifier<em>注解来做到这一点。例如，我们可以通过使用</em>@Qualifier<em>注解来指定我们要使用</em>johnEmployee*方法返回的 bean 。</p>
<p>值得注意的是，<strong>如果@Qualifier和@Primary注解都存在，那么@Qualifier注解将具有优先权。</strong>基本上，<code>@Primary</code>定义了一个默认值，而<code>@Qualifier</code>则非常具体。</p>
<hr>
<h1 id="理解-Spring-中的-getBean"><a href="#理解-Spring-中的-getBean" class="headerlink" title="理解 Spring 中的 getBean()"></a>理解 Spring 中的 getBean()</h1><p>我们将介绍<code>BeanFactory.getBean()</code>方法的不同变体。</p>
<p>简而言之，正如该方法的名称所暗示的那样，<strong>它负责从 Spring 容器中检索 bean 实例</strong>。</p>
<h2 id="Spring-Beans-设置"><a href="#Spring-Beans-设置" class="headerlink" title="Spring Beans 设置"></a>Spring Beans 设置</h2><p>首先，让我们定义几个 Spring bean 进行测试。我们可以通过多种方式为 Spring 容器提供 bean 定义，但在我们的示例中，我们将使用基于注解的 Java 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &#123;&quot;tiger&quot;, &quot;kitty&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line">    <span class="function">Tiger <span class="title">getTiger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tiger(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;lion&quot;)</span></span><br><span class="line">    <span class="function">Lion <span class="title">getLion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Lion(<span class="string">&quot;Hardcoded lion name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经创建了两个 bean。<em>Lion</em>具有默认的单例范围。<em>Tiger</em>明确设置为原型范围。此外，请注意，我们为将在进一步请求中使用的每个 bean 定义了名称。</p>
<h2 id="getBean-API"><a href="#getBean-API" class="headerlink" title="getBean() API"></a><em>getBean()</em> API</h2><p><em>BeanFactory</em>提供了<code>getBean()</code>方法的<code>五种</code>不同签名</p>
<h3 id="按名称检索-Bean"><a href="#按名称检索-Bean" class="headerlink" title="按名称检索 Bean"></a>按名称检索 Bean</h3><p>让我们看看如何使用名称检索<em>Lion</em> bean 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object lion = context.getBean(<span class="string">&quot;lion&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(Lion.class, lion.getClass());</span><br></pre></td></tr></table></figure>

<p>在这个变体中，我们提供一个名称，作为回报，如果应用程序上下文中存在具有给定名称的 bean ，我们将获得一个<em>Object</em> 类的实例。否则，如果 bean 查找失败，则此实现和所有其他实现都将抛出<code>NoSuchBeanDefinitionException</code>。</p>
<p>主要的缺点是<strong>在检索 bean 后，我们必须将其强制转换为所需的类型</strong>如果返回的 bean 的类型与我们预期的不同，这可能会产生另一个异常。</p>
<h3 id="按名称和类型检索-Bean"><a href="#按名称和类型检索-Bean" class="headerlink" title="按名称和类型检索 Bean"></a>按名称和类型检索 Bean</h3><p>这里我们需要指定请求的 bean 的名称和类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lion lion = context.getBean(<span class="string">&quot;lion&quot;</span>, Lion.class);</span><br></pre></td></tr></table></figure>

<p>与前一种方法相比，这种方法更安全，因为我们可以立即获取有关类型不匹配的信息。</p>
<h3 id="按类型检索-Bean"><a href="#按类型检索-Bean" class="headerlink" title="按类型检索 Bean"></a>按类型检索 Bean</h3><p>使用<code>getBean()</code>的第三个变体， 仅指定 bean 类型就足够了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lion lion = context.getBean(Lion.class);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们需要<strong>特别注意一个潜在的模棱两可的结果</strong></p>
<p>在上面的示例中，由于<em>Lion</em>和<em>Tiger 都</em>实现了<em>Animal</em>接口，因此仅指定类型不足以明确确定结果。因此，我们得到一个<code>NoUniqueBeanDefinitionException</code>。</p>
<h3 id="使用构造函数参数按名称检索-Bean"><a href="#使用构造函数参数按名称检索-Bean" class="headerlink" title="使用构造函数参数按名称检索 Bean"></a>使用构造函数参数按名称检索 Bean</h3><p>除了 bean 名称，我们还可以传递构造函数参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = (Tiger) context.getBean(<span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;Siberian&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>这个方法有点不同，因为它只适用于具有原型作用域的 bean</strong>。</p>
<p>在单例的情况下，我们将得到一个<em>BeanDefinitionStoreException</em></p>
<p>因为原型 bean 每次从应用程序容器请求时都会返回一个新创建的实例，所以我们可以在调用<code>getBean()</code>时 <strong>即时提供构造函数参数</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = (Tiger) context.getBean(<span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;Siberian&quot;</span>);</span><br><span class="line">Tiger secondTiger = (Tiger) context.getBean(<span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;Striped&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Siberian&quot;</span>, tiger.getName());</span><br><span class="line">assertEquals(<span class="string">&quot;Striped&quot;</span>, secondTiger.getName());</span><br></pre></td></tr></table></figure>

<p>正如我们所见，根据我们在请求 bean 时指定为第二个参数的内容，每个<em>Tiger</em>获得不同的名称。</p>
<h3 id="使用构造函数参数按类型检索-Bean"><a href="#使用构造函数参数按类型检索-Bean" class="headerlink" title="使用构造函数参数按类型检索 Bean"></a>使用构造函数参数按类型检索 Bean</h3><p>这个方法类似于最后一个，但我们需要传递类型而不是名称作为第一个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = context.getBean(Tiger.class, <span class="string">&quot;Shere Khan&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Shere Khan&quot;</span>, tiger.getName());</span><br></pre></td></tr></table></figure>

<p>与使用构造函数参数按名称检索 bean 类似，<strong>此方法仅适用于具有原型范围的 bean</strong>。</p>
<h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><div class="note no-icon danger"><p>尽管在<em>BeanFactory</em>接口中定义了<em>getBean()<em>方法，但它最常通过</em>ApplicationContext</em>访问<em>。</em>通常，我们不想在我们的程序中直接使用getBean()方法。</p>
<p>Bean 应该由容器管理。如果我们想使用其中之一，我们应该依赖依赖注入而不是直接调用<em>ApplicationContext.getBean()</em> <em>。</em>这样，我们就可以避免将应用程序逻辑与框架相关的细节混合在一起。</p>
</div>

<hr>
<h1 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h1><p><strong>简单地说，我们可以使用@RequestParam从请求中提取查询参数、表单参数甚至文件。</strong></p>
<h2 id="一个简单的映射"><a href="#一个简单的映射" class="headerlink" title="一个简单的映射"></a><strong>一个简单的映射</strong></h2><p>假设我们有一个端点<code>/api/foos</code>，它接受一个名为<code>id</code>的查询参数 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用<code>@RequestParam</code>来提取<code>id</code>查询参数。</p>
<p>一个简单的 GET 请求将调用<em>getFoos</em>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=abc</span><br><span class="line">----</span><br><span class="line">ID: abc</span><br></pre></td></tr></table></figure>

<p>接下来，<strong>让我们看看注解的属性：name、 value、required和defaultValue。</strong></p>
<h2 id="指定请求参数名称"><a href="#指定请求参数名称" class="headerlink" title="指定请求参数名称"></a><strong>指定请求参数名称</strong></h2><p>幸运的是，<strong>我们可以使用name属性配置@RequestParam名称</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addFoo</span><span class="params">(<span class="meta">@RequestParam(name = &quot;id&quot;)</span> String fooId, <span class="meta">@RequestParam</span> String name)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + fooId + <span class="string">&quot; Name: &quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以做 <code>@RequestParam(value = “id”)</code>或者只是<code>@RequestParam(“id”)</code>。</p>
<h2 id="可选的请求参数"><a href="#可选的请求参数" class="headerlink" title="可选的请求参数"></a><strong>可选的请求参数</strong></h2><p>默认用<code>@RequestParam</code>注解的方法参数 是必须的。</p>
<p>这意味着如果请求中不存在该参数，我们将收到错误消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/foos HTTP/1.1</span><br><span class="line">-----</span><br><span class="line">400 Bad Request</span><br><span class="line">Required String parameter <span class="string">&#x27;id&#x27;</span> is not present</span><br></pre></td></tr></table></figure>

<p><strong>使用required 属性将@RequestParam配置为可选：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam(required = false)</span> String id)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，两者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=abc</span><br><span class="line">----</span><br><span class="line">ID: abc</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos</span><br><span class="line">----</span><br><span class="line">ID: null</span><br></pre></td></tr></table></figure>

<p>将正确调用该方法。</p>
<p><strong>当未指定参数时，方法参数绑定到null。</strong></p>
<h2 id="请求参数的默认值"><a href="#请求参数的默认值" class="headerlink" title="请求参数的默认值"></a><strong>请求参数的默认值</strong></h2><p>我们还可以 使用<em>defaultValue</em>属性为<code>@RequestParam</code>设置默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;test&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ID: &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这就像required=false， 因为用户不再需要提供参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos</span><br><span class="line">----</span><br><span class="line">ID: <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>尽管如此，我们仍然可以提供它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=abc</span><br><span class="line">----</span><br><span class="line">ID: abc</span><br></pre></td></tr></table></figure>

<p>请注意，当我们设置 <em>defaultValue</em> 属性时， <em>required</em>确实设置为<em>false</em>。</p>
<h2 id="映射所有参数"><a href="#映射所有参数" class="headerlink" title="映射所有参数"></a><strong>映射所有参数</strong></h2><p><strong>我们也可以有多个参数，而无需定义它们的名称</strong>或计数，只需使用<em>Map</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateFoos</span><span class="params">(<span class="meta">@RequestParam</span> Map&lt;String,String&gt; allParams)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Parameters are &quot;</span> + allParams.entrySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将反映发送的任何参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -F <span class="string">&#x27;name=abc&#x27;</span> -F <span class="string">&#x27;id=123&#x27;</span> http://localhost:8080/api/foos</span><br><span class="line">-----</span><br><span class="line">Parameters are &#123;[name=abc], [id=123]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="映射多值参数"><a href="#映射多值参数" class="headerlink" title="映射多值参数"></a><strong>映射多值参数</strong></h2><p>单个<code>@RequestParam</code>可以有多个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/foos&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoos</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;IDs are &quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring MVC 将映射一个逗号分隔的 id 参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=1,2,3</span><br><span class="line">----</span><br><span class="line">IDs are [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>或单独的id参数列表</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/foos?id=1&amp;id=2</span><br><span class="line">----</span><br><span class="line">IDs are [1,2]</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Component-vs-Repository-和-Service-在-Spring-中区别"><a href="#Component-vs-Repository-和-Service-在-Spring-中区别" class="headerlink" title="@Component vs @Repository 和 @Service 在 Spring 中区别"></a>@Component vs @Repository 和 @Service 在 Spring 中区别</h1><p>在大多数典型的应用程序中，我们有不同的层，如数据访问、表示、服务、业务等。</p>
<p>此外，在每一层中，我们都有不同的 bean。为了自动检测这些 bean，<strong>Spring 使用类路径扫描注释</strong>。</p>
<p>然后它在<em>ApplicationContext 中</em>注册每个 bean 。</p>
<p>以下是其中一些注释的快速概览：</p>
<ul>
<li><code>@Component</code>是任何 Spring 管理的组件的通用<em>构造</em>型。</li>
<li><code>@Service</code>在服务层注释类。</li>
<li><code>@Repository</code>在持久层注释类，它将充当数据库存储库。</li>
</ul>
<h2 id="有什么不同？"><a href="#有什么不同？" class="headerlink" title="有什么不同？"></a>有什么不同？</h2><p><strong>这些刻板印象之间的主要区别在于它们用于不同的分类。</strong>当我们为自动检测注释一个类时，我们应该使用相应的构造型。</p>
<p>现在让我们更详细地了解它们。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><strong>@Component</strong></h3><p><strong>我们可以在整个应用程序中使用 @Component 将 bean 标记为 Spring 的托管组件</strong>。<code>@Component</code>是任何 Spring 管理的组件的通用构造型。Spring 只会使用<code>@Component</code>获取和注册 bean ，一般不会查找<code>@Service</code> 和 <code>@Repository</code>。</p>
<p>它们在<em>ApplicationContext</em>中注册，因为它们用<code>@Component</code>作为元注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>@Service 和 @Repository是@Component的特例，相当于给@Component 起的别名。它们在技术上是相同的，但我们将它们用于不同的目的。</p>
</div>



<h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a><strong>@Repository</strong></h3><p><strong>@Repository的工作是捕获特定于持久性的异常并将它们作为 Spring 的统一未检查异常之一重新抛出</strong>。</p>
<p>为此，Spring 提供了<em>PersistenceExceptionTranslationPostProcessor</em>，我们需要将其添加到我们的应用程序上下文中（如果我们使用 Spring Boot，则已包含）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=</span></span><br><span class="line"><span class="tag">  &quot;<span class="attr">org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor</span>&quot;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 bean 后处理器向任何用*@Repository*注释的 bean 添加了一个顾问 <em>。</em></p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a><strong>@Service</strong></h3><p><strong>我们用 @Service 标记 bean 以表明它们持有业务逻辑</strong>。除了在服务层使用之外，这个注解没有任何其他特殊用途。</p>
<hr>
<h1 id="Spring-中基于-XML-的注入"><a href="#Spring-中基于-XML-的注入" class="headerlink" title="Spring 中基于 XML 的注入"></a>Spring 中基于 XML 的注入</h1><p>让我们从在<em>pom.xml 中</em>添加 Spring 的库依赖开始：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="依赖注入——概述"><a href="#依赖注入——概述" class="headerlink" title="依赖注入——概述"></a><strong>依赖注入——概述</strong></h2><p><a target="_blank" rel="noopener" href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">依赖注入</a>是一种技术，其中对象的依赖项由外部容器提供。</p>
<p>假设我们有一个依赖于实际处理业务逻辑的服务的应用程序类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line">    <span class="comment">// standard constructors/getters/setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们说<code>IService</code>是一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口可以有多个实现。</p>
<p>让我们快速看一下一个潜在的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<em>IndexApp</em>是一个依赖于名为<em>IService</em>的低级组件的高级组件。</p>
<p>从本质上讲，我们将<em>IndexApp</em>与<em>IService</em>的特定实现分离，该实现可能因各种因素而异。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="使用属性注入"><a href="#使用属性注入" class="headerlink" title="使用属性注入"></a><strong>使用属性注入</strong></h3><p>让我们看看如何使用基于 XML 的配置将依赖项连接在一起：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;indexService&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexService&quot;</span> /&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;indexService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<p>可以看出，我们正在创建一个<em>IndexService</em>实例并为其分配一个 id。默认情况下，bean 是单例。此外，我们正在创建<em>IndexApp</em>的实例。</p>
<p>在这个 bean 中，我们使用 setter 方法注入另一个 bean。</p>
<h3 id="使用构造函数注入"><a href="#使用构造函数注入" class="headerlink" title="使用构造函数注入"></a><strong>使用构造函数注入</strong></h3><p>我们可以使用构造函数注入依赖项，而不是通过 setter 方法注入 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;indexService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<h3 id="使用静态工厂"><a href="#使用静态工厂" class="headerlink" title="使用静态工厂"></a><strong>使用静态工厂</strong></h3><p>我们也可以注入一个由工厂返回的 bean。让我们创建一个简单的工厂，根据提供的数字返回<em>IService</em>的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IService <span class="title">getNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们看看我们如何使用上述实现使用基于 XML 的配置将 bean 注入到<em>IndexApp 中</em>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.StaticServiceFactory&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们使用<em>factory-method</em>调用静态<em>getService</em>方法来创建一个带有 id <em>messageService</em>的 bean ，我们将其注入<em>IndexApp。</em></p>
<h3 id="使用工厂方法"><a href="#使用工厂方法" class="headerlink" title="使用工厂方法"></a><strong>使用工厂方法</strong></h3><p>让我们考虑一个实例工厂，它根据提供的数字返回一个<em>IService</em>实例。这一次，该方法不是静态的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IService <span class="title">getNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们看看我们如何使用上面的实现来使用 XML 配置将 bean 注入到<em>IndexApp 中</em>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;indexServiceFactory&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.InstanceServiceFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.InstanceServiceFactory&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;indexServiceFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;indexApp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baeldung.di.spring.IndexApp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用<em>factory-method</em>调用<em>InstanceServiceFactory 实例</em>上的<em>getService</em>方法来创建一个带有 id <em>messageService</em>的 bean ，我们将其注入<em>IndexApp</em>。</p>
<h2 id="访问配置的bean："><a href="#访问配置的bean：" class="headerlink" title="访问配置的bean："></a>访问配置的bean：</h2><p>这是我们如何访问配置的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenGetBeans_returnsBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    IndexApp indexApp = applicationContext.getBean(<span class="string">&quot;indexApp&quot;</span>, IndexApp.class);</span><br><span class="line">    assertNotNull(indexApp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用带有默认值的-Spring-Value"><a href="#使用带有默认值的-Spring-Value" class="headerlink" title="使用带有默认值的 Spring @Value"></a>使用带有默认值的 Spring @Value</h1><h2 id="字符串默认值"><a href="#字符串默认值" class="headerlink" title="字符串默认值"></a><strong>字符串默认值</strong></h2><p>让我们看一下为<em>String</em>属性设置默认值的基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:my default value&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String stringWithDefaultValue;</span><br></pre></td></tr></table></figure>

<p>如果<code>some.key</code>无法解析，<code>stringWithDefaultValue</code>将设置为<code>my default value</code>的默认值。</p>
<p>同样，我们可以设置一个零长度的<em>字符串</em>作为默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:&#125;)</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">private String stringWithBlankDefaultValue;</span></span><br></pre></td></tr></table></figure>

<p><strong>基本类型默认值</strong></p>
<p>要为基本类型（例如<em>boolean</em>和<em>int ）</em>设置默认值，我们使用文字值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:true&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> booleanWithDefaultValue;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:42&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> intWithDefaultValue;</span><br></pre></td></tr></table></figure>

<p>如果我们愿意，我们可以通过将类型更改为<em>Boolean</em>和<em>Integer</em>来使用原始包装器。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>我们还可以将逗号分隔的值列表注入数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:one,two,three&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String[] stringArrayWithDefaults;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;some.key:1,2,3&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] intArrayWithDefaults;</span><br></pre></td></tr></table></figure>

<p>在上面的第一个示例中，值<em>one</em>、<em>two</em> 和<em>three作为默认值注入到</em>stringArrayWithDefaults 中。</p>
<h2 id="使用-SpEL-的高级示例"><a href="#使用-SpEL-的高级示例" class="headerlink" title="使用 SpEL 的高级示例"></a>使用 SpEL 的高级示例</h2><p>我们还可以使用 SpEL 表达式来获取值。</p>
<p>如果我们有一个名为<em>priority</em>的系统属性<em>，</em>那么它的值将应用于该字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;priority&#x27;]&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String spelValue;</span><br></pre></td></tr></table></figure>

<p>如果我们还没有定义系统属性，那么将分配<em>空</em>值。</p>
<p>为了防止这种情况，我们可以在 SpEL 表达式中提供一个默认值。如果未定义系统属性，我们会为该字段获取<em>一些默认</em>值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;unknown&#x27;] ?: &#x27;some default&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String spelSomeDefault;</span><br></pre></td></tr></table></figure>

<p>此外，我们可以使用来自其他 bean 的字段值。假设我们有一个名为<em>someBean</em>的 bean ，其字段<em>someValue</em>等于<em>10</em>。然后，将<em>10</em>分配给该字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;someBean.someValue&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer someBeanValue;</span><br></pre></td></tr></table></figure>

<p>我们可以操作属性来获取值<em>列表</em>，这里是字符串值 A、B 和 C 的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;&#x27;$&#123;listOfValues&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; valuesList;</span><br></pre></td></tr></table></figure>

<h2 id="Value-“-”-和-Value-“-”-的区别"><a href="#Value-“-”-和-Value-“-”-的区别" class="headerlink" title="@Value(“${}”)和@Value(“#{}”)的区别"></a>@Value(“${}”)和@Value(“#{}”)的区别</h2><ul>
<li><code>@Value("$&#123;&#125;")</code>主要获取的是配置文件<code> application.yml /application.proterties</code>中的配置信息。</li>
<li><code>@Value("#&#123;&#125;")</code> 表示SpEl表达式通常用来获取<code>bean的属性</code>，或者调用bean的某个方法或属性。当然还有可以表示常量</li>
</ul>
<p>在下面的示例中，我们希望将<em>some.system.key</em>设置为系统属性，如果未设置，我们希望使用<em>我的默认系统属性值</em> 作为默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;some.key&#x27;] ?: &#x27;my default system property value&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String spelWithDefaultValue;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Autowired-vs-Resource-vs-Inject-的区别"><a href="#Autowired-vs-Resource-vs-Inject-的区别" class="headerlink" title="@Autowired vs @Resource vs @Inject 的区别"></a>@Autowired vs @Resource vs @Inject 的区别</h1><p>为了实现依赖注入 DI 而引入，Java 提供<code>javax.annotation.Resource</code> , <code>javax.inject.Inject</code> 注解，Spring 框架提供了 <code>org.springframework.beans.factory.annotation.Autowired</code>。依赖注入（Denpendency Injection，DI）， 控制反转（Inversion of Control, IoC），主要的目的是去除代码耦合。</p>
<h2 id="具体解释"><a href="#具体解释" class="headerlink" title="具体解释"></a>具体解释</h2><table>
<thead>
<tr>
<th align="left">Annotation</th>
<th align="left">Package</th>
<th align="left">Source</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Autowired</td>
<td align="left">org.springframework.beans.factory.annotation.Autowire</td>
<td align="left">Spring</td>
</tr>
<tr>
<td align="left">@Resource</td>
<td align="left">javax.annotation.Resource</td>
<td align="left">Java</td>
</tr>
<tr>
<td align="left">@Inject</td>
<td align="left">javax.inject.Inject</td>
<td align="left">Java 需额外依赖</td>
</tr>
</tbody></table>
<p><code>@Autowired</code>: Spring 特有的注解，@Autowired 通过<strong>类型</strong>来注入，比如通过类的类型，或者类的接口来注解 field 或者 constructor。为了防止在项目中实现同一个接口，或者一系列子类，可以使用 @Qualifier 注解来避免歧义。默认情况下 bean 的名字就是 qualifier 的值。 尽管你可以按照约定通过名字来使用 @Autowired 注解，@Autowired 根本上还是<strong>类型驱动</strong>的注入，并且附带可选的语义上的 qualifiers.</p>
<p><code>@Inject</code>: 该注解基于 <a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=330">JSR-330</a>, @Inject 注解是 Spring @Autowired 注解的代替品。所以使用 Spring 独有的 @Autowired 注解时，可以考虑选择使用 @Inject. @Autowired 和 @Inject 的不同之处在于是否有<code>required</code>属性，@Inject 没有 required 属性，因此在找不到合适的依赖对象时 inject 会失败，而 @Autowired 可以使用 required=false 来允许 null 注入。</p>
<p>使用 @Inject 需要添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Advantage of @Inject annotation is that rather than inject a reference directly, you could ask @Inject to inject a Provider. The Provider interface enables, among other things, lazy injection of bean references and injection of multiple instances of a bean. In case we have few implementation of an interface or a subclass we can narrow down the selection using the @Named annotation to avoid ambiguity. @Named annotation works much like Spring’s @Qualifier</p>
<p><code>@Resource</code>: JDK 1.6 支持注解，<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=250">JSR-250</a> 引入。@Resource 和 @Autowired @Inject 类似，最主要的区别在于寻找存在的 Bean 注入的路径不同。<code>@Resource</code>寻找的优先顺序为</p>
<ul>
<li>1）优先通过名字 (by name)</li>
<li>2）其次是类型 (by type)</li>
<li>3）再次是 qualifier(by qualifier)</li>
</ul>
<p>而 <code>@Autowired</code> and <code>@Inject</code> 寻找的顺序为</p>
<ol>
<li>通过类型寻找</li>
<li>通过 qualifier</li>
<li>最后通过名字寻找</li>
</ol>
<p>@Resource 如果没有指定 name 属性，当注解标注在 field 上，默认取字段名称作为 bean 名称寻找依赖对象；当标注在属性 setter 方法上，默认取属性名作为 bean 名称寻找依赖。如果没有指定 name 属性，并且按照默认名称找不到依赖对象时，回退到类型装配。</p>
<hr>
<h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p>从 Spring 2.5 开始，该框架引入了注解驱动的<em>依赖注入</em>。此功能的主要注释是<code>@Autowired</code> <em>。</em> <strong>它允许 Spring 解析并将协作 bean 注入到我们的 bean 中。</strong></p>
<h2 id="启用-Autowired注解"><a href="#启用-Autowired注解" class="headerlink" title="启用@Autowired注解"></a>启用@Autowired注解</h2><p>Spring 框架支持自动依赖注入。换句话说，<strong>通过在 Spring 配置文件中声明所有 bean 依赖项，Spring 容器可以自动装配协作 bean 之间的关系</strong>。这称为<strong>Spring bean 自动装配</strong>。</p>
<p>要在我们的应用程序中使用基于 Java 的配置，让我们启用注解驱动注入 来加载我们的 Spring 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.baeldung.autowire.sample&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>或者，注解主要用于激活 Spring XML 文件中的依赖注入注解。</p>
<p>此外，<strong>Spring Boot 引入了@SpringBootApplication注解</strong>。这个单一的注解等效于使用<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和 <code>@ComponentScan</code>。</p>
<p>让我们在应用程序的主类中使用这个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactoryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(VehicleFactoryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，当我们运行这个 Spring Boot 应用程序时，<strong>它会自动扫描当前包及其子包中的组件</strong>。因此，它将在 Spring 的应用程序上下文中注册它们，并允许我们使用<code>@Autowired</code>注入 bean 。</p>
<h2 id="使用-Autowired"><a href="#使用-Autowired" class="headerlink" title="使用@Autowired"></a>使用@Autowired</h2><p>启用注解注入后，<strong>我们可以在属性、设置器和构造函数上使用自动装配</strong>。</p>
<h3 id="Autowired用在属性上"><a href="#Autowired用在属性上" class="headerlink" title="@Autowired用在属性上"></a><strong>@Autowired用在属性上</strong></h3><p>让我们看看如何使用<code>@Autowired</code>注释属性。这消除了对 getter 和 setter 的需要。</p>
<p>首先，让我们定义一个<em>fooFormatter</em> bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooFormatter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们将在字段定义上使用*@Autowired<em>将此 bean 注入</em>FooService* bean ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其结果是，Spring注入<em>fooFormatter</em>时<em>FooService接口</em>被创建。</p>
<h3 id="Autowired在-Setter-上"><a href="#Autowired在-Setter-上" class="headerlink" title="@Autowired在 Setter 上"></a><strong>@Autowired在 Setter 上</strong></h3><p>现在让我们尝试在 setter 方法上添加 @Autowired 注释。</p>
<p>在以下示例中，在创建<em>FooService</em>时使用<em>FooFormatter</em>实例调用 setter 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFooFormatter</span><span class="params">(FooFormatter fooFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fooFormatter = fooFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Autowired在构造函数上"><a href="#Autowired在构造函数上" class="headerlink" title="@Autowired在构造函数上"></a><strong>@Autowired在构造函数上</strong></h3><p>最后，让我们在构造函数上使用 @Autowired 。</p>
<p>我们将看到Spring 注入了一个<em>FooFormatter</em>实例作为<em>FooService</em>构造函数的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooService</span><span class="params">(FooFormatter fooFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fooFormatter = fooFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Autowired-可选注入"><a href="#Autowired-可选注入" class="headerlink" title="@Autowired 可选注入"></a><em>@Autowired</em> 可选注入</h2><p>在构建 bean 时，@ <em>Autowired</em>依赖项应该可用。否则，<strong>如果 Spring 无法解析用于连接的 bean，它将抛出异常</strong>。</p>
<p>因此，它会阻止 Spring 容器成功启动，但以下形式除外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: </span><br><span class="line">No qualifying bean of type [com.autowire.sample.FooDAO] found <span class="keyword">for</span> dependency: </span><br><span class="line">expected at least <span class="number">1</span> bean which qualifies as autowire candidate <span class="keyword">for</span> <span class="keyword">this</span> dependency. </span><br><span class="line">Dependency annotations: </span><br><span class="line">&#123;<span class="meta">@org</span>.springframework.beans.factory.annotation.Autowired(required=<span class="keyword">true</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们需要required解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> FooDAO dataAccessor; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="PropertySource注解"><a href="#PropertySource注解" class="headerlink" title="@PropertySource注解"></a>@PropertySource注解</h1><p><code>@PropertySource</code>注解是Spring 3.1开始引入的配置类注解。通过<code>@PropertySource</code>注解将<code>properties</code>配置文件中的值存储到Spring的<code>Environment</code>中，<code>Environment</code>接口提供方法去读取配置文件中的值，参数是<code>properties</code>文件中定义的key值。也可以使用<code>@Value</code>注解用<code>$&#123;&#125;</code>占位符注入属性</p>
<p><code>@PropertySource</code>注解的源代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertySourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(PropertySources.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PropertySource &#123;</span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">	String[] value();</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">	Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> PropertySourceFactory.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>@PropertySource</code>的源码可以看出，我们可以通过<code>@PropertySource</code>注解指定多个<code>properties</code>文件，可以使用如下形式进行指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value=&#123;&quot;classpath:xxx.properties&quot;, &quot;classpath:yyy.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>细心的读者可以看到，在<code>@PropertySource</code>注解类的上面标注了如下的注解信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(PropertySources.class)</span></span><br></pre></td></tr></table></figure>

<p>看到这里，小伙伴们是不是有种恍然大悟的感觉呢？没错，我们也可以使用<code>@PropertySources</code>注解来指定<code>properties</code>配置文件。</p>
<h2 id="通过注解注册一个配置文件"><a href="#通过注解注册一个配置文件" class="headerlink" title="通过注解注册一个配置文件"></a>通过注解注册一个配置文件</h2><p>我们可以将此注解与<code>@Configuration</code>注解结合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:foo.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesWithJavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种注册新属性文件的非常有用的方法是使用占位符，它允许我们<strong>在运行时动态选择正确的文件</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123; </span></span><br><span class="line"><span class="meta">  &quot;classpath:persistence-$&#123;envTarget:mysql&#125;.properties&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="定义多个属性位置"><a href="#定义多个属性位置" class="headerlink" title="定义多个属性位置"></a>定义多个属性位置</h2><p>根据 Java 8 约定，<code>@PropertySource</code>注释是可重复的。因此，如果我们使用 Java 8 或更高版本，我们可以使用此注释来定义多个属性位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:foo.properties&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:bar.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesWithJavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，<strong>我们也可以使用@PropertySources注解，指定一个@PropertySource数组。</strong>这适用于任何受支持的 Java 版本，而不仅仅是 Java 8 或更高版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySources(&#123;</span></span><br><span class="line"><span class="meta">    @PropertySource(&quot;classpath:foo.properties&quot;),</span></span><br><span class="line"><span class="meta">    @PropertySource(&quot;classpath:bar.properties&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesWithJavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任何一种情况下，值得注意的是，在发生属性名称冲突的情况下，最后一个源读取优先。</p>
<h2 id="使用-注入属性"><a href="#使用-注入属性" class="headerlink" title="使用/注入属性"></a>使用/注入属性</h2><p><strong>使用@Value注释</strong>注入属性很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value( &quot;$&#123;jdbc.url&#125;&quot; )</span></span><br><span class="line"><span class="keyword">private</span> String jdbcUrl;</span><br></pre></td></tr></table></figure>

<p><strong>我们还可以为属性指定一个默认值：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value( &quot;$&#123;jdbc.url:aDefaultUrl&#125;&quot; )</span></span><br><span class="line"><span class="keyword">private</span> String jdbcUrl;</span><br></pre></td></tr></table></figure>

<p>Spring 3.1 中添加的新<em>PropertySourcesPlaceholderConfigurer</em>解析了 bean 定义属性值和@Value注释中的<code>$&#123;…&#125;</code> 占位符。</p>
<p>最后，我们可以 <strong>使用Environment API获取属性的值</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line">...</span><br><span class="line">dataSource.setUrl(env.getProperty(<span class="string">&quot;jdbc.url&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot-的属性"><a href="#Spring-Boot-的属性" class="headerlink" title="Spring Boot 的属性"></a>Spring Boot 的属性</h2><p>在我们进入更高级的属性配置选项之前，让我们花点时间看看 Spring Boot 中的新属性支持。</p>
<p>一般来说，<strong>与标准 Spring 相比</strong>，<strong>这种新支持涉及的配置更少</strong>，这当然是 Boot 的主要目标之一。</p>
<h3 id="application-properties：默认属性文件"><a href="#application-properties：默认属性文件" class="headerlink" title="application.properties：默认属性文件"></a>application.properties：默认属性文件</h3><p>Boot 将其典型的约定应用于属性文件的配置方法。这意味着<strong>我们可以简单地将application.properties文件放在我们的src/main/resources 目录中，它将被自动检测</strong>。然后我们可以像往常一样从它注入任何加载的属性。</p>
<p>因此，通过使用此默认文件，我们不必显式注册<em>PropertySource</em> ，甚至不必提供属性文件的路径。</p>
<p>从<em>2.4.0</em>版本开始，<strong>Spring Boot 支持使用多文档属性文件</strong>，类似于<a target="_blank" rel="noopener" href="https://yaml.org/spec/1.2/spec.html#id2760395">YAML</a>的设计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baeldung.customProperty=defaultValue</span><br><span class="line">#---</span><br><span class="line">baeldung.customProperty=overriddenValue</span><br></pre></td></tr></table></figure>

<p>请注意，对于属性文件，三个破折号符号前面有一个注释字符 ( <em>#</em> )。</p>
<h3 id="特定于环境的属性文件"><a href="#特定于环境的属性文件" class="headerlink" title="特定于环境的属性文件"></a><strong>特定于环境的属性文件</strong></h3><p>如果我们需要针对不同的环境，Boot 中有一个内置的机制。</p>
<p><strong>我们可以简单地在src/main/resources目录下定义一个application-environment.properties文件，然后设置一个具有相同环境名称的 Spring 配置文件。</strong></p>
<p>例如，如果我们定义一个“暂存”环境，这意味着我们必须定义一个<em>暂存</em>配置文件，然后是<em>application-staging.properties</em>。</p>
<p>此 env 文件将被加载并<strong>优先于默认属性文件。</strong>注意，默认文件还是会被加载，只是当发生属性冲突时，特定于环境的属性文件优先。<strong>替代方案：YAML 文件</strong></p>
<p>Spring 还支持 YAML 文件。</p>
<p>所有相同的命名规则都适用于特定于测试、特定于环境和默认属性文件。唯一的区别是文件扩展名和对我们类路径上的<a target="_blank" rel="noopener" href="https://bitbucket.org/asomov/snakeyaml">SnakeYAML</a>库的依赖。</p>
<p><strong>YAML 特别适合分层属性存储</strong>；以下属性文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database.url=jdbc:postgresql:/localhost:5432/instance</span><br><span class="line">database.username=foo</span><br><span class="line">database.password=bar</span><br><span class="line">secret: foo</span><br></pre></td></tr></table></figure>

<p>与以下 YAML 文件同义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">database:</span><br><span class="line">  url: jdbc:postgresql:/localhost:5432/instance</span><br><span class="line">  username: foo</span><br><span class="line">  password: bar</span><br><span class="line">secret: foo</span><br></pre></td></tr></table></figure>

<p>还值得一提的是，YAML 文件不支持*@PropertySource*注解，所以如果我们需要使用这个注解，它会限制我们使用属性文件。</p>
<p>另一个值得注意的地方是，在 2.4.0 版本中，Spring Boot 改变了从多文档 YAML 文件加载属性的方式。以前，它们的添加顺序基于配置文件激活顺序。然而，在新版本中，框架遵循我们之前为*.properties*文件指出的相同排序规则；在文件中声明较低的属性将简单地覆盖那些较高的属性。</p>
<p>此外，在此版本中，配置文件无法再从配置文件特定文档中激活，从而使结果更清晰、更可预测。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/19/Macbook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/19/Macbook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Macbook使用技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-19 16:34:26 / 修改时间：20:13:06" itemprop="dateCreated datePublished" datetime="2021-10-19T16:34:26+08:00">2021-10-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="批量更改文件名称"><a href="#批量更改文件名称" class="headerlink" title="批量更改文件名称"></a>批量更改文件名称</h1><p>对我而言这个功能最好用的是批量更改时替换功能，在截了一堆图需要改名字的时候就可以派上用场。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/batchRename1.png"></p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/batchRename2.png"></p>
<h1 id="聚焦Spotlight"><a href="#聚焦Spotlight" class="headerlink" title="聚焦Spotlight"></a>聚焦<strong>Spotlight</strong></h1><p>“聚焦”可以帮助您快速找到 Mac 上的 App、文稿和其他文件。借助 Siri 建议，您还可以获取最新新闻、体育赛事比分、天气状况等信息。“聚焦”甚至可以为您进行计算和转换。</p>
<h2 id="搜索内容"><a href="#搜索内容" class="headerlink" title="搜索内容"></a>搜索内容</h2><ol>
<li><p>在 Mac 上，点按<a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/guide/mac-help/aside/glos33eb8abd/11.0/mac/11.0">菜单栏</a>中的“聚焦”图标 <img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/bb4de0babc81c7fedb3e9663d00d7a3a.png" alt="img" style="zoom:25%;" />（如果显示），或者按下 Command-空格键或按下键盘上功能键行中的 <img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/bb4de0babc81c7fedb3e9663d00d7a3a.png" alt="聚焦键" style="zoom:25%;" />（如果可用）。</p>
<p>您可以将“聚焦”窗口拖到桌面上的任意位置。</p>
<p><strong>【提示】</strong>如果“聚焦”图标未显示在菜单栏中，请<a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/guide/mac-help/mchlp1119/11.0/mac/11.0">使用“程序坞与菜单栏”偏好设置</a>进行添加。</p>
</li>
<li><p>在搜索栏中，键入要查找的内容，键入时结果会随之出现。</p>
<p>“聚焦”首先列出最常点选，点按一个最常点选以进行预览或打开。“聚焦”还会建议搜索的各种变体；您可以在“聚焦”或网上查看这些结果。</p>
<p><img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/5026e0adf32c51825c1daf163ec73501.png" alt="“聚焦”窗口顶部显示了搜索栏中的搜索文本，下方是结果。"></p>
</li>
<li><p>在结果中，执行以下任一项操作：</p>
<ul>
<li><em>显示预览：</em>按下 Tab 键。根据结果中所选的项目类型，您可以与之交互。例如，选择 App 以查看最近打开文件的列表，然后点按以打开文件。或者点按“播放”按钮来聆听歌曲。</li>
</ul>
</li>
</ol>
<h2 id="在“聚焦”中进行计算和转换"><a href="#在“聚焦”中进行计算和转换" class="headerlink" title="在“聚焦”中进行计算和转换"></a>在“聚焦”中进行计算和转换</h2><p>您可以在“聚焦”搜索栏中输入数学表达式、金额、温度或单位，搜索栏中会立即显示转换或计算结果。</p>
<p><img src="https://help.apple.com/assets/605932B4A1B7A93F492858E8/605932C0A1B7A93F492858FF/zh_CN/6136d2d5c08bb8b6ebf10fc3c3248f48.png" alt="“聚焦”窗口，显示搜索栏中从码到米的转换。左侧是搜索结果列表。右侧预览中显示更多转换。"></p>
<ul>
<li><em>计算：</em>输入数学表达式，如 956*23.94 或 2020/15。</li>
<li><em>货币转换：</em>输入金额，如 100 美元、100 日元或“300 克朗转换成欧元”。</li>
<li><em>温度转换：</em>输入温度，如 98.8F、32C 或“340K 转换成华氏度”。</li>
<li><em>单位转换：</em>输入度量单位，例如 25 磅、54 码、23 英石或“32 英尺转换成米”。</li>
</ul>
<p><strong>【提示】</strong>按下 Tab 键以在预览区域中显示更多转换。</p>
<h1 id="快速添加emoji表情"><a href="#快速添加emoji表情" class="headerlink" title="快速添加emoji表情"></a>快速添加emoji表情</h1><p>按住键盘Control+Command+空格键，此时你的输入栏中，就会跳出所有表情了。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/emoji.png"></p>
<p>​                </p>
<h1 id="快速锁屏"><a href="#快速锁屏" class="headerlink" title="快速锁屏"></a>快速锁屏</h1><p>只需按住control+command+Q，此时你的MacBook就会马上锁屏</p>
<hr>
<h1 id="向后删除"><a href="#向后删除" class="headerlink" title="向后删除"></a>向后删除</h1><p>文本编辑时按 Fn + Delete 键可向后删除内容</p>
<hr>
<h1 id="切换应用程序"><a href="#切换应用程序" class="headerlink" title="切换应用程序"></a>切换应用程序</h1><p>按住command键再按tab键，可从左往右切换已打开的应用程序；command+shift+tab，可从右往左切换</p>
<hr>
<h1 id="触控板手势"><a href="#触控板手势" class="headerlink" title="触控板手势"></a>触控板手势</h1><p>Mac触控板强大无比，掌握触控板使用技能，对提高学习工作效率大有帮助，打开Mac系统偏好设置中的触控板，选择相应手势，右边会有动画教程。</p>
<p>还有一个比较特殊的手势，三指拖动，需在系统偏好设置下的辅助功能中设置。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/split.png"></p>
<hr>
<h1 id="设置文件默认打开方式"><a href="#设置文件默认打开方式" class="headerlink" title="设置文件默认打开方式"></a>设置文件默认打开方式</h1><p>不同格式的文件有不同的默认打开方式，比如视频文件会默认用QuickTime Player打开，如果你想更改系统默认的打开方式，按照如下步骤设置即可，</p>
<p>单击你想要改变默认打开方式的文件，右键单击选择显示简介，或者按快捷键Command+i 显示简介；</p>
<p>在打开方式的下拉菜单中选择你需要的默认打开方式，点击全部更改，在弹出的窗口中选择继续即可。</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/softopentype.png" style="zoom: 50%;" />

<hr>
<h1 id="自带截屏"><a href="#自带截屏" class="headerlink" title="自带截屏"></a>自带截屏</h1><ul>
<li><p>cmd+shift+3：对整个屏幕进行截图；</p>
</li>
<li><p>cmd+shift+4：对自行选择的区域进行截图；</p>
</li>
<li><p>cmd+shift+4+space（空格键）：对选定的某个应用程序界面窗口进行截图。</p>
</li>
</ul>
<hr>
<h1 id="Command（或-Cmd）⌘键"><a href="#Command（或-Cmd）⌘键" class="headerlink" title="Command（或 Cmd）⌘键"></a>Command（或 Cmd）⌘键</h1><p>以下是常用的12个快捷键：</p>
<ul>
<li>Command + X: 剪切</li>
<li>Command + C: 拷贝</li>
<li>Command + V: 原格式粘贴</li>
<li>Command + Shift +Option +V: 合并格式粘贴</li>
<li>Command + Z: 撤销上一个操作（Shift + Command + Z: 反向执行撤销命令）</li>
<li>Command + W: 关闭但不退出应用</li>
<li>Command + Q: 退出应用</li>
<li>Command + Option + Esc: 强制退出应用</li>
<li>Command + Tab: 切换应用</li>
<li>Command + 空格: “聚焦”查找</li>
<li>Command + Shift + 5（MacOS Mojave系统）: 截屏或录屏（其他MacOS: Command + Shift +3: 捕捉整个屏幕；Command + Shift +4: 自选截屏区域）</li>
<li>Command + Control + 空格: 添加emoji</li>
</ul>
<p>Command键除了上面 提到的常用组合快捷键外，还有很多其他功能，这里介绍四个关于Command的隐藏功能</p>
<ul>
<li>按住Command，可以选择并移动菜单栏图标</li>
</ul>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/top.png"></p>
<ul>
<li>在“聚焦”中搜索文件，按住Command就可以显示文件路径，按住Command打开文件可以打开所在的文件夹</li>
</ul>
<h1 id="Option（或-Alt）⌥键"><a href="#Option（或-Alt）⌥键" class="headerlink" title="Option（或 Alt）⌥键"></a>Option（或 Alt）⌥键</h1><ul>
<li><p>按住Option，可以同时关闭同个程序的多个窗口</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/MacBook/optioncloaseall.png" style="zoom:67%;" />
</li>
<li><p>按住Option，单击右侧翻页条任何位置，就可以快速跳到指定位置</p>
</li>
<li><p>『移动文件』CMD+C 复制文件，在目标目录 CMD+Option+V，就把原文件移动过来了，相当于剪切粘贴。</p>
</li>
<li><p>按住Option+拖到文件，可快速复制一份原文件</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/09/Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/09/Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/" class="post-title-link" itemprop="url">Javascript闭包（Closure）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-09 12:18:51" itemprop="dateCreated datePublished" datetime="2021-10-09T12:18:51+08:00">2021-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-23 14:25:18" itemprop="dateModified" datetime="2021-10-23T14:25:18+08:00">2021-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h1><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　alert(n);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　n=<span class="number">999</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1();</span><br><span class="line"></span><br><span class="line">　　alert(n); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<h2 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h2><p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n); <span class="comment">// 999</span></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>专业的讲，一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
<p>我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>上一节代码中的f2函数，就是闭包。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h1 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h1><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解这句话呢？请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h1 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h1><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/27/SpringBoot%E9%A1%B9%E7%9B%AE%E6%8A%A5%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%E7%9A%84%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/27/SpringBoot%E9%A1%B9%E7%9B%AE%E6%8A%A5%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%E7%9A%84%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">SpringBoot项目报端口冲突的错误</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 08:38:58" itemprop="dateCreated datePublished" datetime="2021-09-27T08:38:58+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近运行Springboot项目是，报了一个端口号被占用的错</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Web server failed to start. Port 10000 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#x27;s listening on port 10000 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/springbooterr.png"></p>
<p>报错原因：端口被占用。</p>
<p>解决办法</p>
<p>1.使用cmd命令查看端口号占用情况，例如查看端口10000，可以看出进程号为5372；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 10000</span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/findport.png"></p>
<p>2.关闭该进程</p>
<p>方法一： 使用命令关闭</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /F /pid 5372 </span><br></pre></td></tr></table></figure>

<p>如果是非管理员用户可能报拒绝访问的错误</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/confusetoaccess.png"></p>
<p>重新以管理员的身份打开cmd窗口，重新运行以上的关闭进程命令</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/opencmd.png"></p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/killtaskpidZ.png"></p>
<p>方法二：使用任务管理器关闭：</p>
<p>菜单栏 -&gt; 右键 - &gt; 任务管理器 -&gt; 详细信息，根据PID排序找到PID为5372的进程，选择后点击结束任务。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Springboot%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81/killtask.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/22/%E8%A7%A3%E5%86%B3Mysql5-7%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AFRestarting-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/22/%E8%A7%A3%E5%86%B3Mysql5-7%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AFRestarting-1/" class="post-title-link" itemprop="url">解决Mysql5.7一直重启Restarting(1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-22 16:16:44" itemprop="dateCreated datePublished" datetime="2021-09-22T16:16:44+08:00">2021-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>优于长时间没进Linux连接mysql，今天进入Linux连接mysql，使用<code>docker ps</code>，mysql的状态一直是Restarting (1) x seconds ago，mysql一直在重启无法连接</p>
<p>查看日志</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs mysql</span><br></pre></td></tr></table></figure>

<p>发现是内存不足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">2021-06-14T11:41:26.576589Z 0 [ERROR] InnoDB: Error number 28 means &#39;No space left on device&#39;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>使用 df -h 查看 发现是 /var/docker/overlay2里面的东西占了很大的空间</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/linuxdfh.png"></p>
<p>检查内存占用情况，发现vagrant占用36G，一路找下去，发现到application data目录无线循环，上网搜索发现了问题所在。</p>
<p><strong>ls查看发现里的东西很多和我本机C盘里的文件一模一样 AppData之类的 为什么这些东西会在虚拟机里 虚拟机同步了C盘里的内容 百度发现 vagrant提供了将本机</strong></p>
<p><strong>目录挂载到虚拟机目录下的功能，默认是将vagrant配置文件所在目录挂载到虚拟机/vagrant目录下。</strong></p>
<p><strong>也就是说 我的VagrantFile 是 C/user/username/VagrantFile 那么所有和VagrantFile同级的 C/user/username/里面的内容会全部同步到vagrant中 导致虚拟机内存爆满</strong></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ol>
<li><p>在和Vagrantfile同级目录（C:\Users\Administrator\）创建一个自己的文件夹,我的叫VagrantSyncFolder</p>
</li>
<li><p>然后打开目录到C:\Users\Administrator.vagrant.d\boxes\centos-VAGRANTSLASH-7\2004.01\virtualbox</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/vagrantfile.png"></p>
</li>
<li><p>打开Vagrantfile，</p>
<p>config.vm.synced_folder “.”, “/vagrant”, type: “rsync”</p>
<p>修改为</p>
<p>config.vm.synced_folder “./vagrantCache”, “/vagrant”, type: “rsync”</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/changevagrantfile.png"></p>
</li>
<li><p>修改完这个之后,vagrant reload发现还是不行,猜测可能只有vagrant成功重启之后修改的这个映射才能生效,但是已经占用100%不能成功重启,没办法,只能删东</p>
<p>西了</p>
<p>查看了一下vagrant目录里文件的大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>

<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/cdvagrant.png"></p>
<p>其中AppData很大</p>
<p>试着删了一下3D Objects文件里的一些东西,发现文件里的文件并没有影响,ok,直接将AppData删了,释放了很大的空间，然后exit退出</p>
<p>vagrant reload重启，大功告成！</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/%E8%A7%A3%E5%86%B3mysql%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/vagrantreload.png"></p>
</li>
</ol>
<p>其实这种情况，可能在使用vagrant  up命令的时候就会报Rsync 错误，可以参考这篇文章，其问题和上方的一样</p>
<p><a target="_blank" rel="noopener" href="https://www.dissmeyer.com/2020/02/11/issue-with-centos-7-vagrant-boxes-on-windows-10/">Windows 10 上的 CentOS 7 Vagrant 框出现 Rsync 错误</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/Vue3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/11/Vue3/" class="post-title-link" itemprop="url">Vue3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-11 19:52:10" itemprop="dateCreated datePublished" datetime="2021-09-11T19:52:10+08:00">2021-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>2020年9月18日Vue.js 3.0“海贼王”正式发布。该框架的这个新主要版本提供了改进的性能、更小的包大小、更好的 TypeScript 集成、用于处理大规模用例的新 API，以及该框架未来长期迭代的坚实基础。</p>
<p>特点：</p>
<ul>
<li>随着时间的推移，它演变成我们所说的“渐进式框架”：一个可以逐渐学习和采用的框架，同时随着用户处理越来越多的要求的场景提供持续的支持。</li>
<li>Vue 3.0 核心仍然可以通过一个简单的<code>&lt;script&gt;</code>标签使用，但它的内部已经从头开始重写为<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/tree/master/packages">一组解耦模块</a>。新架构提供了更好的可维护性，并允许最终用户通过 tree-shaking 将运行时大小减少一半。</li>
<li>2.x 基于对象的 API 在 Vue 3 中基本保持不变。但是，3.0 还引入了<a target="_blank" rel="noopener" href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API——</a>一组新的 API，旨在解决 Vue 在大规模应用程序中使用的痛点。</li>
<li>性能改进</li>
<li>Vue 3 的代码库是用 TypeScript 编写的，具有自动生成、测试和捆绑的类型定义，因此它们始终是最新的</li>
</ul>
<h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="使用-vue-cli-创建Vue3-0工程"><a href="#使用-vue-cli-创建Vue3-0工程" class="headerlink" title="使用 vue-cli 创建Vue3.0工程"></a>使用 vue-cli 创建Vue3.0工程</h2><p>先查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<p>如果版本过低，就需要安装或者升级你的@vue/cli</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>

<p>运行以下命令来创建一个新项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure>

<p>启动项目</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-world</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h1 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a><code>setup</code></h2><p>使用 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，<strong>逻辑关注点</strong>的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/options-api.png"></p>
<p>这是一个大型组件的示例，其中<strong>逻辑关注点</strong>按颜色进行分组。</p>
<p>这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块。</p>
<p>如果能够将同一个逻辑关注点相关代码收集在一起会更好。</p>
<p><span style="color:red"><strong>setup的设计是为了使用组合式api，使相关逻辑的代码集中在一起.</strong></span></p>
<h3 id="setup-组件选项"><a href="#setup-组件选项" class="headerlink" title="setup 组件选项"></a><code>setup</code> 组件选项</h3><p>新的 <code>setup</code> 选项在<strong>组件创建之前</strong>执行，一旦 <code>props</code> 被解析，就将作为组合式 API 的入口。</p>
<blockquote>
<p><span style="color:orange">在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例。<code>setup</code> 的调用发生在 <code>data</code> property、<code>computed</code> property 或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。</span></p>
</blockquote>
<p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数，此外，我们将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">prop,context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;prop:&quot;</span>,prop)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;context:&quot;</span>,context)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125; <span class="comment">// 这里返回的任何内容都可以用于组件的其余部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>setup</code> 函数时，它将接收两个参数：</p>
<ol>
<li><code>props</code></li>
<li><code>context</code></li>
</ol>
<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 prop 时，它将被更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:orange">但是，因为 <code>props</code> 是响应式的，你<strong>不能使用 ES6 解构</strong>，它会消除 prop 的响应性。</span></p>
</blockquote>
<p>如果需要解构 prop，可以在 <code>setup</code> 函数中使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84"><code>toRefs</code></a> 函数来完成此操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>title</code> 是可选的 prop，则传入的 <code>props</code> 中可能没有 <code>title</code> 。在这种情况下，<code>toRefs</code> 将不会为 <code>title</code> 创建一个 ref 。你需要使用 <code>toRef</code> 替代它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> title = toRef(props, <span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>props</code>在浏览器的控制台输出如下图：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3props.png"></p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露组件的三个 property：</p>
<p>的三个 property：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Attribute (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插槽 (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件 (方法)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, &#123; attrs, slots, emit &#125;</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。</p>
<p><code>context</code>在浏览器的控制台输出如下图：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3context.png"></p>
<p><code>setup</code>注意点：</p>
<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
<li><strong>在 <code>setup()</code> 内部，<code>this</code> 不是该活跃实例的引用</strong></li>
</ol>
<p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p>
<ul>
<li><code>props</code></li>
<li><code>attrs</code></li>
<li><code>slots</code></li>
<li><code>emit</code></li>
</ul>
<p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p>
<ul>
<li><code>data</code></li>
<li><code>computed</code></li>
<li><code>methods</code></li>
</ul>
<hr>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property <code>.value</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count.value++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    countAdd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将对象分配为 ref 值，则通过 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive">reactive</a> 方法使该对象具有高度的响应式。</p>
<p>使用数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>count: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;countAdd&quot;</span>&gt;</span>count++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 使用了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
<hr>
<h2 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h2><p>返回对象的响应式副本，Proxy的实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:green"><code>reactive</code> 将解包所有深层的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">refs</a>，同时维持 ref 的响应性。</span></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123; count &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref 会被解包</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count === count.value) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它会更新 `obj.count`</span></span><br><span class="line">count.value++</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它也会更新 `count` ref</span></span><br><span class="line">obj.count++</span><br><span class="line"><span class="built_in">console</span>.log(obj.count) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue3-0中的响应式原理"><a href="#Vue3-0中的响应式原理" class="headerlink" title="Vue3.0中的响应式原理"></a>Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li><p>实现原理: </p>
<ul>
<li><p>通过Proxy（代理）:  <strong>Proxy 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。</strong></p>
</li>
<li><p>通过Reflect（反射）:  使用 Proxy 的一个难点是 <code>this</code> 绑定。我们希望任何方法都绑定到这个 Proxy，而不是目标对象，这样我们也可以拦截它们。值得庆幸的是，ES6 引入了另一个名为 <code>Reflect</code> 的新特性，它允许我们以最小的代价消除了这个问题：</p>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure>

<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>有时我们需要依赖于其他状态的状态——在 Vue 中，这是用组件<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8">计算属性</a>处理的，以直接创建计算值，我们可以使用 <code>computed</code> 方法：它接受 getter 函数并为 getter 返回的值返回一个不可变的响应式 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%80%BC%E4%BD%9C%E4%B8%BA-refs">ref</a> 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> person = reactive(&#123;</span><br><span class="line">    firstName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  person.fullName = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> person.firstName + <span class="string">&#x27; &#x27;</span> + person.lastName</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   person</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请输入姓名<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>firstName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.firstName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.lastName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>fullName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; person.fullName &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3computed.png" style="zoom: 80%;" />

<p>或者，它可以使用一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> person = reactive(&#123;</span><br><span class="line">      firstName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      lastName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    person.fullName = computed(&#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> person.firstName + <span class="string">&quot; &quot;</span> + person.lastName;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> names = newValue.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        person.firstName = names[<span class="number">0</span>];</span><br><span class="line">        person.lastName = names[names.length - <span class="number">1</span>];</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      person,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>使用数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请输入姓名<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>fullName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.fullName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>firstName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; person.firstName &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; person.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/vue3computed1.png" style="zoom:80%;" />

<hr>
<h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。</p>
<h4 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h4><p>侦听器数据源可以是返回值的 getter 函数，也可以直接是 <code>ref</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h4><p>侦听器还可以使用数组同时侦听多个源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = ref(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> lastName = ref(<span class="string">&quot;san&quot;</span>);</span><br><span class="line"></span><br><span class="line">watch([firstName, lastName], <span class="function">(<span class="params">newValues, prevValues</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValues, prevValues);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeFirstName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  firstName.value = <span class="string">&quot;Steve&quot;</span>; <span class="comment">// logs: [&quot;Steve&quot;, &quot;san&quot;] [&quot;zhang&quot;, &quot;san&quot;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeLastName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  lastName.value = <span class="string">&quot;Jobs&quot;</span>;  <span class="comment">// logs: [&quot;zhang&quot;, &quot;Jobs&quot;] [&quot;zhang&quot;, &quot;san&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管如此，如果你在同一个方法里同时改变这些被侦听的来源，侦听器仍只会执行一次：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeFullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  firstName.value = <span class="string">&quot;Steve&quot;</span>;</span><br><span class="line">  lastName.value = <span class="string">&quot;Jobs&quot;</span>;</span><br><span class="line">  <span class="comment">// 打印 [&quot;Steve&quot;, &quot;Jobs&quot;] [&quot;zhang&quot;, &quot;san&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意多个同步更改只会触发一次侦听器。</p>
<p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、默认已经强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<hr>
<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><ul>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li><p>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</p>
</li>
<li><p>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line">watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.value</span><br><span class="line">    <span class="keyword">const</span> x2 = person.age</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/lifecycle.svg"  />

<p>下表包含如何在 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup ()</a> 内部调用生命周期钩子：</p>
<table>
<thead>
<tr>
<th>选项式 API</th>
<th>Hook inside <code>setup</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>beforeCreate</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>created</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>beforeMount</code></td>
<td><code>onBeforeMount</code></td>
</tr>
<tr>
<td><code>mounted</code></td>
<td><code>onMounted</code></td>
</tr>
<tr>
<td><code>beforeUpdate</code></td>
<td><code>onBeforeUpdate</code></td>
</tr>
<tr>
<td><code>updated</code></td>
<td><code>onUpdated</code></td>
</tr>
<tr>
<td><code>beforeUnmount</code></td>
<td><code>onBeforeUnmount</code></td>
</tr>
<tr>
<td><code>unmounted</code></td>
<td><code>onUnmounted</code></td>
</tr>
<tr>
<td><code>errorCaptured</code></td>
<td><code>onErrorCaptured</code></td>
</tr>
<tr>
<td><code>renderTracked</code></td>
<td><code>onRenderTracked</code></td>
</tr>
<tr>
<td><code>renderTriggered</code></td>
<td><code>onRenderTriggered</code></td>
</tr>
<tr>
<td><code>activated</code></td>
<td><code>onActivated</code></td>
</tr>
<tr>
<td><code>deactivated</code></td>
<td><code>onDeactivated</code></td>
</tr>
</tbody></table>
<blockquote>
<p><span style="color:green">因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写。</span></p>
</blockquote>
<h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a><code>toRef</code></h2><p>可以用来为源响应式对象上的某个 property 新创建一个 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = toRef(state, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fooRef.value++</span><br><span class="line"><span class="built_in">console</span>.log(state.foo) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">state.foo++</span><br><span class="line"><span class="built_in">console</span>.log(fooRef.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a><code>toRefs</code></h2><p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>。</p>
<p>当从组合式函数返回响应式对象时，<code>toRefs</code> 非常有用，这样消费组件就可以在不丢失响应性的情况下对返回的对象进行分解/扩散：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFeatureX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作 state 的逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回时转换为ref</span></span><br><span class="line">  <span class="keyword">return</span> toRefs(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在不失去响应性的情况下解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toRefs</code> 只会为源对象中包含的 property 生成 ref。如果要为特定的 property 创建 ref，则应当使用 <code>toRef</code></p>
<hr>
<h1 id="其他-Composition-API"><a href="#其他-Composition-API" class="headerlink" title="其他 Composition API"></a>其他 Composition API</h1><h2 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h2><ul>
<li><p><code>shallowReactive</code>：创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 state 本身的性质是响应式的</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="comment">// ...但是不转换嵌套对象</span></span><br><span class="line">isReactive(state.nested) <span class="comment">// false</span></span><br><span class="line">state.nested.bar++ <span class="comment">// 非响应式</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>shallowRef</code>：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = shallowRef(&#123;&#125;)</span><br><span class="line"><span class="comment">// 改变 ref 的值是响应式的</span></span><br><span class="line">foo.value = &#123;&#125;</span><br><span class="line"><span class="comment">// 但是这个值不会被转换。</span></span><br><span class="line">isReactive(foo.value) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么时候使用?</p>
<ul>
<li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; <code>shallowReactive</code>。</li>
<li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; <code>shallowRef</code>。</li>
</ul>
</li>
</ul>
<h2 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h2><ul>
<li><p><code>readonly</code>: 接受一个对象 (响应式或纯对象) 或 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = readonly(original)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用于响应性追踪</span></span><br><span class="line">  <span class="built_in">console</span>.log(copy.count)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更 original 会触发依赖于副本的侦听器</span></span><br><span class="line">original.count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更副本将失败并导致警告</span></span><br><span class="line">copy.count++ <span class="comment">// 警告!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shallowReadonly</code>：创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReadonly(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 state 本身的 property 将失败</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="comment">// ...但适用于嵌套对象</span></span><br><span class="line">isReadonly(state.nested) <span class="comment">// false</span></span><br><span class="line">state.nested.bar++ <span class="comment">// 适用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景: 不希望数据被修改时。</p>
</li>
</ul>
<h2 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h2><ul>
<li><p>toRaw：</p>
<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li><p>markRaw：</p>
<ul>
<li><p>作用：标记一个对象，使其永远不会再成为响应式对象。返回对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = markRaw(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(reactive(foo))) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套在其他响应式对象中时也可以使用</span></span><br><span class="line"><span class="keyword">const</span> bar = reactive(&#123; foo &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(bar.foo)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red">有些值不应该是响应式的，例如复杂的第三方类实例或 Vue 组件对象</span></p>
<p><span style="color:red">当渲染具有不可变数据源的大列表时，跳过 proxy 转换可以提高性能。</span></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h2><p>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收 <code>track</code> 和 <code>trigger</code> 函数作为参数，并且应该返回一个带有 <code>get</code> 和 <code>set</code> 的对象。</p>
<p>自定义customRef配合自定义hook函数使用。</p>
<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。类似于vue2.x中的mixin。自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
<p>在项目中新建hooks文件夹，在hooks文件夹下新建useDebounce.js文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, delay = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout</span><br><span class="line">    <span class="keyword">return</span> customRef(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          track()</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">          timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            value = newValue</span><br><span class="line">            trigger()</span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义 ref 通过 <code>v-model</code> 实现 debounce 的示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useDebouncedRef <span class="keyword">from</span> <span class="string">&#x27;../hooks/useDebounce&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text: useDebouncedRef(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><p>通常，当我们需要从父组件向子组件传递数据时，我们使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-props.html">props</a>。想象一下这样的结构：有一些深度嵌套的组件，而深层的子组件只需要父组件的部分内容。在这种情况下，如果仍然将 prop 沿着组件链逐级传递下去，可能会很麻烦。</p>
<p>对于这种情况，我们可以使用一对 <code>provide</code> 和 <code>inject</code>。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这些数据。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/vue3/components_provide.png"></p>
<p>用法:</p>
<p>父组件中提供：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = reactive(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    provide(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件中使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props,context</span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = inject(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<hr>
<h1 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h1><p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>
<p>让我们修改 <code>modal-button</code> 以使用 <code>&lt;teleport&gt;</code>，并告诉 Vue “<strong>Teleport</strong> 这个 HTML <strong>到</strong>该‘<strong>body</strong>’标签”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;modal-button&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;modalOpen = true&quot;&gt;</span></span><br><span class="line"><span class="string">        Open full screen modal! (With teleport!)</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;teleport to=&quot;body&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">          I&#x27;m a teleported modal! </span></span><br><span class="line"><span class="string">          (My parent is &quot;body&quot;)</span></span><br><span class="line"><span class="string">          &lt;button @click=&quot;modalOpen = false&quot;&gt;</span></span><br><span class="line"><span class="string">            Close</span></span><br><span class="line"><span class="string">          &lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      modalOpen: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="全局API的转移"><a href="#全局API的转移" class="headerlink" title="全局API的转移"></a>全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  inserted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close&#x3D;&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click&#x3D;&quot;handleNativeClickEvent&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#39;close&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/09/Vue-Router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/09/Vue-Router/" class="post-title-link" itemprop="url">Vue Router</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-09 11:26:13" itemprop="dateCreated datePublished" datetime="2021-09-09T11:26:13+08:00">2021-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure>

<h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><h2 id="引入插件并使用"><a href="#引入插件并使用" class="headerlink" title="引入插件并使用"></a>引入插件并使用</h2><p>在<code>main.js</code>中引入插件并使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>

<h2 id="编写router配置项"><a href="#编写router配置项" class="headerlink" title="编写router配置项:"></a>编写router配置项:</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Chinese <span class="keyword">from</span> <span class="string">&quot;../pages/Chinese.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> English <span class="keyword">from</span> <span class="string">&quot;../pages/English.vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/chinese&#x27;</span>,</span><br><span class="line">            component: Chinese</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/english&#x27;</span>,</span><br><span class="line">            component: English</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用router"><a href="#使用router" class="headerlink" title="使用router"></a>使用router</h2><p>在<code>main.js</code>中引入<code>router</code>并使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router: router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="实现路由页面切换"><a href="#实现路由页面切换" class="headerlink" title="实现路由页面切换"></a>实现路由页面切换</h2><p>（active-class可配置高亮样式）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/chinese&quot;</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/english&quot;</span>&gt;</span>英文<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定组件渲染的位置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h2><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件。</p>
<p>配置路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/chinese&#x27;</span>,</span><br><span class="line">            component: Chinese</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/english&#x27;</span>,</span><br><span class="line">            component: English,</span><br><span class="line">            <span class="comment">//通过children配置子级路由</span></span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;book&#x27;</span>,</span><br><span class="line">                    component: Book</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">                    component: Author</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>路由跳转:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/english/book&quot;</span>&gt;</span>Book<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/english/author&quot;</span>&gt;</span>Author<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h1><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&#x27;chineseRouter&#x27;</span>,</span><br><span class="line">            path: <span class="string">&#x27;/chinese&#x27;</span>,</span><br><span class="line">            component: Chinese</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/english&#x27;</span>,</span><br><span class="line">            component: English,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: <span class="string">&#x27;bookRouter&#x27;</span>,</span><br><span class="line">                    path: <span class="string">&#x27;book&#x27;</span>,</span><br><span class="line">                    component: Book</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: <span class="string">&#x27;authorRouter&#x27;</span>,</span><br><span class="line">                    path: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">                    component: Author</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>路由跳转:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=<span class="string">&quot;/english/book&quot;</span>&gt;Book&lt;/router-link&gt;</span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;name : &#x27;bookRouter&#x27;&#125;&quot;</span>&gt;Book&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;</span>&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">  path: &#x27;/english/author/info&#x27;,</span></span><br><span class="line"><span class="string">  query: &#123;</span></span><br><span class="line"><span class="string">      id: author.id,</span></span><br><span class="line"><span class="string">      name: author.name,</span></span><br><span class="line"><span class="string">      info: author.info</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&quot;</span>&gt;</span><br><span class="line">&#123;&#123; author.name &#125;&#125;</span><br><span class="line">&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;    </span><br></pre></td></tr></table></figure>

<p>接收参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>编号: &#123;&#123;$route.query.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>作家: &#123;&#123;$route.query.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>简介: &#123;&#123;$route.query.info&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="路由的param参数"><a href="#路由的param参数" class="headerlink" title="路由的param参数"></a>路由的param参数</h1><p>在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;bookRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;book&#x27;</span>,</span><br><span class="line">        component: Book</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;authorRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">        component: Author,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;authorInfoRouter&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;info/:id/:name/:info&#x27;</span>,<span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">                component: AuthorInfo</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>路由跳转:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  name: &#x27;authorInfoRouter&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="string">  params: &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">      id: author.id,</span></span></span><br><span class="line"><span class="tag"><span class="string">      name: author.name,</span></span></span><br><span class="line"><span class="tag"><span class="string">      info: author.info</span></span></span><br><span class="line"><span class="tag"><span class="string">  &#125;</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; author.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red">特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</span></p>
</blockquote>
<p>接受参数:</p>
<p>当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>编号: &#123;&#123;$route.params.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>作家: &#123;&#123;$route.params.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>简介: &#123;&#123;$route.params.info&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h1><p>在上面的例子中，我们读取参数需要不停重复的写 <code>this.$route.params</code> 前缀，很繁琐，使用props配置可以解决</p>
<h2 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h2><p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性。</p>
<p>若<code>props</code>为true，就会把路由组件收到的所有<span style="color:red"><code>params</code></span>参数，以<code>props</code>的形式传给AuthorInfo组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;authorInfoRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;info/:id/:name/:info&#x27;</span>,</span><br><span class="line">        component: AuthorInfo,</span><br><span class="line">        props: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>使用<code>props</code> 配置项接受参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    props: [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;info&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//这里存放数据</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>使用参数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>编号: &#123;&#123;id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>作家: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>简介: &#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h2><p>你可以创建一个函数返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;authorInfoRouter&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">        component: AuthorInfo,</span><br><span class="line">        <span class="function"><span class="title">props</span>(<span class="params">$route</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                id: $route.query.id,</span><br><span class="line">                name: $route.query.name,</span><br><span class="line">                info: $route.query.info</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>props</code>函数的结构赋值形式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">props</span>(<span class="params">&#123;query: &#123;id, name, info&#125;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        name: name,</span><br><span class="line">        info: info</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lt-router-link-gt-的replace属性"><a href="#lt-router-link-gt-的replace属性" class="headerlink" title="&lt;router-link&gt;的replace属性"></a><code>&lt;router-link&gt;</code>的replace属性</h1><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录（相当于向一个栈中添加元素），<code>replace</code>是替换当前记录（相当于替换掉栈顶元素）。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h1 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h1><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法<code>push</code>，通过编写代码来实现。</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td><code>router.push(...)</code></td>
</tr>
</tbody></table>
<p><strong>注意：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</strong></p>
<p><code>router.push(location, onComplete?, onAbort?)</code></p>
<p>可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; </span><br><span class="line">    name: <span class="string">&#x27;user&#x27;</span>, </span><br><span class="line">    params: &#123; </span><br><span class="line">        userId: <span class="string">&#x27;123&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; </span><br><span class="line">    path: <span class="string">&#x27;register&#x27;</span>, </span><br><span class="line">    query: &#123; </span><br><span class="line">        plan: <span class="string">&#x27;private&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，使用<code>params</code>就不用<code>path</code>，而是用<code>name</code></strong></p>
<p><code>router.replace(location, onComplete?, onAbort?)</code></p>
<p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录，相当于替换掉栈顶元素。</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td><code>router.replace(...)</code></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.replace(&#123; </span><br><span class="line">    path: <span class="string">&#x27;register&#x27;</span>, </span><br><span class="line">    query: &#123; </span><br><span class="line">        plan: <span class="string">&#x27;private&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>forward</code>  、<code>back</code>  、<code>go</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.forward() <span class="comment">//前进</span></span><br><span class="line"><span class="built_in">this</span>.$router.back() <span class="comment">//后退</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(-<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><ul>
<li><p><strong>Props</strong>：</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>
<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>
</li>
</ul>
<p>主要用于保留组件状态或避免重新渲染。</p>
<p><code>include</code> 和 <code>exclude</code> prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组（组件名）来表示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;News&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="路由相关的两个生命周期钩子"><a href="#路由相关的两个生命周期钩子" class="headerlink" title="路由相关的两个生命周期钩子"></a>路由相关的两个生命周期钩子</h1><h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件激活时调用。</p>
</li>
<li><p><strong>代码</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">//import 引入的组件需要注入到对象中才能使用</span></span><br><span class="line">  name: <span class="string">&quot;English&quot;</span>,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//这里存放数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//计算属性类似于data 概念</span></span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;&#125;, <span class="comment">// 被 keep-alive 缓存的组件激活时调用。</span></span><br><span class="line">  <span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">// 被 keep-alive 缓存的组件停用时调用。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件停用时调用。</p>
</li>
</ul>
<hr>
<h1 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h1><p>作用：对路由进行权限控制</p>
<h2 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h2><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><strong><code>to: Route</code></strong>: 即将要进入的目标路由对象</li>
<li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li>
<li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul>
<li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li>
<li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <code>router-link</code> 的 <code>to</code> prop 或 <code>router.push</code>中的选项。</li>
<li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError()</code>注册过的回调。</li>
</ul>
</li>
</ul>
<blockquote>
<p><span style="color:red"><strong>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错</strong>。</span></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h2><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h2><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这些守卫与全局前置守卫的方法参数是一样的</p>
<h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h2><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code> (2.2 新增)</li>
<li><code>beforeRouteLeave</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">//import 引入的组件需要注入到对象中才能使用</span></span><br><span class="line">  name: <span class="string">&quot;English&quot;</span>,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//这里存放数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过路由规则，进入该组件时被调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过路由规则，离开该组件时被调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>定义路由的时候可以配置 <code>meta</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">          component: Bar,</span><br><span class="line">          <span class="comment">// a meta field</span></span><br><span class="line">          meta: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过<code>to.meta.requiresAuth</code>访问</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/Vuex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/08/Vuex/" class="post-title-link" itemprop="url">Vuex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-08 09:38:03" itemprop="dateCreated datePublished" datetime="2021-09-08T09:38:03+08:00">2021-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 17:05:37" itemprop="dateModified" datetime="2023-09-05T17:05:37+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex?"></a>什么是Vuex?</h1><p>Vuex是专门在Vue 中实现集中式状态（数据）管理的一个Vue 插件，对vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<p>当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
<p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p>
<p>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想.</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/vuex.png"></p>
<h1 id="什么情况下我应该使用-Vuex？"><a href="#什么情况下我应该使用-Vuex？" class="headerlink" title="什么情况下我应该使用 Vuex？"></a>什么情况下我应该使用 Vuex？</h1><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>
<blockquote>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>
</blockquote>
<hr>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装vuex"><a href="#安装vuex" class="headerlink" title="安装vuex"></a>安装vuex</h2><p><code>NPM</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex </span><br></pre></td></tr></table></figure>

<h2 id="使用Store"><a href="#使用Store" class="headerlink" title="使用Store"></a>使用Store</h2><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
</li>
<li><p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用</p>
</li>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<p>为了在 Vue 组件中访问 <code>this.$store</code> property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 <code>store</code> 选项的方式“注入”该 store 的机制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store: store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 ES6，你也可以以 ES6 对象的 property 简写 (用在对象某个 property 的 key 和被传入的变量同名时)：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在子组件<span style="color:red">HelloWorld</span>中绑定一个方法，用来改变store中的数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前的值是:&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increase&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;increment&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完善<code>src/store/index.js</code>中的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="comment">//  Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 		   			context.state 和 context.getters 来获取 state 和 getters。</span></span><br><span class="line">        <span class="comment">// 参数value值是通过dispatch方法传过来的参数</span></span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">context, value</span>)</span> &#123;</span><br><span class="line">            context.commit(<span class="string">&quot;increment&quot;</span>,value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state,value</span>)</span> &#123;</span><br><span class="line">            state.count += value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>效果</p>
<p>点击按钮前：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/vuexchangebefore.png"></p>
<p>点击按钮5下后</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/vuexchangeafter.png"></p>
</li>
</ol>
<hr>
<h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>Getter 接受 state 作为其第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="function"><span class="title">increase</span>(<span class="params">context, value</span>)</span> &#123;</span><br><span class="line">            context.commit(<span class="string">&quot;increase&quot;</span>,value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        dollar: <span class="number">0</span>,</span><br><span class="line">        rate: <span class="number">7</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        <span class="function"><span class="title">rmb</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state.dollar * state.rate</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">increase</span>(<span class="params">state,value</span>)</span> &#123;</span><br><span class="line">            state.dollar += value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.getters.rmb </span><br></pre></td></tr></table></figure>

<h2 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h2><p>先引入mapGetters </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数组写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h2><p>先引入mapState </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p>
<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>对象写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  count:<span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="mapActions-辅助函数"><a href="#mapActions-辅助函数" class="headerlink" title="mapActions 辅助函数"></a>mapActions 辅助函数</h2><p>先导入mapActions </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数组写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   ...mapActions([</span><br><span class="line">     <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">     <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">   ]),</span><br><span class="line">   ...mapActions(&#123;</span><br><span class="line">     add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对象写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...mapActions(&#123;</span><br><span class="line">  add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="mapMutations-辅助函数"><a href="#mapMutations-辅助函数" class="headerlink" title="mapMutations 辅助函数"></a>mapMutations 辅助函数</h2><p>先导入mapActions </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数组写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">]),</span><br></pre></td></tr></table></figure>

<p>对象写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...mapMutations(&#123;</span><br><span class="line">  add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Module模块化"><a href="#Module模块化" class="headerlink" title="Module模块化"></a>Module模块化</h1><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  namespaced:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  namespaced:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在组件中对数据进行读取:</strong></p>
<p>读取<span style="color:red"><code>state</code></span>数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数空间名称字符串，第二个参数是空间名称字符串的中的参数</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(<span class="string">&#x27;currency&#x27;</span>,[<span class="string">&#x27;dollar&#x27;</span>,<span class="string">&#x27;rate&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>读取<span style="color:red"><code>getters</code></span>数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数空间名称字符串</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters(<span class="string">&#x27;currency&#x27;</span>,[<span class="string">&#x27;rmb&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>组件中调用<span style="color:red"><code>dispatch</code></span>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;currency/increase&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">    <span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">    ...mapActions(<span class="string">&#x27;currency&#x27;</span>,[<span class="string">&#x27;increase&#x27;</span>])</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件中调用<span style="color:red"><code>commit</code></span>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addOnePerson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;person/addOnePerson&#x27;</span>,newPerson)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">    ...mapActions(<span class="string">&#x27;person&#x27;</span>,[<span class="string">&#x27;addOnePerson&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/03/Vue-CLI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wotzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cai">
      <meta itemprop="description" content="真正的大师永远都怀着一颗学徒的心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cai">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/03/Vue-CLI/" class="post-title-link" itemprop="url">Vue CLI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-03 19:05:48" itemprop="dateCreated datePublished" datetime="2021-09-03T19:05:48+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-19 15:21:00" itemprop="dateModified" datetime="2021-10-19T15:21:00+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vue-CLI的使用"><a href="#Vue-CLI的使用" class="headerlink" title="Vue-CLI的使用"></a>Vue-CLI的使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>vue脚手架的作用是用来自动一键生成vue+webpack的项目模版，包括依赖库，免去你手动安装各种插件，寻找各种cdn并一个个引入的麻烦。</p>
<p>vue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。</p>
<p>vue-cli是有Vue提供的一个官方cli，专门为单页面应用快速搭建繁杂的脚手架。它是用于自动生成vue.js+webpack的项目模板，是为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载，保存时 lint 校验，以及生产环境可用的构建版本</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Node 版本要求</p>
<p>Vue CLI 4.x 需要 <a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js</a> v8.9 或更高版本 (推荐 v10 以上)。你可以使用 <a target="_blank" rel="noopener" href="https://github.com/tj/n">n</a>，<a target="_blank" rel="noopener" href="https://github.com/creationix/nvm">nvm</a> 或 <a target="_blank" rel="noopener" href="https://github.com/coreybutler/nvm-windows">nvm-windows</a> 在同一台电脑中管理多个 Node 版本。</p>
<p>可以使用下列任一命令安装这个新的包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure>

<p>安装之后，你就可以在命令行中访问 <code>vue</code> 命令。你可以通过简单运行 <code>vue</code>，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。</p>
<p>你还可以用这个命令来检查其版本是否正确：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>如需升级全局的 Vue CLI 包，请运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm update -g @vue/cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn global upgrade --latest @vue/cli</span><br></pre></td></tr></table></figure>

<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>切换到你要创建项目的目录，然后运行以下命令来创建一个新项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure>

<p>你会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 Vue2或者Vue3，也可以选“手动选择特性”来选取需要的特性。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/vueprojectinit.png"></p>
<p><strong>使用图形化界面</strong></p>
<p>你也可以通过 <code>vue ui</code> 命令以图形化界面创建和管理项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure>

<p>上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/initprojectinweb.png"></p>
<h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如出现下载缓慢请配置npm 淘宝镜像：npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue 脚手架隐藏了所有webpack 相关的配置，若想查看具体的webpakc 配置，请执行：vue inspect &gt; output.js</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。你也可以使用 <code>package.json</code> 中的 <code>vue</code> 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p>
<p>这个文件应该导出一个包含了选项的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="type">&#123;import(&#x27;@vue/cli-service&#x27;).ProjectOptions&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板项目的结构"><a href="#模板项目的结构" class="headerlink" title="模板项目的结构"></a>模板项目的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules </span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico: 页签图标</span><br><span class="line">│   └── index.html: 主页面</span><br><span class="line">├── src</span><br><span class="line">│   ├── assets: 存放静态资源</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   │── component: 存放组件</span><br><span class="line">│   │   └── HelloWorld.vue</span><br><span class="line">│   │── App.vue: 汇总所有组件</span><br><span class="line">│   │── main.js: 入口文件</span><br><span class="line">├── .gitignore: git版本管制忽略的配置</span><br><span class="line">├── babel.config.js: babel的配置文件</span><br><span class="line">├── package.json: 应用包配置文件 </span><br><span class="line">├── README.md: 应用描述文件</span><br><span class="line">├── package-lock.json：包版本控制文件</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h1><p><code>ref</code> 被用来给元素或子组件注册引用信息。</p>
<ul>
<li>引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素（id的替代者）；</li>
<li>如果用在子组件上，引用就指向组件实例<code>VueComponent</code>：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;p&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p>
<p>获取：<code>this.$refs.xxx</code></p>
<hr>
<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><p>props 可以是数组或对象，用于接收来自父组件的数据。</p>
<p><strong>三种读取方式</strong></p>
<ul>
<li><p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单语法</span></span><br><span class="line">Vue.component(<span class="string">&#x27;props-demo-simple&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;myMessage&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定名称和类型</span></span><br><span class="line">Vue.component(<span class="string">&#x27;props-demo-simple&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span>,</span><br><span class="line">    likes: <span class="built_in">Number</span>,</span><br><span class="line">    isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">    commentIds: <span class="built_in">Array</span>,</span><br><span class="line">    author: <span class="built_in">Object</span>,</span><br><span class="line">    callback: <span class="built_in">Function</span>,</span><br><span class="line">    contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象语法，提供验证</span></span><br><span class="line">Vue.component(<span class="string">&#x27;props-demo-advanced&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 检测类型</span></span><br><span class="line">    height: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 检测类型 + 其他验证</span></span><br><span class="line">    age: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span>, <span class="comment">// 默认值</span></span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h1 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h1><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p>
<p>当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个混入对象</span></span><br><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混入对象的局部使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个使用混入对象的组件</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</span><br><span class="line">  mixins: [mixin]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<p>如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。</p>
<p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p>
<p>全局使用</p>
<p>全局混入：<code>Vue.mixin(xxx)</code></p>
<p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p>
<hr>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>
<ol>
<li>添加全局方法或者 property。如：vue-custom-element</li>
<li>添加全局资源：指令/过滤器/过渡等。如 vue-touch</li>
<li>通过全局混入来添加一些组件选项。如 vue-router</li>
<li>添加 Vue 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router</li>
</ol>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 `MyPlugin.install(Vue)`</span></span><br><span class="line">Vue.use(MyPlugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h1><ol>
<li><p>作用：让样式在局部生效，防止冲突。</p>
</li>
<li><p>写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">250px</span>) &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.list-container</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">      background: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这个可选 <code>scoped</code> attribute 会自动添加一个唯一的 attribute (比如 <code>data-v-21e5b78</code>) 为组件内 CSS 指定作用域，编译的时候 <code>.list-container:hover</code> 会被编译成类似 <code>.list-container[data-v-21e5b78]:hover</code>。</p>
<hr>
<h1 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h1><p>组件的自定义事件是一种组件间通信方式，适用于：子组件给父组件传递数据。</p>
<p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p>
<p><strong>步骤：</strong></p>
<p>先在父组件中给子组件<code>TodoFooter</code>绑定事件:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TodoFooter</span> @<span class="attr">custom-event</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TodoFooter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并在<code>methods</code>中定义doSomething回调方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子组件中绑定一个按钮来触发自定义事件:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;triggerCustomEvent&quot;</span>&gt;</span>触发自定义事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>触发自定义事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">triggerCustomEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$emit(<span class="string">&quot;custom-event&quot;</span>,<span class="string">&quot;doSomething...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面绑定自定义事件还有第二种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TodoFooter ref=<span class="string">&quot;todofooter&quot;</span>&gt;&lt;/TodoFooter&gt;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.$refs.todofooter.$on(<span class="string">&quot;custom-event&quot;</span>,<span class="built_in">this</span>.doSomething)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>解绑自定义事件：</strong></p>
<p><strong>vm.$off( [event, callback] )</strong></p>
<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>&#123;string | Array&lt;string&gt;&#125; event</code> (只在 2.2.2+ 支持数组)</li>
<li><code>&#123;Function&#125; [callback]</code></li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p>移除自定义事件监听器。</p>
<ul>
<li>如果没有提供参数，则移除所有的事件监听器；</li>
<li>如果只提供了事件，则移除该事件所有的监听器；</li>
<li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$off(<span class="string">&quot;custom-event&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>将原生事件绑定到组件</strong></p>
<p>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TodoFooter</span> @<span class="attr">click.native</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TodoFooter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h1><p>vue组件中的数据传递最最常见的就是父子组件之间的传递。父传子通过props向下传递数据给子组件；子传父通过$emit发送事件，并携带数据给父组件。而有时两个组件之间毫无关系，或者他们之间的结构复杂，如何传递数据呢？这时就要用到 vue 中的事件总线 EventBus的概念。</p>
<h2 id="使用-EventBus"><a href="#使用-EventBus" class="headerlink" title="使用 EventBus"></a>使用 EventBus</h2><ul>
<li>第一种方式: 可以在 main.js中，初始化 EventBus</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Vue.prototype.$bus = <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>X组件想接收数据，则在X组件中给<code>$bus</code>绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">methods</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">demo</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="built_in">this</span>.demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Y组件想要给X组件传递数据，则在Y组件中发送事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;xxxx&#x27;</span>,param)</span><br></pre></td></tr></table></figure>

<p>在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件</p>
<p>语法：<code>this.$EventBus.$off(要移除监听的事件名)</code></p>
<hr>
<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h1><h3 id="vm-nextTick-callback"><a href="#vm-nextTick-callback" class="headerlink" title="vm.$nextTick( [callback] )"></a>vm.$nextTick( [callback] )</h3><ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>&#123;Function&#125; [callback]</code></li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p>将回调延迟到下次 DOM 更新循环之后执行。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    example: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 修改数据</span></span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;changed&#x27;</span></span><br><span class="line">      <span class="comment">// DOM 还没有更新</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// DOM 现在更新了</span></span><br><span class="line">        <span class="comment">// `this` 绑定到当前实例</span></span><br><span class="line">        <span class="built_in">this</span>.doSomethingElse()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h1><h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>这里是一个典型的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li>
</ol>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/transition.png"></p>
<p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p>
<p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入/离开过渡的不同的缓和曲线。</p>
<h2 id="CSS-过渡"><a href="#CSS-过渡" class="headerlink" title="CSS 过渡"></a>CSS 过渡</h2><p>常用的过渡都是使用 CSS 过渡。</p>
<p>下面是一个简单例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle render</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;slide-fade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example-1&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以设置不同的进入和离开动画 */</span></span><br><span class="line"><span class="comment">/* 设置持续时间和动画函数 */</span></span><br><span class="line"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三方-CSS-动画库"><a href="#第三方-CSS-动画库" class="headerlink" title="第三方 CSS 动画库"></a>第三方 CSS 动画库</h2><p>我们可以通过以下 attribute 来自定义过渡类名：</p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <a target="_blank" rel="noopener" href="https://daneden.github.io/animate.css/">Animate.css</a> 结合使用十分有用。</p>
<p>Install with npm:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install animate.css</span></span><br></pre></td></tr></table></figure>

<p>Import it into your file:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;animate.css&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span>Toggle render<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;animate__animated animate__bounce&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">enter-active-class</span>=<span class="string">&quot;animate__bounce&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">leave-active-class</span>=<span class="string">&quot;animate__backOutDown&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>An animated element<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么怎么同时渲染整个列表，比如使用 <code>v-for</code>？在这种场景中，使用 <code>&lt;transition-group&gt;</code> 组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p>
<ul>
<li>不同于 <code>&lt;transition&gt;</code>，它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 <code>tag</code> attribute 更换为其他元素。</li>
<li>过渡模式不可用，因为我们不再相互切换特有的元素。</li>
<li>内部元素<strong>总是需要</strong>提供唯一的 <code>key</code> attribute 值。</li>
<li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。</li>
</ul>
<hr>
<h1 id="Vue-CLI配置代理"><a href="#Vue-CLI配置代理" class="headerlink" title="Vue-CLI配置代理"></a>Vue-CLI配置代理</h1><p>如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在开发环境下将 API 请求代理到 API 服务器。这个问题可以通过 <code>vue.config.js</code> 中的 <code>devServer.proxy</code> 选项来配置。</p>
<p>resolve <code>CORS policy</code> <code>Access-Control-Allow-Origin</code></p>
<ul>
<li><code>devServer.proxy</code> 可以是一个指向开发环境 API 服务器的字符串：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:4000&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会告诉开发服务器将任何未知请求 (没有匹配到静态文件的请求) 代理到<code>http://localhost:4000</code>。</p>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<p><strong>配置多个代理</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	devServer: &#123;</span><br><span class="line">      proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        target: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        target: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<hr>
<h1 id="插槽-slot"><a href="#插槽-slot" class="headerlink" title="插槽(slot)"></a>插槽(slot)</h1><p>Slot 通俗的理解就是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中<span style="color:red"><code>slot</code></span>位置）<br>并且可以作为承载分发内容的出口</p>
<p>因为在2.6.0中，<strong>具名插槽</strong> 和 <strong>作用域插槽</strong> 引入了一个新的统一的语法 (即<span style="color:red"><code>v-slot</code></span> 指令)。它取代了 <span style="color:red"><code>slot</code></span> 和 <span style="color:red"><code>slot-scope</code></span></p>
<h2 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h2><p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a target="_blank" rel="noopener" href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components 规范草案</a>，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>
<p>它允许你像这样合成组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">  Hello World</span><br><span class="line"><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后你在 <code>HelloWorld</code> 组件中可能会写为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Hello World”。插槽内可以包含任何模板代码，包括 HTML。</p>
<p>如果<code>HelloWorld</code> 组件 的 <code>template</code> 中<strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签<span style="color:red"><code>&lt;HelloWorld&gt;</code></span>和结束标签 <span style="color:red"><code>&lt;/HelloWorld&gt;</code></span>之间的任何内容都会被抛弃。</p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在 <span style="color:red"><code>&lt;template&gt;</code></span>元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有<span style="color:red"><code>v-solt</code></span>的 <span style="color:red"><code>&lt;template&gt;</code></span> 中的内容都会被视为默认插槽的内容。</p>
<p>然而，如果你希望更明确一些，仍然可以在一个 <span style="color:red"><code>&lt;template&gt;</code></span> 中包裹默认插槽的内容：<span style="color:red"><code>&lt;template&gt;</code></span></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>任何一种写法都会渲染出：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意 v-slot 只能添加在 &lt;template&gt; 上</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h2><p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，父组件访问子组件中才有的数据</p>
<p>在子组件<span style="color:red"><code>HelloWorld</code></span>中先定义数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        firstName : <span class="string">&#x27;张&#x27;</span>,</span><br><span class="line">        lastName : <span class="string">&#x27;三&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在父组件中使用子组件的数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123;user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>法外狂徒&#123;&#123; user.firstName &#125;&#125;&#123;&#123; user.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/Vue%E5%9F%BA%E7%A1%80/slotshow.png"></p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wotzc</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/wotzc" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
